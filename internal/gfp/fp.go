// Code generated by 'gofp'. DO NOT EDIT.
package gfp
import _ "reflect" 
import "sync" 
import "github.com/logic-building/functional-go/fp" 
import "github.com/logic-building/functional-go/internal/employee" 
import "github.com/logic-building/functional-go/internal/employer" 

func MapEmployer(f func(employer.Employer) employer.Employer, list []employer.Employer) []employer.Employer {
	if f == nil {
		return []employer.Employer{}
	}
	newList := make([]employer.Employer, len(list))
	for i, v := range list {
		newList[i] = f(v)
	}
	return newList
}

func MapEmployerPtr(f func(*employer.Employer) *employer.Employer, list []*employer.Employer) []*employer.Employer {
	if f == nil {
		return []*employer.Employer{}
	}
	newList := make([]*employer.Employer, len(list))
	for i, v := range list {
		newList[i] = f(v)
	}
	return newList
}

// MapEmployerPtrErr takes 2 arguments:
//  1. A function input argument: *employer.Employer and return types (*employer.Employer, error)
//  2. A list of type []*employer.Employer
//
// Returns:
// 	([]*employer.Employer, error)
func MapEmployerPtrErr(f func(*employer.Employer) (*employer.Employer, error), list []*employer.Employer) ([]*employer.Employer, error) {
	if f == nil {
		return []*employer.Employer{}, nil
	}
	newList := make([]*employer.Employer, len(list))
	for i, v := range list {
		var err error
		newList[i], err = f(v)
		if err != nil {
			return nil, err
		}
	}
	return newList, nil
}

// MapEmployerErr takes 2 arguments:
//  1. A function input argument: employer.Employer and return types (employer.Employer, error)
//  2. A list of type []employer.Employer
//
// Returns:
// 	([]employer.Employer, error)
func MapEmployerErr(f func(employer.Employer) (employer.Employer, error), list []employer.Employer) ([]employer.Employer, error) {
	if f == nil {
		return []employer.Employer{}, nil
	}
	newList := make([]employer.Employer, len(list))
	for i, v := range list {
		var err error
		newList[i], err = f(v)
		if err != nil {
			return nil, err
		}
	}
	return newList, nil
}

func FilterEmployer(f func(employer.Employer) bool, list []employer.Employer) []employer.Employer {
	if f == nil {
		return []employer.Employer{}
	}
	var newList []employer.Employer
	for _, v := range list {
		if f(v) {
			newList = append(newList, v)
		}
	}
	return newList
}

func FilterEmployerPtr(f func(*employer.Employer) bool, list []*employer.Employer) []*employer.Employer {
	if f == nil {
		return []*employer.Employer{}
	}
	var newList []*employer.Employer
	for _, v := range list {
		if f(v) {
			newList = append(newList, v)
		}
	}
	return newList
}

// FilterEmployerPtrErr takes two arguments
//  1. Function: takes 1 argument of type employer.Employer and returns (bool, error)
//  2. slice of type []*employer.Employer
//
// Returns:
//  new filtered list and error
func FilterEmployerPtrErr(f func(*employer.Employer) (bool, error), list []*employer.Employer) ([]*employer.Employer, error) {
	if f == nil {
		return []*employer.Employer{}, nil
	}
	var newList []*employer.Employer
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if r {
			newList = append(newList, v)
		}
	}
	return newList, nil
}

// FilterEmployerErr takes two arguments
//  1. Function: takes 1 argument of type employer.Employer and returns (bool, error)
//  2. slice of type []employer.Employer
//
// Returns:
//  new filtered list and error
func FilterEmployerErr(f func(employer.Employer) (bool, error), list []employer.Employer) ([]employer.Employer, error) {
	if f == nil {
		return []employer.Employer{}, nil
	}
	var newList []employer.Employer
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if r {
			newList = append(newList, v)
		}
	}
	return newList, nil
}

func RemoveEmployer(f func(employer.Employer) bool, list []employer.Employer) []employer.Employer {
	if f == nil {
		return []employer.Employer{}
	}
	var newList []employer.Employer
	for _, v := range list {
		if !f(v) {
			newList = append(newList, v)
		}
	}
	return newList
}

func RemoveEmployerPtr(f func(*employer.Employer) bool, list []*employer.Employer) []*employer.Employer {
	if f == nil {
		return []*employer.Employer{}
	}
	var newList []*employer.Employer
	for _, v := range list {
		if !f(v) {
			newList = append(newList, v)
		}
	}
	return newList
}

// RemoveEmployerPtrErr removes the items from the given list based on supplied function and returns new list
//
// Takes 2 inputs:
//	1. Function: input type *employer.Employer and return types(bool, error)
//	2. List of type: []*employer.Employer
//
// Returns:
//	New list and error: ([]*employer.Employer, error)
//	Empty list if both of arguments are nil or either one is nil.
func RemoveEmployerPtrErr(f func(*employer.Employer) (bool, error), list []*employer.Employer) ([]*employer.Employer, error) {
	if f == nil {
		return []*employer.Employer{}, nil
	}
	var newList []*employer.Employer
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if !r {
			newList = append(newList, v)
		}
	}
	return newList, nil
}

// RemoveEmployerErr removes the items from the given list based on supplied function and returns new list
//
// Takes 2 inputs:
//	1. Function: input type employer.Employer and return types(bool, error)
//	2. List of type: []employer.Employer
//
// Returns:
//	New list and error: ([]employer.Employer, error)
//	Empty list if both of arguments are nil or either one is nil.
func RemoveEmployerErr(f func(employer.Employer) (bool, error), list []employer.Employer) ([]employer.Employer, error) {
	if f == nil {
		return []employer.Employer{}, nil
	}
	var newList []employer.Employer
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if !r {
			newList = append(newList, v)
		}
	}
	return newList, nil
}

func SomeEmployer(f func(employer.Employer) bool, list []employer.Employer) bool {
	if f == nil {
		return false
	}
	for _, v := range list {
		if f(v) {
			return true
		}
	}
	return false
}

func SomeEmployerPtr(f func(*employer.Employer) bool, list []*employer.Employer) bool {
	if f == nil {
		return false
	}
	for _, v := range list {
		if f(v) {
			return true
		}
	}
	return false
}

// SomeEmployerPtrErr finds item in the list based on supplied function.
//
// Takes 2 input:
//	1. Function
//	2. List
//
// Returns:
//	(bool,err).
//	True if condition satisfies, else false
func SomeEmployerPtrErr(f func(*employer.Employer) (bool, error), list []*employer.Employer) (bool, error) {
	if f == nil {
		return false, nil
	}
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return false, err
		}
		if r {
			return true, nil
		}
	}
	return false, nil
}

// SomeEmployerErr finds item in the list based on supplied function.
//
// Takes 2 input:
//	1. Function
//	2. List
//
// Returns:
//	(bool,err).
//	True if condition satisfies, else false
func SomeEmployerErr(f func(employer.Employer) (bool, error), list []employer.Employer) (bool, error) {
	if f == nil {
		return false, nil
	}
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return false, err
		}
		if r {
			return true, nil
		}
	}
	return false, nil
}

func EveryEmployer(f func(employer.Employer) bool, list []employer.Employer) bool {
	if f == nil || len(list) == 0 {
		return false
	}
	for _, v := range list {
		if !f(v) {
			return false
		}
	}
	return true
}

func EveryEmployerPtr(f func(*employer.Employer) bool, list []*employer.Employer) bool {
	if f == nil || len(list) == 0 {
		return false
	}
	for _, v := range list {
		if !f(v) {
			return false
		}
	}
	return true
}

// EveryEmployerPtrErr returns true if supplied function returns logical true for every item in the list
func EveryEmployerPtrErr(f func(*employer.Employer) (bool, error), list []*employer.Employer) (bool, error) {
	if f == nil || len(list) == 0 {
		return false, nil
	}
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return false, err
		}
		if !r {
			return false, nil
		}
	}
	return true, nil
}

// EveryEmployerErr returns true if supplied function returns logical true for every item in the list
func EveryEmployerErr(f func(employer.Employer) (bool, error), list []employer.Employer) (bool, error) {
	if f == nil || len(list) == 0 {
		return false, nil
	}
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return false, err
		}
		if !r {
			return false, nil
		}
	}
	return true, nil
}

func DropWhileEmployer(f func(employer.Employer) bool, list []employer.Employer) []employer.Employer {
	if f == nil {
		return []employer.Employer{}
	}
	var newList []employer.Employer
	for i, v := range list {
		if !f(v) {
			listLen := len(list)
			newList = make([]employer.Employer, listLen-i)
			j := 0
			for i < listLen {
				newList[j] = list[i]
				i++
				j++
			}
			return newList
		}
	}
	return newList
}

func DropWhileEmployerPtr(f func(*employer.Employer) bool, list []*employer.Employer) []*employer.Employer {
	if f == nil {
		return []*employer.Employer{}
	}
	var newList []*employer.Employer
	for i, v := range list {
		if !f(v) {
			listLen := len(list)
			newList = make([]*employer.Employer, listLen-i)
			j := 0
			for i < listLen {
				newList[j] = list[i]
				i++
				j++
			}
			return newList
		}
	}
	return newList
}

// DropWhileEmployerPtrErr drops the items from the list as long as condition satisfies.
//
// Takes two inputs
//	1. Function: takes one input and returns (boolean, error)
//	2. list
//
// Returns:
// 	New List, error
//  Empty list if either one of arguments or both of them are nil
func DropWhileEmployerPtrErr(f func(*employer.Employer) (bool, error), list []*employer.Employer) ([]*employer.Employer, error) {
	if f == nil {
		return []*employer.Employer{}, nil
	}
	var newList []*employer.Employer
	for i, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if !r {
			listLen := len(list)
			newList = make([]*employer.Employer, listLen-i)
			j := 0
			for i < listLen {
				newList[j] = list[i]
				i++
				j++
			}
			return newList, nil
		}
	}
	return newList, nil
}

// DropWhileEmployerErr drops the items from the list as long as condition satisfies.
//
// Takes two inputs
//	1. Function: takes one input and returns (boolean, error)
//	2. list
//
// Returns:
// 	New List, error
//  Empty list if either one of arguments or both of them are nil
func DropWhileEmployerErr(f func(employer.Employer) (bool, error), list []employer.Employer) ([]employer.Employer, error) {
	if f == nil {
		return []employer.Employer{}, nil
	}
	var newList []employer.Employer
	for i, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if !r {
			listLen := len(list)
			newList = make([]employer.Employer, listLen-i)
			j := 0
			for i < listLen {
				newList[j] = list[i]
				i++
				j++
			}
			return newList, nil
		}
	}
	return newList, nil
}

func TakeWhileEmployer(f func(employer.Employer) bool, list []employer.Employer) []employer.Employer {
	if f == nil {
		return []employer.Employer{}
	}
	var newList []employer.Employer
	for _, v := range list {
		if !f(v) {
			return newList
		}
		newList = append(newList, v)
	}
	return newList
}

func TakeWhileEmployerPtr(f func(*employer.Employer) bool, list []*employer.Employer) []*employer.Employer {
	if f == nil {
		return []*employer.Employer{}
	}
	var newList []*employer.Employer
	for _, v := range list {
		if !f(v) {
			return newList
		}
		newList = append(newList, v)
	}
	return newList
}

// TakeWhileEmployerPtrErr returns new list based on condition in the supplied function. It returns new list once condition fails.
//
// Takes 2 inputs:
//	1. Function - 1 input of type *employer.Employer and returns ([]*employer.Employer, error)
//	2. List
//
// Returns:
//	New List, error.
//	Empty list if all the parameters are nil or either of one parameter is nil
func TakeWhileEmployerPtrErr(f func(*employer.Employer) (bool, error), list []*employer.Employer) ([]*employer.Employer, error) {
	if f == nil {
		return []*employer.Employer{}, nil
	}
	var newList []*employer.Employer
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if !r {
			return newList, nil
		}
		newList = append(newList, v)
	}
	return newList, nil
}

// TakeWhileEmployerErr returns new list based on condition in the supplied function. It returns new list once condition fails.
//
// Takes 2 inputs:
//	1. Function - 1 input of type employer.Employer and returns ([]employer.Employer, error)
//	2. List
//
// Returns:
//	New List, error.
//	Empty list if all the parameters are nil or either of one parameter is nil
func TakeWhileEmployerErr(f func(employer.Employer) (bool, error), list []employer.Employer) ([]employer.Employer, error) {
	if f == nil {
		return []employer.Employer{}, nil
	}
	var newList []employer.Employer
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if !r {
			return newList, nil
		}
		newList = append(newList, v)
	}
	return newList, nil
}

// PMapEmployer applies the function(1st argument) on each item in the list and returns a new list.
//  Order of new list is guaranteed. This feature can be disabled by passing: Optional{RandomOrder: true} to gain performance
//  Run in parallel. no_of_goroutines = no_of_items_in_list or 3rd argument can be passed to fix the number of goroutines.
//
// Takes 3 inputs. 3rd argument is optional
//  1. Function - takes 1 input
//  2. List
//  3. optional argument - fp.Optional{FixedPool: <some_number>}
func PMapEmployer(f func(employer.Employer) employer.Employer, list []employer.Employer, optional ...fp.Optional) []employer.Employer {
	if f == nil {
		return []employer.Employer{}
	}

	var worker = len(list)
	if optional != nil && len(optional) > 0 {
		if optional[0].FixedPool > 0 && optional[0].FixedPool < worker {
			worker = optional[0].FixedPool
		}

		if optional[0].RandomOrder == true {
			return pMapEmployerNoOrder(f, list, worker)
		}
	}

	return pMapEmployerPreserveOrder(f, list, worker)
}

func pMapEmployerPreserveOrder(f func(employer.Employer) employer.Employer, list []employer.Employer, worker int) []employer.Employer {
	chJobs := make(chan map[int]employer.Employer, len(list))
	go func() {
		for i, v := range list {
			chJobs <- map[int]employer.Employer{i: v}
		}
		close(chJobs)
	}()

	chResult := make(chan map[int]employer.Employer, worker/3)

	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan map[int]employer.Employer, chJobs chan map[int]employer.Employer) {
			defer wg.Done()

			for m := range chJobs {
				for k, v := range m {
					chResult <- map[int]employer.Employer{k: f(v)}
				}
			}
		}(chResult, chJobs)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newListMap := make(map[int]employer.Employer, len(list))
	newList := make([]employer.Employer, len(list))

	for m := range chResult {
		for k, v := range m {
			newListMap[k] = v
		}
	}

	for i := 0; i < len(list); i++ {
		newList[i] = newListMap[i]
	}

	return newList
}

func pMapEmployerNoOrder(f func(employer.Employer) employer.Employer, list []employer.Employer, worker int) []employer.Employer {
	chJobs := make(chan employer.Employer, len(list))
	go func() {
		for _, v := range list {
			chJobs <- v
		}
		close(chJobs)
	}()

	chResult := make(chan employer.Employer, worker/3)

	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan employer.Employer, chJobs chan employer.Employer) {
			defer wg.Done()

			for v := range chJobs {
				chResult <- f(v)
			}
		}(chResult, chJobs)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newList := make([]employer.Employer, len(list))
	i := 0

	for v := range chResult {
		newList[i] = v
		i++
	}

	return newList
}

// PMapEmployerPtr applies the function(1st argument) on each item in the list and returns a new list.
//  Order of new list is guaranteed. This feature can be disabled by passing: Optional{RandomOrder: true} to gain performance
//  Run in parallel. no_of_goroutines = no_of_items_in_list or 3rd argument can be passed to fix the number of goroutines.
//
// Takes 3 inputs. 3rd argument is optional
//  1. Function - takes 1 input
//  2. List
//  3. optional argument - fp.Optional{FixedPool: <some_number>}
func PMapEmployerPtr(f func(*employer.Employer) *employer.Employer, list []*employer.Employer, optional ...fp.Optional) []*employer.Employer {
	if f == nil {
		return []*employer.Employer{}
	}

	var worker = len(list)
	if optional != nil && len(optional) > 0 {
		if optional[0].FixedPool > 0 && optional[0].FixedPool < worker {
			worker = optional[0].FixedPool
		}

		if optional[0].RandomOrder == true {
			return pMapEmployerPtrNoOrder(f, list, worker)
		}
	}

	return pMapEmployerPtrPreserveOrder(f, list, worker)
}

func pMapEmployerPtrPreserveOrder(f func(*employer.Employer) *employer.Employer, list []*employer.Employer, worker int) []*employer.Employer {
	chJobs := make(chan map[int]*employer.Employer, len(list))
	go func() {
		for i, v := range list {
			chJobs <- map[int]*employer.Employer{i: v}
		}
		close(chJobs)
	}()

	chResult := make(chan map[int]*employer.Employer, worker/3)

	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan map[int]*employer.Employer, chJobs chan map[int]*employer.Employer) {
			defer wg.Done()

			for m := range chJobs {
				for k, v := range m {
					chResult <- map[int]*employer.Employer{k: f(v)}
				}
			}
		}(chResult, chJobs)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newListMap := make(map[int]*employer.Employer, len(list))
	newList := make([]*employer.Employer, len(list))

	for m := range chResult {
		for k, v := range m {
			newListMap[k] = v
		}
	}

	for i := 0; i < len(list); i++ {
		newList[i] = newListMap[i]
	}

	return newList
}

func pMapEmployerPtrNoOrder(f func(*employer.Employer) *employer.Employer, list []*employer.Employer, worker int) []*employer.Employer {
	chJobs := make(chan *employer.Employer, len(list))
	go func() {
		for _, v := range list {
			chJobs <- v
		}
		close(chJobs)
	}()

	chResult := make(chan *employer.Employer, worker/3)

	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan *employer.Employer, chJobs chan *employer.Employer) {
			defer wg.Done()

			for v := range chJobs {
				chResult <- f(v)
			}
		}(chResult, chJobs)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newList := make([]*employer.Employer, len(list))
	i := 0

	for v := range chResult {
		newList[i] = v
		i++
	}

	return newList
}

// PMapEmployerPtrErr applies the function(1st argument) on each item in the list and returns a new list and error.
//  Order of new list is guaranteed. This feature can be disabled by passing: Optional{RandomOrder: true} to gain performance
//  Run in parallel. no_of_goroutines = no_of_items_in_list or 3rd argument can be passed to fix the number of goroutines.
//
// Takes 3 inputs. 3rd argument is optional
//  1. Function - takes 1 input
//  2. List
//  3. optional argument - fp.Optional{FixedPool: <some_number>}
func PMapEmployerPtrErr(f func(*employer.Employer) (*employer.Employer, error), list []*employer.Employer, optional ...fp.Optional) ([]*employer.Employer, error) {
	if f == nil {
		return []*employer.Employer{}, nil
	}

	var worker = len(list)
	if optional != nil && len(optional) > 0 {
		if optional[0].FixedPool > 0 && optional[0].FixedPool < worker {
			worker = optional[0].FixedPool
		}

		if optional[0].RandomOrder == true {
			return pMapEmployerPtrErrNoOrder(f, list, worker)
		}
	}

	return pMapEmployerPtrErrPreserveOrder(f, list, worker)
}

func pMapEmployerPtrErrPreserveOrder(f func(*employer.Employer) (*employer.Employer, error), list []*employer.Employer, worker int) ([]*employer.Employer, error) {
	chJobs := make(chan map[int]*employer.Employer, len(list))
	go func() {
		for i, v := range list {
			chJobs <- map[int]*employer.Employer{i: v}
		}
		close(chJobs)
	}()

	chResult := make(chan map[int]*employer.Employer, worker/3)

	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan map[int]*employer.Employer, chJobs chan map[int]*employer.Employer, errCh chan error) {
			defer wg.Done()
			if len(errCh) > 0 {
				return
			}
			for m := range chJobs {
				for k, v := range m {
					r, err := f(v)
					if err != nil {
						errCh <- err
						return
					}
					chResult <- map[int]*employer.Employer{k: r}
				}
			}
		}(chResult, chJobs, errCh)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newListMap := make(map[int]*employer.Employer, len(list))
	newList := make([]*employer.Employer, len(list))

	for m := range chResult {
		select {
		case err := <-errCh:
			return []*employer.Employer{}, err
		default:
		}
		for k, v := range m {
			newListMap[k] = v
		}
	}

	if len(errCh) > 0 {
		return []*employer.Employer{}, <-errCh
	}

	for i := 0; i < len(list); i++ {
		newList[i] = newListMap[i]
	}

	return newList, nil
}

func pMapEmployerPtrErrNoOrder(f func(*employer.Employer) (*employer.Employer, error), list []*employer.Employer, worker int) ([]*employer.Employer, error) {
	chJobs := make(chan *employer.Employer, len(list))
	go func() {
		for _, v := range list {
			chJobs <- v
		}
		close(chJobs)
	}()

	chResult := make(chan *employer.Employer, worker/3)

	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan *employer.Employer, chJobs chan *employer.Employer, errCh chan error) {
			defer wg.Done()
			if len(errCh) > 0 {
				return
			}
			for v := range chJobs {
				r, err := f(v)
				if err != nil {
					errCh <- err
					return
				}
				chResult <- r
			}
		}(chResult, chJobs, errCh)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newList := make([]*employer.Employer, len(list))
	i := 0

	for v := range chResult {
		select {
		case err := <-errCh:
			return []*employer.Employer{}, err
		default:
		}
		newList[i] = v
		i++
	}

	if len(errCh) > 0 {
		return []*employer.Employer{}, <-errCh
	}

	return newList, nil
}

// PMapEmployerErr applies the function(1st argument) on each item in the list and returns a new list and error.
//  Order of new list is guaranteed. This feature can be disabled by passing: Optional{RandomOrder: true} to gain performance
//  Run in parallel. no_of_goroutines = no_of_items_in_list or 3rd argument can be passed to fix the number of goroutines.
//
// Takes 3 inputs. 3rd argument is optional
//  1. Function - takes 1 input
//  2. List
//  3. optional argument - fp.Optional{FixedPool: <some_number>}
func PMapEmployerErr(f func(employer.Employer) (employer.Employer, error), list []employer.Employer, optional ...fp.Optional) ([]employer.Employer, error) {
	if f == nil {
		return []employer.Employer{}, nil
	}

	var worker = len(list)
	if optional != nil && len(optional) > 0 {
		if optional[0].FixedPool > 0 && optional[0].FixedPool < worker {
			worker = optional[0].FixedPool
		}

		if optional[0].RandomOrder == true {
			return pMapEmployerErrNoOrder(f, list, worker)
		}
	}

	return pMapEmployerErrPreserveOrder(f, list, worker)
}

func pMapEmployerErrPreserveOrder(f func(employer.Employer) (employer.Employer, error), list []employer.Employer, worker int) ([]employer.Employer, error) {
	chJobs := make(chan map[int]employer.Employer, len(list))
	go func() {
		for i, v := range list {
			chJobs <- map[int]employer.Employer{i: v}
		}
		close(chJobs)
	}()

	chResult := make(chan map[int]employer.Employer, worker/3)

	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan map[int]employer.Employer, chJobs chan map[int]employer.Employer, errCh chan error) {
			defer wg.Done()
			if len(errCh) > 0 {
				return
			}
			for m := range chJobs {
				for k, v := range m {
					r, err := f(v)
					if err != nil {
						errCh <- err
						return
					}
					chResult <- map[int]employer.Employer{k: r}
				}
			}
		}(chResult, chJobs, errCh)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newListMap := make(map[int]employer.Employer, len(list))
	newList := make([]employer.Employer, len(list))

	for m := range chResult {
		select {
		case err := <-errCh:
			return []employer.Employer{}, err
		default:
		}
		for k, v := range m {
			newListMap[k] = v
		}
	}

	if len(errCh) > 0 {
		return []employer.Employer{}, <-errCh
	}

	for i := 0; i < len(list); i++ {
		newList[i] = newListMap[i]
	}

	return newList, nil
}

func pMapEmployerErrNoOrder(f func(employer.Employer) (employer.Employer, error), list []employer.Employer, worker int) ([]employer.Employer, error) {
	chJobs := make(chan employer.Employer, len(list))
	go func() {
		for _, v := range list {
			chJobs <- v
		}
		close(chJobs)
	}()

	chResult := make(chan employer.Employer, worker/3)

	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan employer.Employer, chJobs chan employer.Employer, errCh chan error) {
			defer wg.Done()
			if len(errCh) > 0 {
				return
			}
			for v := range chJobs {
				r, err := f(v)
				if err != nil {
					errCh <- err
					return
				}
				chResult <- r
			}
		}(chResult, chJobs, errCh)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newList := make([]employer.Employer, len(list))
	i := 0

	for v := range chResult {
		select {
		case err := <-errCh:
			return []employer.Employer{}, err
		default:
		}
		newList[i] = v
		i++
	}

	if len(errCh) > 0 {
		return []employer.Employer{}, <-errCh
	}

	return newList, nil
}

func FilterMapEmployer(fFilter func(employer.Employer) bool, fMap func(employer.Employer) employer.Employer, list []employer.Employer) []employer.Employer {
	if fFilter == nil || fMap == nil {
		return []employer.Employer{}
	}
	var newList []employer.Employer
	for _, v := range list {
		if fFilter(v) {
			newList = append(newList, fMap(v))
		}
	}
	return newList
}

func FilterMapEmployerPtr(fFilter func(*employer.Employer) bool, fMap func(*employer.Employer) *employer.Employer, list []*employer.Employer) []*employer.Employer {
	if fFilter == nil || fMap == nil {
		return []*employer.Employer{}
	}
	var newList []*employer.Employer
	for _, v := range list {
		if fFilter(v) {
			newList = append(newList, fMap(v))
		}
	}
	return newList
}

// FilterMapEmployerPtrErr filters given list, then apply function(2nd argument) on each item in the list and returns a new list
// Takes 3 inputs
//	1. Function: takes one input(*employer.Employer) and returns (bool, error).
//	2. Function: takes *employer.Employer as argument and returns (*employer.Employer, error)
// 	3. Slice of type []*employer.Employer
//
// Returns:
//	New List ([]*employer.Employer, error).
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapEmployerPtrErr(fFilter func(*employer.Employer) (bool, error), fMap func(*employer.Employer) (*employer.Employer, error), list []*employer.Employer) ([]*employer.Employer, error) {
	if fFilter == nil || fMap == nil {
		return []*employer.Employer{}, nil
	}
	var newList []*employer.Employer
	for _, v := range list {
		r, err := fFilter(v)
		if err != nil {
			return nil, err
		}
		if r {
			r, err := fMap(v)
			if err != nil {
				return nil, err
			}
			newList = append(newList, r)
		}
	}
	return newList, nil
}

// FilterMapEmployerErr filters given list, then apply function(2nd argument) on each item in the list and returns a new list
// Takes 3 inputs
//	1. Function: takes one input(employer.Employer) and returns (bool, error).
//	2. Function: takes employer.Employer as argument and returns (employer.Employer, error)
// 	3. Slice of type []employer.Employer
//
// Returns:
//	New List ([]employer.Employer, error).
//  Empty list if all there parameters are nil or either of parameter is nil
//
func FilterMapEmployerErr(fFilter func(employer.Employer) (bool, error), fMap func(employer.Employer) (employer.Employer, error), list []employer.Employer) ([]employer.Employer, error) {
	if fFilter == nil || fMap == nil {
		return []employer.Employer{}, nil
	}
	var newList []employer.Employer
	for _, v := range list {
		r, err := fFilter(v)
		if err != nil {
			return nil, err
		}
		if r {
			r, err := fMap(v)
			if err != nil {
				return nil, err
			}
			newList = append(newList, r)
		}
	}
	return newList, nil
}

func RestEmployer(l []employer.Employer) []employer.Employer {
	if l == nil {
		return []employer.Employer{}
	}

	len := len(l)
	if len == 0 || len == 1 {
		return []employer.Employer{}
	}

	newList := make([]employer.Employer, len-1)

	for i, v := range l[1:] {
		newList[i] = v
	}

	return newList
}


// RestEmployer removes 1st item of the list and return new list having rest of the items
func RestEmployerPtr(l []*employer.Employer) []*employer.Employer {
	if l == nil {
		return []*employer.Employer{}
	}

	len := len(l)
	if len == 0 || len == 1 {
		return []*employer.Employer{}
	}

	newList := make([]*employer.Employer, len-1)

	for i, v := range l[1:] {
		newList[i] = v
	}

	return newList
}

func ReduceEmployer(f func(employer.Employer, employer.Employer) employer.Employer, list []employer.Employer, initializer ...employer.Employer) employer.Employer {
	var init employer.Employer 
	lenList := len(list)

	if initializer != nil {
		init = initializer[0]
	} else if lenList > 0 {
		init = list[0]
		if lenList == 1 {
			return list[0]
		}
		if lenList >= 2 {
			list = list[1:]
		}
	}
	
	if lenList == 0 {
		return init
	}
	r := f(init, list[0])
	return ReduceEmployer(f, list[1:], r)
}

func ReduceEmployerPtr(f func(*employer.Employer, *employer.Employer) *employer.Employer, list []*employer.Employer, initializer ...employer.Employer) *employer.Employer {
	var initVal employer.Employer
	var init *employer.Employer = &initVal
	lenList := len(list)

	if initializer != nil {
		init = &initializer[0]
	} else if lenList > 0 {
		init = list[0]
		if lenList == 1 {
			return list[0]
		}
		if lenList >= 2 {
			list = list[1:]
		}
	}

	if lenList == 0 {
		return init
	}

	r := f(init, list[0])
	return ReduceEmployerPtr(f, list[1:], *r)
}

// ReduceEmployerPtrErr reduces a list to a single value by combining elements via a supplied function
//
// Takes three inputs
//	A. function - takes two arguments (*employer.Employer, *employer.Employer)
//	B. list of type []*employer.Employer
// 	C. initializer (optional of type employer.Employer)
//
// Returns:
//	single value, error: (*employer.Employer, error)
func ReduceEmployerPtrErr(f func(*employer.Employer, *employer.Employer) (*employer.Employer, error), list []*employer.Employer, initializer ...employer.Employer) (*employer.Employer, error) {
	var initVal employer.Employer
	var init *employer.Employer = &initVal
	lenList := len(list)

	if initializer != nil {
		init = &initializer[0]
	} else if lenList > 0 {
		init = list[0]
		if lenList == 1 {
			return list[0], nil
		}
		if lenList >= 2 {
			list = list[1:]
		}
	}

	if lenList == 0 {
		return init, nil
	}

	r, err := f(init, list[0])
	if err != nil {
		return nil, err
	}
	return ReduceEmployerPtrErr(f, list[1:], *r)
}

// ReduceEmployerErr reduces a list to a single value by combining elements via a supplied function
//
// Takes three inputs
//	A. function - takes two arguments (employer.Employer, employer.Employer)
//	B. list of type []employer.Employer
// 	C. initializer (optional of type employer.Employer)
//
// Returns:
//	single value, error: (employer.Employer, error)
func ReduceEmployerErr(f func(employer.Employer, employer.Employer) (employer.Employer, error), list []employer.Employer, initializer ...employer.Employer) (employer.Employer, error) {
	var initVal employer.Employer
	var init employer.Employer = initVal
	lenList := len(list)

	if initializer != nil {
		init = initializer[0]
	} else if lenList > 0 {
		init = list[0]
		if lenList == 1 {
			return list[0], nil
		}
		if lenList >= 2 {
			list = list[1:]
		}
	}

	if lenList == 0 {
		return init, nil
	}

	r, err := f(init, list[0])
	if err != nil {
		return r, err
	}
	return ReduceEmployerErr(f, list[1:], r)
}

// DropLastEmployer drops last item from the list and returns new list.
// Returns empty list if there is only one item in the list or list empty
func DropLastEmployer(list []employer.Employer) []employer.Employer {
	listLen := len(list)

	if list == nil || listLen == 0 || listLen == 1 {
		return []employer.Employer{}
	}

	newList := make([]employer.Employer, listLen-1)

	for i := 0; i < listLen-1; i++ {
		newList[i] = list[i]
	}
	return newList
}

// DropLastEmployerPtr drops last item from the list and returns new list.
// Returns empty list if there is only one item in the list or list empty
func DropLastEmployerPtr(list []*employer.Employer) []*employer.Employer {
	listLen := len(list)

	if list == nil || listLen == 0 || listLen == 1 {
		return []*employer.Employer{}
	}

	newList := make([]*employer.Employer, listLen-1)

	for i := 0; i < listLen-1; i++ {
		newList[i] = list[i]
	}
	return newList
}

// ReverseEmployers reverse the list
func ReverseEmployers(list []employer.Employer) []employer.Employer {
	newList := make([]employer.Employer, len(list))
	for i := 0; i < len(list); i++ {
		newList[i] = list[len(list)-(i+1)]
	}
	return newList
}

// ReverseEmployersPtr reverse the list
func ReverseEmployersPtr(list []*employer.Employer) []*employer.Employer {
	newList := make([]*employer.Employer, len(list))
	for i := 0; i < len(list); i++ {
		newList[i] = list[len(list)-(i+1)]
	}
	return newList
}

// TakeEmployer returns n items in the list
func TakeEmployer(n int, list []employer.Employer) []employer.Employer {
	if n < 0 {
		return []employer.Employer{}
	}

	newListLen := len(list)

	if n < newListLen {
		newListLen = n
	}
	newList := make([]employer.Employer, newListLen)
	for i := 0; i < newListLen; i++ {
		newList[i] = list[i]
	}
	return newList
}

// TakeEmployerPtr returns n items in the list
func TakeEmployerPtr(n int, list []*employer.Employer) []*employer.Employer {
	if n < 0 {
		return []*employer.Employer{}
	}

	newListLen := len(list)

	if n < newListLen {
		newListLen = n
	}
	newList := make([]*employer.Employer, newListLen)
	for i := 0; i < newListLen; i++ {
		newList[i] = list[i]
	}
	return newList
}

type employerSlice []employer.Employer
type employerFunctorForMap func(employer.Employer) employer.Employer
type employerFunctorForFilter func(employer.Employer) bool

type employerSlicePtr []*employer.Employer
type employerFunctorForMapPtr func(*employer.Employer) *employer.Employer
type employerFunctorForFilterPtr func(*employer.Employer) bool

// MakeEmployerSlice - creates slice for the functional method such as map, filter
func MakeEmployerSlice(values ...employer.Employer) employerSlice {
	newSlice := employerSlice(values)
	return newSlice
}

// Map - applies the function(1st argument) on each item of the list and returns new list
func (slice employerSlice) Map(functors ...employerFunctorForMap) employerSlice {

	tmpSlice := slice
	
	for _, f := range functors {
		if f == nil {
			continue
		}
		tmpSlice = MapEmployer(f, tmpSlice)
	}

	return tmpSlice
}

// MakeEmployerSlicePtr - creates slice for the functional method such as map, filter
func MakeEmployerSlicePtr(values ...*employer.Employer) employerSlicePtr {
	newSlice := employerSlicePtr(values)
	return newSlice
}

// MapPtr - applies the function(1st argument) on each item of the list and returns new list
func (slice employerSlicePtr) MapPtr(functors ...employerFunctorForMapPtr) employerSlicePtr {

	tmpSlice := slice
	
	for _, f := range functors {
		if f == nil {
			continue
		}
		tmpSlice = MapEmployerPtr(f, tmpSlice)
	}

	return tmpSlice
}

// Filter - 
func (slice employerSlice) Filter(functors ...employerFunctorForFilter) employerSlice {

	tmpSlice := slice
	
	for _, f := range functors {
		if f == nil {
			continue
		}
		tmpSlice = FilterEmployer(f, tmpSlice)
	}

	return tmpSlice
}

// FilterPtr - 
func (slice employerSlicePtr) FilterPtr(functors ...employerFunctorForFilterPtr) employerSlicePtr {

	tmpSlice := slice
	
	for _, f := range functors {
		if f == nil {
			continue
		}
		tmpSlice = FilterEmployerPtr(f, tmpSlice)
	}

	return tmpSlice
}

// DistinctEmployerP returns true if no two of the arguments are =
func DistinctEmployerP(list []employer.Employer) bool {
	if len(list) == 0 {
		return false
	}

	s := make(map[employer.Employer]bool)
	for _, v := range list {
		if _, ok := s[v]; ok {
			return false
		}
		s[v] = true
	}
	return true
}

// DistinctEmployerPPtr returns true if no two of the arguments are =
func DistinctEmployerPPtr(list []*employer.Employer) bool {
	if len(list) == 0 {
		return false
	}

	s := make(map[employer.Employer]bool)
	for _, v := range list {
		if _, ok := s[*v]; ok {
			return false
		}
		s[*v] = true
	}
	return true
}

// DistinctEmployer removes duplicates.
func DistinctEmployer(list []employer.Employer) []employer.Employer {
	var newList []employer.Employer
	s := make(map[employer.Employer]struct{}, len(list))
	for _, v := range list {
		if _, ok := s[v]; ok {
			continue
		}
		s[v] = struct{}{}
		newList = append(newList, v)
	}
	return newList
}

// DistinctEmployerPtr removes duplicates.
func DistinctEmployerPtr(list []*employer.Employer) []*employer.Employer {
	var newList []*employer.Employer
	s := make(map[employer.Employer]struct{}, len(list))
	for _, v := range list {
		if _, ok := s[*v]; ok {
			continue
		}
		s[*v] = struct{}{}
		newList = append(newList, v)
	}
	return newList
}

// UnionEmployer return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionEmployer(arrList ...[]employer.Employer) []employer.Employer {
	resultMap := make(map[employer.Employer]bool)
	for _, arr := range arrList {
		for _, v := range arr {
			resultMap[v] = true
		}
	}

	resultArr := make([]employer.Employer, len(resultMap))
	i := 0
	for k := range resultMap {
		resultArr[i] = k
		i++
	}
	return resultArr
}

// UnionEmployerPtr return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionEmployerPtr(arrList ...[]*employer.Employer) []*employer.Employer {
	resultMap := make(map[employer.Employer]bool)
	var resultArr []*employer.Employer
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[*v]
			if !ok {
				resultMap[*v] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// IntersectionEmployer return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionEmployer(arrList ...[]employer.Employer) []employer.Employer {
	if arrList == nil {
		return []employer.Employer{}
	}

	resultMap := make(map[employer.Employer]bool)
	if len(arrList) == 1 {
		var newList []employer.Employer
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i]]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i]] = true
			}
		}
		return newList
	}

	var newList []employer.Employer
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i] == v {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i]]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i]] = true
			}
		}
	}
	return newList
}

// IntersectionEmployerPtr return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionEmployerPtr(arrList ...[]*employer.Employer) []*employer.Employer {
	if arrList == nil {
		return []*employer.Employer{}
	}

	resultMap := make(map[employer.Employer]bool)
	if len(arrList) == 1 {
		var newList []*employer.Employer
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[*arrList[0][i]]
			if !ok {
				resultMap[*arrList[0][i]] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*employer.Employer
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if *arrList[0][i] == *v {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[*arrList[0][i]]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[*arrList[0][i]] = true
			}
		}
	}
	return newList
}

// DifferenceEmployer returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceEmployer(arrList ...[]employer.Employer) []employer.Employer {
	if arrList == nil {
		return []employer.Employer{}
	}

	resultMap := make(map[employer.Employer]bool)
	if len(arrList) == 1 {
		var newList []employer.Employer
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i]]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i]] = true
			}
		}
		return newList
	}

	var newList []employer.Employer
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i] == v {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i]]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i]] = true
			}
		}
	}
	return newList
}

// DifferenceEmployerPtr returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceEmployerPtr(arrList ...[]*employer.Employer) []*employer.Employer {
	if arrList == nil {
		return []*employer.Employer{}
	}

	resultMap := make(map[employer.Employer]bool)
	if len(arrList) == 1 {
		var newList []*employer.Employer
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[*arrList[0][i]]
			if !ok {
				resultMap[*arrList[0][i]] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*employer.Employer
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if *arrList[0][i] == *v {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[*arrList[0][i]]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[*arrList[0][i]] = true
			}
		}
	}
	return newList
}

// SubsetEmployer returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetEmployer(list1, list2 []employer.Employer) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[employer.Employer]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i]]
		if !ok {
			found := false
			resultMap[list1[i]] = true
			for j := 0; j < len(list2); j++ {
				if list1[i] == list2[j] {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SubsetEmployerPtr returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetEmployerPtr(list1, list2 []*employer.Employer) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[employer.Employer]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[*list1[i]]
		if !ok {
			found := false
			resultMap[*list1[i]] = true
			for j := 0; j < len(list2); j++ {
				if list1[i] == list2[j] {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetEmployer returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetEmployer(list1, list2 []employer.Employer) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[employer.Employer]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i]]
		if !ok {
			found := false
			resultMap[list2[i]] = true
			for j := 0; j < len(list1); j++ {
				if list2[i] == list1[j] {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetEmployerPtr returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetEmployerPtr(list1, list2 []*employer.Employer) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[employer.Employer]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[*list2[i]]
		if !ok {
			found := false
			resultMap[*list2[i]] = true
			for j := 0; j < len(list1); j++ {
				if list2[i] == list1[j] {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SetEmployer returns a set of the distinct elements of coll.
func SetEmployer(list []employer.Employer) []employer.Employer {
	if list == nil || len(list) == 0 {
		return []employer.Employer{}
	}

	resultMap := make(map[employer.Employer]bool)
	newList := []employer.Employer{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i]]
		if !ok {
			resultMap[list[i]] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}

// SetEmployerPtr returns a set of the distinct elements of coll.
func SetEmployerPtr(list []*employer.Employer) []*employer.Employer {
	if list == nil || len(list) == 0 {
		return []*employer.Employer{}
	}

	resultMap := make(map[employer.Employer]bool)
	newList := []*employer.Employer{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[*list[i]]
		if !ok {
			resultMap[*list[i]] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}

func MapEmployee(f func(employee.Employee) employee.Employee, list []employee.Employee) []employee.Employee {
	if f == nil {
		return []employee.Employee{}
	}
	newList := make([]employee.Employee, len(list))
	for i, v := range list {
		newList[i] = f(v)
	}
	return newList
}

func MapEmployeePtr(f func(*employee.Employee) *employee.Employee, list []*employee.Employee) []*employee.Employee {
	if f == nil {
		return []*employee.Employee{}
	}
	newList := make([]*employee.Employee, len(list))
	for i, v := range list {
		newList[i] = f(v)
	}
	return newList
}

// MapEmployeePtrErr takes 2 arguments:
//  1. A function input argument: *employee.Employee and return types (*employee.Employee, error)
//  2. A list of type []*employee.Employee
//
// Returns:
// 	([]*employee.Employee, error)
func MapEmployeePtrErr(f func(*employee.Employee) (*employee.Employee, error), list []*employee.Employee) ([]*employee.Employee, error) {
	if f == nil {
		return []*employee.Employee{}, nil
	}
	newList := make([]*employee.Employee, len(list))
	for i, v := range list {
		var err error
		newList[i], err = f(v)
		if err != nil {
			return nil, err
		}
	}
	return newList, nil
}

// MapEmployeeErr takes 2 arguments:
//  1. A function input argument: employee.Employee and return types (employee.Employee, error)
//  2. A list of type []employee.Employee
//
// Returns:
// 	([]employee.Employee, error)
func MapEmployeeErr(f func(employee.Employee) (employee.Employee, error), list []employee.Employee) ([]employee.Employee, error) {
	if f == nil {
		return []employee.Employee{}, nil
	}
	newList := make([]employee.Employee, len(list))
	for i, v := range list {
		var err error
		newList[i], err = f(v)
		if err != nil {
			return nil, err
		}
	}
	return newList, nil
}

func FilterEmployee(f func(employee.Employee) bool, list []employee.Employee) []employee.Employee {
	if f == nil {
		return []employee.Employee{}
	}
	var newList []employee.Employee
	for _, v := range list {
		if f(v) {
			newList = append(newList, v)
		}
	}
	return newList
}

func FilterEmployeePtr(f func(*employee.Employee) bool, list []*employee.Employee) []*employee.Employee {
	if f == nil {
		return []*employee.Employee{}
	}
	var newList []*employee.Employee
	for _, v := range list {
		if f(v) {
			newList = append(newList, v)
		}
	}
	return newList
}

// FilterEmployeePtrErr takes two arguments
//  1. Function: takes 1 argument of type employee.Employee and returns (bool, error)
//  2. slice of type []*employee.Employee
//
// Returns:
//  new filtered list and error
func FilterEmployeePtrErr(f func(*employee.Employee) (bool, error), list []*employee.Employee) ([]*employee.Employee, error) {
	if f == nil {
		return []*employee.Employee{}, nil
	}
	var newList []*employee.Employee
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if r {
			newList = append(newList, v)
		}
	}
	return newList, nil
}

// FilterEmployeeErr takes two arguments
//  1. Function: takes 1 argument of type employee.Employee and returns (bool, error)
//  2. slice of type []employee.Employee
//
// Returns:
//  new filtered list and error
func FilterEmployeeErr(f func(employee.Employee) (bool, error), list []employee.Employee) ([]employee.Employee, error) {
	if f == nil {
		return []employee.Employee{}, nil
	}
	var newList []employee.Employee
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if r {
			newList = append(newList, v)
		}
	}
	return newList, nil
}

func RemoveEmployee(f func(employee.Employee) bool, list []employee.Employee) []employee.Employee {
	if f == nil {
		return []employee.Employee{}
	}
	var newList []employee.Employee
	for _, v := range list {
		if !f(v) {
			newList = append(newList, v)
		}
	}
	return newList
}

func RemoveEmployeePtr(f func(*employee.Employee) bool, list []*employee.Employee) []*employee.Employee {
	if f == nil {
		return []*employee.Employee{}
	}
	var newList []*employee.Employee
	for _, v := range list {
		if !f(v) {
			newList = append(newList, v)
		}
	}
	return newList
}

// RemoveEmployeePtrErr removes the items from the given list based on supplied function and returns new list
//
// Takes 2 inputs:
//	1. Function: input type *employee.Employee and return types(bool, error)
//	2. List of type: []*employee.Employee
//
// Returns:
//	New list and error: ([]*employee.Employee, error)
//	Empty list if both of arguments are nil or either one is nil.
func RemoveEmployeePtrErr(f func(*employee.Employee) (bool, error), list []*employee.Employee) ([]*employee.Employee, error) {
	if f == nil {
		return []*employee.Employee{}, nil
	}
	var newList []*employee.Employee
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if !r {
			newList = append(newList, v)
		}
	}
	return newList, nil
}

// RemoveEmployeeErr removes the items from the given list based on supplied function and returns new list
//
// Takes 2 inputs:
//	1. Function: input type employee.Employee and return types(bool, error)
//	2. List of type: []employee.Employee
//
// Returns:
//	New list and error: ([]employee.Employee, error)
//	Empty list if both of arguments are nil or either one is nil.
func RemoveEmployeeErr(f func(employee.Employee) (bool, error), list []employee.Employee) ([]employee.Employee, error) {
	if f == nil {
		return []employee.Employee{}, nil
	}
	var newList []employee.Employee
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if !r {
			newList = append(newList, v)
		}
	}
	return newList, nil
}

func SomeEmployee(f func(employee.Employee) bool, list []employee.Employee) bool {
	if f == nil {
		return false
	}
	for _, v := range list {
		if f(v) {
			return true
		}
	}
	return false
}

func SomeEmployeePtr(f func(*employee.Employee) bool, list []*employee.Employee) bool {
	if f == nil {
		return false
	}
	for _, v := range list {
		if f(v) {
			return true
		}
	}
	return false
}

// SomeEmployeePtrErr finds item in the list based on supplied function.
//
// Takes 2 input:
//	1. Function
//	2. List
//
// Returns:
//	(bool,err).
//	True if condition satisfies, else false
func SomeEmployeePtrErr(f func(*employee.Employee) (bool, error), list []*employee.Employee) (bool, error) {
	if f == nil {
		return false, nil
	}
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return false, err
		}
		if r {
			return true, nil
		}
	}
	return false, nil
}

// SomeEmployeeErr finds item in the list based on supplied function.
//
// Takes 2 input:
//	1. Function
//	2. List
//
// Returns:
//	(bool,err).
//	True if condition satisfies, else false
func SomeEmployeeErr(f func(employee.Employee) (bool, error), list []employee.Employee) (bool, error) {
	if f == nil {
		return false, nil
	}
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return false, err
		}
		if r {
			return true, nil
		}
	}
	return false, nil
}

func EveryEmployee(f func(employee.Employee) bool, list []employee.Employee) bool {
	if f == nil || len(list) == 0 {
		return false
	}
	for _, v := range list {
		if !f(v) {
			return false
		}
	}
	return true
}

func EveryEmployeePtr(f func(*employee.Employee) bool, list []*employee.Employee) bool {
	if f == nil || len(list) == 0 {
		return false
	}
	for _, v := range list {
		if !f(v) {
			return false
		}
	}
	return true
}

// EveryEmployeePtrErr returns true if supplied function returns logical true for every item in the list
func EveryEmployeePtrErr(f func(*employee.Employee) (bool, error), list []*employee.Employee) (bool, error) {
	if f == nil || len(list) == 0 {
		return false, nil
	}
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return false, err
		}
		if !r {
			return false, nil
		}
	}
	return true, nil
}

// EveryEmployeeErr returns true if supplied function returns logical true for every item in the list
func EveryEmployeeErr(f func(employee.Employee) (bool, error), list []employee.Employee) (bool, error) {
	if f == nil || len(list) == 0 {
		return false, nil
	}
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return false, err
		}
		if !r {
			return false, nil
		}
	}
	return true, nil
}

func DropWhileEmployee(f func(employee.Employee) bool, list []employee.Employee) []employee.Employee {
	if f == nil {
		return []employee.Employee{}
	}
	var newList []employee.Employee
	for i, v := range list {
		if !f(v) {
			listLen := len(list)
			newList = make([]employee.Employee, listLen-i)
			j := 0
			for i < listLen {
				newList[j] = list[i]
				i++
				j++
			}
			return newList
		}
	}
	return newList
}

func DropWhileEmployeePtr(f func(*employee.Employee) bool, list []*employee.Employee) []*employee.Employee {
	if f == nil {
		return []*employee.Employee{}
	}
	var newList []*employee.Employee
	for i, v := range list {
		if !f(v) {
			listLen := len(list)
			newList = make([]*employee.Employee, listLen-i)
			j := 0
			for i < listLen {
				newList[j] = list[i]
				i++
				j++
			}
			return newList
		}
	}
	return newList
}

// DropWhileEmployeePtrErr drops the items from the list as long as condition satisfies.
//
// Takes two inputs
//	1. Function: takes one input and returns (boolean, error)
//	2. list
//
// Returns:
// 	New List, error
//  Empty list if either one of arguments or both of them are nil
func DropWhileEmployeePtrErr(f func(*employee.Employee) (bool, error), list []*employee.Employee) ([]*employee.Employee, error) {
	if f == nil {
		return []*employee.Employee{}, nil
	}
	var newList []*employee.Employee
	for i, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if !r {
			listLen := len(list)
			newList = make([]*employee.Employee, listLen-i)
			j := 0
			for i < listLen {
				newList[j] = list[i]
				i++
				j++
			}
			return newList, nil
		}
	}
	return newList, nil
}

// DropWhileEmployeeErr drops the items from the list as long as condition satisfies.
//
// Takes two inputs
//	1. Function: takes one input and returns (boolean, error)
//	2. list
//
// Returns:
// 	New List, error
//  Empty list if either one of arguments or both of them are nil
func DropWhileEmployeeErr(f func(employee.Employee) (bool, error), list []employee.Employee) ([]employee.Employee, error) {
	if f == nil {
		return []employee.Employee{}, nil
	}
	var newList []employee.Employee
	for i, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if !r {
			listLen := len(list)
			newList = make([]employee.Employee, listLen-i)
			j := 0
			for i < listLen {
				newList[j] = list[i]
				i++
				j++
			}
			return newList, nil
		}
	}
	return newList, nil
}

func TakeWhileEmployee(f func(employee.Employee) bool, list []employee.Employee) []employee.Employee {
	if f == nil {
		return []employee.Employee{}
	}
	var newList []employee.Employee
	for _, v := range list {
		if !f(v) {
			return newList
		}
		newList = append(newList, v)
	}
	return newList
}

func TakeWhileEmployeePtr(f func(*employee.Employee) bool, list []*employee.Employee) []*employee.Employee {
	if f == nil {
		return []*employee.Employee{}
	}
	var newList []*employee.Employee
	for _, v := range list {
		if !f(v) {
			return newList
		}
		newList = append(newList, v)
	}
	return newList
}

// TakeWhileEmployeePtrErr returns new list based on condition in the supplied function. It returns new list once condition fails.
//
// Takes 2 inputs:
//	1. Function - 1 input of type *employee.Employee and returns ([]*employee.Employee, error)
//	2. List
//
// Returns:
//	New List, error.
//	Empty list if all the parameters are nil or either of one parameter is nil
func TakeWhileEmployeePtrErr(f func(*employee.Employee) (bool, error), list []*employee.Employee) ([]*employee.Employee, error) {
	if f == nil {
		return []*employee.Employee{}, nil
	}
	var newList []*employee.Employee
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if !r {
			return newList, nil
		}
		newList = append(newList, v)
	}
	return newList, nil
}

// TakeWhileEmployeeErr returns new list based on condition in the supplied function. It returns new list once condition fails.
//
// Takes 2 inputs:
//	1. Function - 1 input of type employee.Employee and returns ([]employee.Employee, error)
//	2. List
//
// Returns:
//	New List, error.
//	Empty list if all the parameters are nil or either of one parameter is nil
func TakeWhileEmployeeErr(f func(employee.Employee) (bool, error), list []employee.Employee) ([]employee.Employee, error) {
	if f == nil {
		return []employee.Employee{}, nil
	}
	var newList []employee.Employee
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if !r {
			return newList, nil
		}
		newList = append(newList, v)
	}
	return newList, nil
}

// PMapEmployee applies the function(1st argument) on each item in the list and returns a new list.
//  Order of new list is guaranteed. This feature can be disabled by passing: Optional{RandomOrder: true} to gain performance
//  Run in parallel. no_of_goroutines = no_of_items_in_list or 3rd argument can be passed to fix the number of goroutines.
//
// Takes 3 inputs. 3rd argument is optional
//  1. Function - takes 1 input
//  2. List
//  3. optional argument - fp.Optional{FixedPool: <some_number>}
func PMapEmployee(f func(employee.Employee) employee.Employee, list []employee.Employee, optional ...fp.Optional) []employee.Employee {
	if f == nil {
		return []employee.Employee{}
	}

	var worker = len(list)
	if optional != nil && len(optional) > 0 {
		if optional[0].FixedPool > 0 && optional[0].FixedPool < worker {
			worker = optional[0].FixedPool
		}

		if optional[0].RandomOrder == true {
			return pMapEmployeeNoOrder(f, list, worker)
		}
	}

	return pMapEmployeePreserveOrder(f, list, worker)
}

func pMapEmployeePreserveOrder(f func(employee.Employee) employee.Employee, list []employee.Employee, worker int) []employee.Employee {
	chJobs := make(chan map[int]employee.Employee, len(list))
	go func() {
		for i, v := range list {
			chJobs <- map[int]employee.Employee{i: v}
		}
		close(chJobs)
	}()

	chResult := make(chan map[int]employee.Employee, worker/3)

	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan map[int]employee.Employee, chJobs chan map[int]employee.Employee) {
			defer wg.Done()

			for m := range chJobs {
				for k, v := range m {
					chResult <- map[int]employee.Employee{k: f(v)}
				}
			}
		}(chResult, chJobs)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newListMap := make(map[int]employee.Employee, len(list))
	newList := make([]employee.Employee, len(list))

	for m := range chResult {
		for k, v := range m {
			newListMap[k] = v
		}
	}

	for i := 0; i < len(list); i++ {
		newList[i] = newListMap[i]
	}

	return newList
}

func pMapEmployeeNoOrder(f func(employee.Employee) employee.Employee, list []employee.Employee, worker int) []employee.Employee {
	chJobs := make(chan employee.Employee, len(list))
	go func() {
		for _, v := range list {
			chJobs <- v
		}
		close(chJobs)
	}()

	chResult := make(chan employee.Employee, worker/3)

	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan employee.Employee, chJobs chan employee.Employee) {
			defer wg.Done()

			for v := range chJobs {
				chResult <- f(v)
			}
		}(chResult, chJobs)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newList := make([]employee.Employee, len(list))
	i := 0

	for v := range chResult {
		newList[i] = v
		i++
	}

	return newList
}

// PMapEmployeePtr applies the function(1st argument) on each item in the list and returns a new list.
//  Order of new list is guaranteed. This feature can be disabled by passing: Optional{RandomOrder: true} to gain performance
//  Run in parallel. no_of_goroutines = no_of_items_in_list or 3rd argument can be passed to fix the number of goroutines.
//
// Takes 3 inputs. 3rd argument is optional
//  1. Function - takes 1 input
//  2. List
//  3. optional argument - fp.Optional{FixedPool: <some_number>}
func PMapEmployeePtr(f func(*employee.Employee) *employee.Employee, list []*employee.Employee, optional ...fp.Optional) []*employee.Employee {
	if f == nil {
		return []*employee.Employee{}
	}

	var worker = len(list)
	if optional != nil && len(optional) > 0 {
		if optional[0].FixedPool > 0 && optional[0].FixedPool < worker {
			worker = optional[0].FixedPool
		}

		if optional[0].RandomOrder == true {
			return pMapEmployeePtrNoOrder(f, list, worker)
		}
	}

	return pMapEmployeePtrPreserveOrder(f, list, worker)
}

func pMapEmployeePtrPreserveOrder(f func(*employee.Employee) *employee.Employee, list []*employee.Employee, worker int) []*employee.Employee {
	chJobs := make(chan map[int]*employee.Employee, len(list))
	go func() {
		for i, v := range list {
			chJobs <- map[int]*employee.Employee{i: v}
		}
		close(chJobs)
	}()

	chResult := make(chan map[int]*employee.Employee, worker/3)

	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan map[int]*employee.Employee, chJobs chan map[int]*employee.Employee) {
			defer wg.Done()

			for m := range chJobs {
				for k, v := range m {
					chResult <- map[int]*employee.Employee{k: f(v)}
				}
			}
		}(chResult, chJobs)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newListMap := make(map[int]*employee.Employee, len(list))
	newList := make([]*employee.Employee, len(list))

	for m := range chResult {
		for k, v := range m {
			newListMap[k] = v
		}
	}

	for i := 0; i < len(list); i++ {
		newList[i] = newListMap[i]
	}

	return newList
}

func pMapEmployeePtrNoOrder(f func(*employee.Employee) *employee.Employee, list []*employee.Employee, worker int) []*employee.Employee {
	chJobs := make(chan *employee.Employee, len(list))
	go func() {
		for _, v := range list {
			chJobs <- v
		}
		close(chJobs)
	}()

	chResult := make(chan *employee.Employee, worker/3)

	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan *employee.Employee, chJobs chan *employee.Employee) {
			defer wg.Done()

			for v := range chJobs {
				chResult <- f(v)
			}
		}(chResult, chJobs)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newList := make([]*employee.Employee, len(list))
	i := 0

	for v := range chResult {
		newList[i] = v
		i++
	}

	return newList
}

// PMapEmployeePtrErr applies the function(1st argument) on each item in the list and returns a new list and error.
//  Order of new list is guaranteed. This feature can be disabled by passing: Optional{RandomOrder: true} to gain performance
//  Run in parallel. no_of_goroutines = no_of_items_in_list or 3rd argument can be passed to fix the number of goroutines.
//
// Takes 3 inputs. 3rd argument is optional
//  1. Function - takes 1 input
//  2. List
//  3. optional argument - fp.Optional{FixedPool: <some_number>}
func PMapEmployeePtrErr(f func(*employee.Employee) (*employee.Employee, error), list []*employee.Employee, optional ...fp.Optional) ([]*employee.Employee, error) {
	if f == nil {
		return []*employee.Employee{}, nil
	}

	var worker = len(list)
	if optional != nil && len(optional) > 0 {
		if optional[0].FixedPool > 0 && optional[0].FixedPool < worker {
			worker = optional[0].FixedPool
		}

		if optional[0].RandomOrder == true {
			return pMapEmployeePtrErrNoOrder(f, list, worker)
		}
	}

	return pMapEmployeePtrErrPreserveOrder(f, list, worker)
}

func pMapEmployeePtrErrPreserveOrder(f func(*employee.Employee) (*employee.Employee, error), list []*employee.Employee, worker int) ([]*employee.Employee, error) {
	chJobs := make(chan map[int]*employee.Employee, len(list))
	go func() {
		for i, v := range list {
			chJobs <- map[int]*employee.Employee{i: v}
		}
		close(chJobs)
	}()

	chResult := make(chan map[int]*employee.Employee, worker/3)

	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan map[int]*employee.Employee, chJobs chan map[int]*employee.Employee, errCh chan error) {
			defer wg.Done()
			if len(errCh) > 0 {
				return
			}
			for m := range chJobs {
				for k, v := range m {
					r, err := f(v)
					if err != nil {
						errCh <- err
						return
					}
					chResult <- map[int]*employee.Employee{k: r}
				}
			}
		}(chResult, chJobs, errCh)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newListMap := make(map[int]*employee.Employee, len(list))
	newList := make([]*employee.Employee, len(list))

	for m := range chResult {
		select {
		case err := <-errCh:
			return []*employee.Employee{}, err
		default:
		}
		for k, v := range m {
			newListMap[k] = v
		}
	}

	if len(errCh) > 0 {
		return []*employee.Employee{}, <-errCh
	}

	for i := 0; i < len(list); i++ {
		newList[i] = newListMap[i]
	}

	return newList, nil
}

func pMapEmployeePtrErrNoOrder(f func(*employee.Employee) (*employee.Employee, error), list []*employee.Employee, worker int) ([]*employee.Employee, error) {
	chJobs := make(chan *employee.Employee, len(list))
	go func() {
		for _, v := range list {
			chJobs <- v
		}
		close(chJobs)
	}()

	chResult := make(chan *employee.Employee, worker/3)

	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan *employee.Employee, chJobs chan *employee.Employee, errCh chan error) {
			defer wg.Done()
			if len(errCh) > 0 {
				return
			}
			for v := range chJobs {
				r, err := f(v)
				if err != nil {
					errCh <- err
					return
				}
				chResult <- r
			}
		}(chResult, chJobs, errCh)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newList := make([]*employee.Employee, len(list))
	i := 0

	for v := range chResult {
		select {
		case err := <-errCh:
			return []*employee.Employee{}, err
		default:
		}
		newList[i] = v
		i++
	}

	if len(errCh) > 0 {
		return []*employee.Employee{}, <-errCh
	}

	return newList, nil
}

// PMapEmployeeErr applies the function(1st argument) on each item in the list and returns a new list and error.
//  Order of new list is guaranteed. This feature can be disabled by passing: Optional{RandomOrder: true} to gain performance
//  Run in parallel. no_of_goroutines = no_of_items_in_list or 3rd argument can be passed to fix the number of goroutines.
//
// Takes 3 inputs. 3rd argument is optional
//  1. Function - takes 1 input
//  2. List
//  3. optional argument - fp.Optional{FixedPool: <some_number>}
func PMapEmployeeErr(f func(employee.Employee) (employee.Employee, error), list []employee.Employee, optional ...fp.Optional) ([]employee.Employee, error) {
	if f == nil {
		return []employee.Employee{}, nil
	}

	var worker = len(list)
	if optional != nil && len(optional) > 0 {
		if optional[0].FixedPool > 0 && optional[0].FixedPool < worker {
			worker = optional[0].FixedPool
		}

		if optional[0].RandomOrder == true {
			return pMapEmployeeErrNoOrder(f, list, worker)
		}
	}

	return pMapEmployeeErrPreserveOrder(f, list, worker)
}

func pMapEmployeeErrPreserveOrder(f func(employee.Employee) (employee.Employee, error), list []employee.Employee, worker int) ([]employee.Employee, error) {
	chJobs := make(chan map[int]employee.Employee, len(list))
	go func() {
		for i, v := range list {
			chJobs <- map[int]employee.Employee{i: v}
		}
		close(chJobs)
	}()

	chResult := make(chan map[int]employee.Employee, worker/3)

	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan map[int]employee.Employee, chJobs chan map[int]employee.Employee, errCh chan error) {
			defer wg.Done()
			if len(errCh) > 0 {
				return
			}
			for m := range chJobs {
				for k, v := range m {
					r, err := f(v)
					if err != nil {
						errCh <- err
						return
					}
					chResult <- map[int]employee.Employee{k: r}
				}
			}
		}(chResult, chJobs, errCh)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newListMap := make(map[int]employee.Employee, len(list))
	newList := make([]employee.Employee, len(list))

	for m := range chResult {
		select {
		case err := <-errCh:
			return []employee.Employee{}, err
		default:
		}
		for k, v := range m {
			newListMap[k] = v
		}
	}

	if len(errCh) > 0 {
		return []employee.Employee{}, <-errCh
	}

	for i := 0; i < len(list); i++ {
		newList[i] = newListMap[i]
	}

	return newList, nil
}

func pMapEmployeeErrNoOrder(f func(employee.Employee) (employee.Employee, error), list []employee.Employee, worker int) ([]employee.Employee, error) {
	chJobs := make(chan employee.Employee, len(list))
	go func() {
		for _, v := range list {
			chJobs <- v
		}
		close(chJobs)
	}()

	chResult := make(chan employee.Employee, worker/3)

	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan employee.Employee, chJobs chan employee.Employee, errCh chan error) {
			defer wg.Done()
			if len(errCh) > 0 {
				return
			}
			for v := range chJobs {
				r, err := f(v)
				if err != nil {
					errCh <- err
					return
				}
				chResult <- r
			}
		}(chResult, chJobs, errCh)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newList := make([]employee.Employee, len(list))
	i := 0

	for v := range chResult {
		select {
		case err := <-errCh:
			return []employee.Employee{}, err
		default:
		}
		newList[i] = v
		i++
	}

	if len(errCh) > 0 {
		return []employee.Employee{}, <-errCh
	}

	return newList, nil
}

func FilterMapEmployee(fFilter func(employee.Employee) bool, fMap func(employee.Employee) employee.Employee, list []employee.Employee) []employee.Employee {
	if fFilter == nil || fMap == nil {
		return []employee.Employee{}
	}
	var newList []employee.Employee
	for _, v := range list {
		if fFilter(v) {
			newList = append(newList, fMap(v))
		}
	}
	return newList
}

func FilterMapEmployeePtr(fFilter func(*employee.Employee) bool, fMap func(*employee.Employee) *employee.Employee, list []*employee.Employee) []*employee.Employee {
	if fFilter == nil || fMap == nil {
		return []*employee.Employee{}
	}
	var newList []*employee.Employee
	for _, v := range list {
		if fFilter(v) {
			newList = append(newList, fMap(v))
		}
	}
	return newList
}

// FilterMapEmployeePtrErr filters given list, then apply function(2nd argument) on each item in the list and returns a new list
// Takes 3 inputs
//	1. Function: takes one input(*employee.Employee) and returns (bool, error).
//	2. Function: takes *employee.Employee as argument and returns (*employee.Employee, error)
// 	3. Slice of type []*employee.Employee
//
// Returns:
//	New List ([]*employee.Employee, error).
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapEmployeePtrErr(fFilter func(*employee.Employee) (bool, error), fMap func(*employee.Employee) (*employee.Employee, error), list []*employee.Employee) ([]*employee.Employee, error) {
	if fFilter == nil || fMap == nil {
		return []*employee.Employee{}, nil
	}
	var newList []*employee.Employee
	for _, v := range list {
		r, err := fFilter(v)
		if err != nil {
			return nil, err
		}
		if r {
			r, err := fMap(v)
			if err != nil {
				return nil, err
			}
			newList = append(newList, r)
		}
	}
	return newList, nil
}

// FilterMapEmployeeErr filters given list, then apply function(2nd argument) on each item in the list and returns a new list
// Takes 3 inputs
//	1. Function: takes one input(employee.Employee) and returns (bool, error).
//	2. Function: takes employee.Employee as argument and returns (employee.Employee, error)
// 	3. Slice of type []employee.Employee
//
// Returns:
//	New List ([]employee.Employee, error).
//  Empty list if all there parameters are nil or either of parameter is nil
//
func FilterMapEmployeeErr(fFilter func(employee.Employee) (bool, error), fMap func(employee.Employee) (employee.Employee, error), list []employee.Employee) ([]employee.Employee, error) {
	if fFilter == nil || fMap == nil {
		return []employee.Employee{}, nil
	}
	var newList []employee.Employee
	for _, v := range list {
		r, err := fFilter(v)
		if err != nil {
			return nil, err
		}
		if r {
			r, err := fMap(v)
			if err != nil {
				return nil, err
			}
			newList = append(newList, r)
		}
	}
	return newList, nil
}

func RestEmployee(l []employee.Employee) []employee.Employee {
	if l == nil {
		return []employee.Employee{}
	}

	len := len(l)
	if len == 0 || len == 1 {
		return []employee.Employee{}
	}

	newList := make([]employee.Employee, len-1)

	for i, v := range l[1:] {
		newList[i] = v
	}

	return newList
}


// RestEmployee removes 1st item of the list and return new list having rest of the items
func RestEmployeePtr(l []*employee.Employee) []*employee.Employee {
	if l == nil {
		return []*employee.Employee{}
	}

	len := len(l)
	if len == 0 || len == 1 {
		return []*employee.Employee{}
	}

	newList := make([]*employee.Employee, len-1)

	for i, v := range l[1:] {
		newList[i] = v
	}

	return newList
}

func ReduceEmployee(f func(employee.Employee, employee.Employee) employee.Employee, list []employee.Employee, initializer ...employee.Employee) employee.Employee {
	var init employee.Employee 
	lenList := len(list)

	if initializer != nil {
		init = initializer[0]
	} else if lenList > 0 {
		init = list[0]
		if lenList == 1 {
			return list[0]
		}
		if lenList >= 2 {
			list = list[1:]
		}
	}
	
	if lenList == 0 {
		return init
	}
	r := f(init, list[0])
	return ReduceEmployee(f, list[1:], r)
}

func ReduceEmployeePtr(f func(*employee.Employee, *employee.Employee) *employee.Employee, list []*employee.Employee, initializer ...employee.Employee) *employee.Employee {
	var initVal employee.Employee
	var init *employee.Employee = &initVal
	lenList := len(list)

	if initializer != nil {
		init = &initializer[0]
	} else if lenList > 0 {
		init = list[0]
		if lenList == 1 {
			return list[0]
		}
		if lenList >= 2 {
			list = list[1:]
		}
	}

	if lenList == 0 {
		return init
	}

	r := f(init, list[0])
	return ReduceEmployeePtr(f, list[1:], *r)
}

// ReduceEmployeePtrErr reduces a list to a single value by combining elements via a supplied function
//
// Takes three inputs
//	A. function - takes two arguments (*employee.Employee, *employee.Employee)
//	B. list of type []*employee.Employee
// 	C. initializer (optional of type employee.Employee)
//
// Returns:
//	single value, error: (*employee.Employee, error)
func ReduceEmployeePtrErr(f func(*employee.Employee, *employee.Employee) (*employee.Employee, error), list []*employee.Employee, initializer ...employee.Employee) (*employee.Employee, error) {
	var initVal employee.Employee
	var init *employee.Employee = &initVal
	lenList := len(list)

	if initializer != nil {
		init = &initializer[0]
	} else if lenList > 0 {
		init = list[0]
		if lenList == 1 {
			return list[0], nil
		}
		if lenList >= 2 {
			list = list[1:]
		}
	}

	if lenList == 0 {
		return init, nil
	}

	r, err := f(init, list[0])
	if err != nil {
		return nil, err
	}
	return ReduceEmployeePtrErr(f, list[1:], *r)
}

// ReduceEmployeeErr reduces a list to a single value by combining elements via a supplied function
//
// Takes three inputs
//	A. function - takes two arguments (employee.Employee, employee.Employee)
//	B. list of type []employee.Employee
// 	C. initializer (optional of type employee.Employee)
//
// Returns:
//	single value, error: (employee.Employee, error)
func ReduceEmployeeErr(f func(employee.Employee, employee.Employee) (employee.Employee, error), list []employee.Employee, initializer ...employee.Employee) (employee.Employee, error) {
	var initVal employee.Employee
	var init employee.Employee = initVal
	lenList := len(list)

	if initializer != nil {
		init = initializer[0]
	} else if lenList > 0 {
		init = list[0]
		if lenList == 1 {
			return list[0], nil
		}
		if lenList >= 2 {
			list = list[1:]
		}
	}

	if lenList == 0 {
		return init, nil
	}

	r, err := f(init, list[0])
	if err != nil {
		return r, err
	}
	return ReduceEmployeeErr(f, list[1:], r)
}

// DropLastEmployee drops last item from the list and returns new list.
// Returns empty list if there is only one item in the list or list empty
func DropLastEmployee(list []employee.Employee) []employee.Employee {
	listLen := len(list)

	if list == nil || listLen == 0 || listLen == 1 {
		return []employee.Employee{}
	}

	newList := make([]employee.Employee, listLen-1)

	for i := 0; i < listLen-1; i++ {
		newList[i] = list[i]
	}
	return newList
}

// DropLastEmployeePtr drops last item from the list and returns new list.
// Returns empty list if there is only one item in the list or list empty
func DropLastEmployeePtr(list []*employee.Employee) []*employee.Employee {
	listLen := len(list)

	if list == nil || listLen == 0 || listLen == 1 {
		return []*employee.Employee{}
	}

	newList := make([]*employee.Employee, listLen-1)

	for i := 0; i < listLen-1; i++ {
		newList[i] = list[i]
	}
	return newList
}

// ReverseEmployees reverse the list
func ReverseEmployees(list []employee.Employee) []employee.Employee {
	newList := make([]employee.Employee, len(list))
	for i := 0; i < len(list); i++ {
		newList[i] = list[len(list)-(i+1)]
	}
	return newList
}

// ReverseEmployeesPtr reverse the list
func ReverseEmployeesPtr(list []*employee.Employee) []*employee.Employee {
	newList := make([]*employee.Employee, len(list))
	for i := 0; i < len(list); i++ {
		newList[i] = list[len(list)-(i+1)]
	}
	return newList
}

// TakeEmployee returns n items in the list
func TakeEmployee(n int, list []employee.Employee) []employee.Employee {
	if n < 0 {
		return []employee.Employee{}
	}

	newListLen := len(list)

	if n < newListLen {
		newListLen = n
	}
	newList := make([]employee.Employee, newListLen)
	for i := 0; i < newListLen; i++ {
		newList[i] = list[i]
	}
	return newList
}

// TakeEmployeePtr returns n items in the list
func TakeEmployeePtr(n int, list []*employee.Employee) []*employee.Employee {
	if n < 0 {
		return []*employee.Employee{}
	}

	newListLen := len(list)

	if n < newListLen {
		newListLen = n
	}
	newList := make([]*employee.Employee, newListLen)
	for i := 0; i < newListLen; i++ {
		newList[i] = list[i]
	}
	return newList
}

type employeeSlice []employee.Employee
type employeeFunctorForMap func(employee.Employee) employee.Employee
type employeeFunctorForFilter func(employee.Employee) bool

type employeeSlicePtr []*employee.Employee
type employeeFunctorForMapPtr func(*employee.Employee) *employee.Employee
type employeeFunctorForFilterPtr func(*employee.Employee) bool

// MakeEmployeeSlice - creates slice for the functional method such as map, filter
func MakeEmployeeSlice(values ...employee.Employee) employeeSlice {
	newSlice := employeeSlice(values)
	return newSlice
}

// Map - applies the function(1st argument) on each item of the list and returns new list
func (slice employeeSlice) Map(functors ...employeeFunctorForMap) employeeSlice {

	tmpSlice := slice
	
	for _, f := range functors {
		if f == nil {
			continue
		}
		tmpSlice = MapEmployee(f, tmpSlice)
	}

	return tmpSlice
}

// MakeEmployeeSlicePtr - creates slice for the functional method such as map, filter
func MakeEmployeeSlicePtr(values ...*employee.Employee) employeeSlicePtr {
	newSlice := employeeSlicePtr(values)
	return newSlice
}

// MapPtr - applies the function(1st argument) on each item of the list and returns new list
func (slice employeeSlicePtr) MapPtr(functors ...employeeFunctorForMapPtr) employeeSlicePtr {

	tmpSlice := slice
	
	for _, f := range functors {
		if f == nil {
			continue
		}
		tmpSlice = MapEmployeePtr(f, tmpSlice)
	}

	return tmpSlice
}

// Filter - 
func (slice employeeSlice) Filter(functors ...employeeFunctorForFilter) employeeSlice {

	tmpSlice := slice
	
	for _, f := range functors {
		if f == nil {
			continue
		}
		tmpSlice = FilterEmployee(f, tmpSlice)
	}

	return tmpSlice
}

// FilterPtr - 
func (slice employeeSlicePtr) FilterPtr(functors ...employeeFunctorForFilterPtr) employeeSlicePtr {

	tmpSlice := slice
	
	for _, f := range functors {
		if f == nil {
			continue
		}
		tmpSlice = FilterEmployeePtr(f, tmpSlice)
	}

	return tmpSlice
}

// DistinctEmployeeP returns true if no two of the arguments are =
func DistinctEmployeeP(list []employee.Employee) bool {
	if len(list) == 0 {
		return false
	}

	s := make(map[employee.Employee]bool)
	for _, v := range list {
		if _, ok := s[v]; ok {
			return false
		}
		s[v] = true
	}
	return true
}

// DistinctEmployeePPtr returns true if no two of the arguments are =
func DistinctEmployeePPtr(list []*employee.Employee) bool {
	if len(list) == 0 {
		return false
	}

	s := make(map[employee.Employee]bool)
	for _, v := range list {
		if _, ok := s[*v]; ok {
			return false
		}
		s[*v] = true
	}
	return true
}

// DistinctEmployee removes duplicates.
func DistinctEmployee(list []employee.Employee) []employee.Employee {
	var newList []employee.Employee
	s := make(map[employee.Employee]struct{}, len(list))
	for _, v := range list {
		if _, ok := s[v]; ok {
			continue
		}
		s[v] = struct{}{}
		newList = append(newList, v)
	}
	return newList
}

// DistinctEmployeePtr removes duplicates.
func DistinctEmployeePtr(list []*employee.Employee) []*employee.Employee {
	var newList []*employee.Employee
	s := make(map[employee.Employee]struct{}, len(list))
	for _, v := range list {
		if _, ok := s[*v]; ok {
			continue
		}
		s[*v] = struct{}{}
		newList = append(newList, v)
	}
	return newList
}

// UnionEmployee return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionEmployee(arrList ...[]employee.Employee) []employee.Employee {
	resultMap := make(map[employee.Employee]bool)
	for _, arr := range arrList {
		for _, v := range arr {
			resultMap[v] = true
		}
	}

	resultArr := make([]employee.Employee, len(resultMap))
	i := 0
	for k := range resultMap {
		resultArr[i] = k
		i++
	}
	return resultArr
}

// UnionEmployeePtr return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionEmployeePtr(arrList ...[]*employee.Employee) []*employee.Employee {
	resultMap := make(map[employee.Employee]bool)
	var resultArr []*employee.Employee
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[*v]
			if !ok {
				resultMap[*v] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// IntersectionEmployee return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionEmployee(arrList ...[]employee.Employee) []employee.Employee {
	if arrList == nil {
		return []employee.Employee{}
	}

	resultMap := make(map[employee.Employee]bool)
	if len(arrList) == 1 {
		var newList []employee.Employee
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i]]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i]] = true
			}
		}
		return newList
	}

	var newList []employee.Employee
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i] == v {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i]]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i]] = true
			}
		}
	}
	return newList
}

// IntersectionEmployeePtr return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionEmployeePtr(arrList ...[]*employee.Employee) []*employee.Employee {
	if arrList == nil {
		return []*employee.Employee{}
	}

	resultMap := make(map[employee.Employee]bool)
	if len(arrList) == 1 {
		var newList []*employee.Employee
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[*arrList[0][i]]
			if !ok {
				resultMap[*arrList[0][i]] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*employee.Employee
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if *arrList[0][i] == *v {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[*arrList[0][i]]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[*arrList[0][i]] = true
			}
		}
	}
	return newList
}

// DifferenceEmployee returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceEmployee(arrList ...[]employee.Employee) []employee.Employee {
	if arrList == nil {
		return []employee.Employee{}
	}

	resultMap := make(map[employee.Employee]bool)
	if len(arrList) == 1 {
		var newList []employee.Employee
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i]]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i]] = true
			}
		}
		return newList
	}

	var newList []employee.Employee
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i] == v {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i]]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i]] = true
			}
		}
	}
	return newList
}

// DifferenceEmployeePtr returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceEmployeePtr(arrList ...[]*employee.Employee) []*employee.Employee {
	if arrList == nil {
		return []*employee.Employee{}
	}

	resultMap := make(map[employee.Employee]bool)
	if len(arrList) == 1 {
		var newList []*employee.Employee
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[*arrList[0][i]]
			if !ok {
				resultMap[*arrList[0][i]] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*employee.Employee
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if *arrList[0][i] == *v {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[*arrList[0][i]]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[*arrList[0][i]] = true
			}
		}
	}
	return newList
}

// SubsetEmployee returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetEmployee(list1, list2 []employee.Employee) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[employee.Employee]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i]]
		if !ok {
			found := false
			resultMap[list1[i]] = true
			for j := 0; j < len(list2); j++ {
				if list1[i] == list2[j] {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SubsetEmployeePtr returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetEmployeePtr(list1, list2 []*employee.Employee) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[employee.Employee]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[*list1[i]]
		if !ok {
			found := false
			resultMap[*list1[i]] = true
			for j := 0; j < len(list2); j++ {
				if list1[i] == list2[j] {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetEmployee returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetEmployee(list1, list2 []employee.Employee) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[employee.Employee]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i]]
		if !ok {
			found := false
			resultMap[list2[i]] = true
			for j := 0; j < len(list1); j++ {
				if list2[i] == list1[j] {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetEmployeePtr returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetEmployeePtr(list1, list2 []*employee.Employee) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[employee.Employee]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[*list2[i]]
		if !ok {
			found := false
			resultMap[*list2[i]] = true
			for j := 0; j < len(list1); j++ {
				if list2[i] == list1[j] {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SetEmployee returns a set of the distinct elements of coll.
func SetEmployee(list []employee.Employee) []employee.Employee {
	if list == nil || len(list) == 0 {
		return []employee.Employee{}
	}

	resultMap := make(map[employee.Employee]bool)
	newList := []employee.Employee{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i]]
		if !ok {
			resultMap[list[i]] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}

// SetEmployeePtr returns a set of the distinct elements of coll.
func SetEmployeePtr(list []*employee.Employee) []*employee.Employee {
	if list == nil || len(list) == 0 {
		return []*employee.Employee{}
	}

	resultMap := make(map[employee.Employee]bool)
	newList := []*employee.Employee{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[*list[i]]
		if !ok {
			resultMap[*list[i]] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}


// MapEmployerEmployee takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list
func MapEmployerEmployee(f func(employer.Employer) employee.Employee, list []employer.Employer) []employee.Employee {
	if f == nil {
		return []employee.Employee{}
	}
	newList := make([]employee.Employee, len(list))
	for i, v := range list {
		newList[i] = f(v)
	}
	return newList
}

// MapEmployerEmployeeErr takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list and error
func MapEmployerEmployeeErr(f func(employer.Employer) (employee.Employee, error), list []employer.Employer) ([]employee.Employee, error) {
	if f == nil {
		return []employee.Employee{}, nil
	}
	newList := make([]employee.Employee, len(list))
	for i, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		newList[i] = r
	}
	return newList, nil
}

// MapEmployerEmployeePtr takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list
func MapEmployerEmployeePtr(f func(*employer.Employer) *employee.Employee, list []*employer.Employer) []*employee.Employee {
	if f == nil {
		return []*employee.Employee{}
	}
	newList := make([]*employee.Employee, len(list))
	for i, v := range list {
		newList[i] = f(v)
	}
	return newList
}

// MapEmployerEmployeePtrErr takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list, error
func MapEmployerEmployeePtrErr(f func(*employer.Employer) (*employee.Employee, error), list []*employer.Employer) ([]*employee.Employee, error) {
	if f == nil {
		return []*employee.Employee{}, nil
	}
	newList := make([]*employee.Employee, len(list))
	for i, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		newList[i] = r
	}
	return newList, nil
}

// PMapEmployerEmployee applies the function(1st argument) on each item in the list and returns a new list.
//  Order of new list is guaranteed. This feature can be disabled by passing: Optional{RandomOrder: true} to gain performance
//  Run in parallel. no_of_goroutines = no_of_items_in_list or 3rd argument can be passed to fix the number of goroutines.
//
// Takes 3 inputs. 3rd argument is optional
//  1. Function - takes 1 input
//  2. List
//  3. optional argument - fp.Optional{FixedPool: <some_number>}
func PMapEmployerEmployee(f func(employer.Employer) employee.Employee, list []employer.Employer, optional ...fp.Optional) []employee.Employee {
	if f == nil {
		return []employee.Employee{}
	}

	var worker = len(list)
	if optional != nil && len(optional) > 0 {
		if optional[0].FixedPool > 0 && optional[0].FixedPool < worker {
			worker = optional[0].FixedPool
		}

		if optional[0].RandomOrder == true {
			return pMapEmployerEmployeeNoOrder(f, list, worker)
		}
	}

	return pMapEmployerEmployeePreserveOrder(f, list, worker)
}

func pMapEmployerEmployeePreserveOrder(f func(employer.Employer) employee.Employee, list []employer.Employer, worker int) []employee.Employee {
	chJobs := make(chan map[int]employer.Employer, len(list))
	go func() {
		for i, v := range list {
			chJobs <- map[int]employer.Employer{i: v}
		}
		close(chJobs)
	}()

	chResult := make(chan map[int]employee.Employee, worker/3)

	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan map[int]employee.Employee, chJobs chan map[int]employer.Employer) {
			defer wg.Done()

			for m := range chJobs {
				for k, v := range m {
					chResult <- map[int]employee.Employee{k: f(v)}
				}
			}
		}(chResult, chJobs)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newListMap := make(map[int]employee.Employee, len(list))
	newList := make([]employee.Employee, len(list))

	for m := range chResult {
		for k, v := range m {
			newListMap[k] = v
		}
	}

	for i := 0; i < len(list); i++ {
		newList[i] = newListMap[i]
	}

	return newList
}

func pMapEmployerEmployeeNoOrder(f func(employer.Employer) employee.Employee, list []employer.Employer, worker int) []employee.Employee {
	chJobs := make(chan employer.Employer, len(list))
	go func() {
		for _, v := range list {
			chJobs <- v
		}
		close(chJobs)
	}()

	chResult := make(chan employee.Employee, worker/3)

	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan employee.Employee, chJobs chan employer.Employer) {
			defer wg.Done()

			for v := range chJobs {
				chResult <- f(v)
			}
		}(chResult, chJobs)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newList := make([]employee.Employee, len(list))
	i := 0

	for v := range chResult {
		newList[i] = v
		i++
	}

	return newList
}

// PMapEmployerEmployeeErr applies the function(1st argument) on each item in the list and returns a new list and error.
//  Order of new list is guaranteed. This feature can be disabled by passing: Optional{RandomOrder: true} to gain performance
//  Run in parallel. no_of_goroutines = no_of_items_in_list or 3rd argument can be passed to fix the number of goroutines.
//
// Takes 3 inputs. 3rd argument is optional
//  1. Function - takes 1 input
//  2. List
//  3. optional argument - fp.Optional{FixedPool: <some_number>}
func PMapEmployerEmployeeErr(f func(employer.Employer) (employee.Employee, error), list []employer.Employer, optional ...fp.Optional) ([]employee.Employee, error) {
	if f == nil {
		return []employee.Employee{}, nil
	}

	var worker = len(list)
	if optional != nil && len(optional) > 0 {
		if optional[0].FixedPool > 0 && optional[0].FixedPool < worker {
			worker = optional[0].FixedPool
		}

		if optional[0].RandomOrder == true {
			return pMapEmployerEmployeeErrNoOrder(f, list, worker)
		}
	}

	return pMapEmployerEmployeeErrPreserveOrder(f, list, worker)
}

func pMapEmployerEmployeeErrPreserveOrder(f func(employer.Employer) (employee.Employee, error), list []employer.Employer, worker int) ([]employee.Employee, error) {
	chJobs := make(chan map[int]employer.Employer, len(list))
	go func() {
		for i, v := range list {
			chJobs <- map[int]employer.Employer{i: v}
		}
		close(chJobs)
	}()

	chResult := make(chan map[int]employee.Employee, worker/3)

	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan map[int]employee.Employee, chJobs chan map[int]employer.Employer, errCh chan error) {
			defer wg.Done()
			if len(errCh) > 0 {
				return
			}
			for m := range chJobs {
				for k, v := range m {
					r, err := f(v)
					if err != nil {
						errCh <- err
						return
					}
					chResult <- map[int]employee.Employee{k: r}
				}
			}
		}(chResult, chJobs, errCh)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newListMap := make(map[int]employee.Employee, len(list))
	newList := make([]employee.Employee, len(list))

	for m := range chResult {
		select {
		case err := <-errCh:
			return []employee.Employee{}, err
		default:
		}
		for k, v := range m {
			newListMap[k] = v
		}
	}

	if len(errCh) > 0 {
		return []employee.Employee{}, <-errCh
	}

	for i := 0; i < len(list); i++ {
		newList[i] = newListMap[i]
	}

	return newList, nil
}

func pMapEmployerEmployeeErrNoOrder(f func(employer.Employer) (employee.Employee, error), list []employer.Employer, worker int) ([]employee.Employee, error) {
	chJobs := make(chan employer.Employer, len(list))
	go func() {
		for _, v := range list {
			chJobs <- v
		}
		close(chJobs)
	}()

	chResult := make(chan employee.Employee, worker/3)

	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan employee.Employee, chJobs chan employer.Employer, errCh chan error) {
			defer wg.Done()
			if len(errCh) > 0 {
				return
			}
			for v := range chJobs {
				r, err := f(v)
				if err != nil {
					errCh <- err
					return
				}
				chResult <- r
			}
		}(chResult, chJobs, errCh)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newList := make([]employee.Employee, len(list))
	i := 0

	for v := range chResult {
		select {
		case err := <-errCh:
			return []employee.Employee{}, err
		default:
		}
		newList[i] = v
		i++
	}

	if len(errCh) > 0 {
		return []employee.Employee{}, <-errCh
	}

	return newList, nil
}

// PMapEmployerEmployeePtr applies the function(1st argument) on each item in the list and returns a new list.
//  Order of new list is guaranteed. This feature can be disabled by passing: Optional{RandomOrder: true} to gain performance
//  Run in parallel. no_of_goroutines = no_of_items_in_list or 3rd argument can be passed to fix the number of goroutines.
//
// Takes 3 inputs. 3rd argument is optional
//  1. Function - takes 1 input
//  2. List
//  3. optional argument - fp.Optional{FixedPool: <some_number>}
func PMapEmployerEmployeePtr(f func(*employer.Employer) *employee.Employee, list []*employer.Employer, optional ...fp.Optional) []*employee.Employee {
	if f == nil {
		return []*employee.Employee{}
	}

	var worker = len(list)
	if optional != nil && len(optional) > 0 {
		if optional[0].FixedPool > 0 && optional[0].FixedPool < worker {
			worker = optional[0].FixedPool
		}

		if optional[0].RandomOrder == true {
			return pMapEmployerEmployeePtrNoOrder(f, list, worker)
		}
	}

	return pMapEmployerEmployeePtrPreserveOrder(f, list, worker)
}

func pMapEmployerEmployeePtrPreserveOrder(f func(*employer.Employer) *employee.Employee, list []*employer.Employer, worker int) []*employee.Employee {
	chJobs := make(chan map[int]*employer.Employer, len(list))
	go func() {
		for i, v := range list {
			chJobs <- map[int]*employer.Employer{i: v}
		}
		close(chJobs)
	}()

	chResult := make(chan map[int]*employee.Employee, worker/3)

	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan map[int]*employee.Employee, chJobs chan map[int]*employer.Employer) {
			defer wg.Done()

			for m := range chJobs {
				for k, v := range m {
					chResult <- map[int]*employee.Employee{k: f(v)}
				}
			}
		}(chResult, chJobs)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newListMap := make(map[int]*employee.Employee, len(list))
	newList := make([]*employee.Employee, len(list))

	for m := range chResult {
		for k, v := range m {
			newListMap[k] = v
		}
	}

	for i := 0; i < len(list); i++ {
		newList[i] = newListMap[i]
	}

	return newList
}

func pMapEmployerEmployeePtrNoOrder(f func(*employer.Employer) *employee.Employee, list []*employer.Employer, worker int) []*employee.Employee {
	chJobs := make(chan *employer.Employer, len(list))
	go func() {
		for _, v := range list {
			chJobs <- v
		}
		close(chJobs)
	}()

	chResult := make(chan *employee.Employee, worker/3)

	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan *employee.Employee, chJobs chan *employer.Employer) {
			defer wg.Done()

			for v := range chJobs {
				chResult <- f(v)
			}
		}(chResult, chJobs)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newList := make([]*employee.Employee, len(list))
	i := 0

	for v := range chResult {
		newList[i] = v
		i++
	}

	return newList
}

// PMapEmployerEmployeePtrErr applies the function(1st argument) on each item in the list and returns a new list and error.
//  Order of new list is guaranteed. This feature can be disabled by passing: Optional{RandomOrder: true} to gain performance
//  Run in parallel. no_of_goroutines = no_of_items_in_list or 3rd argument can be passed to fix the number of goroutines.
//
// Takes 3 inputs. 3rd argument is optional
//  1. Function - takes 1 input
//  2. List
//  3. optional argument - fp.Optional{FixedPool: <some_number>}
func PMapEmployerEmployeePtrErr(f func(*employer.Employer) (*employee.Employee, error), list []*employer.Employer, optional ...fp.Optional) ([]*employee.Employee, error) {
	if f == nil {
		return []*employee.Employee{}, nil
	}

	var worker = len(list)
	if optional != nil && len(optional) > 0 {
		if optional[0].FixedPool > 0 && optional[0].FixedPool < worker {
			worker = optional[0].FixedPool
		}

		if optional[0].RandomOrder == true {
			return pMapEmployerEmployeePtrErrNoOrder(f, list, worker)
		}
	}

	return pMapEmployerEmployeePtrErrPreserveOrder(f, list, worker)
}

func pMapEmployerEmployeePtrErrPreserveOrder(f func(*employer.Employer) (*employee.Employee, error), list []*employer.Employer, worker int) ([]*employee.Employee, error) {
	chJobs := make(chan map[int]*employer.Employer, len(list))
	go func() {
		for i, v := range list {
			chJobs <- map[int]*employer.Employer{i: v}
		}
		close(chJobs)
	}()

	chResult := make(chan map[int]*employee.Employee, worker/3)

	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan map[int]*employee.Employee, chJobs chan map[int]*employer.Employer, errCh chan error) {
			defer wg.Done()
			if len(errCh) > 0 {
				return
			}
			for m := range chJobs {
				for k, v := range m {
					r, err := f(v)
					if err != nil {
						errCh <- err
						return
					}
					chResult <- map[int]*employee.Employee{k: r}
				}
			}
		}(chResult, chJobs, errCh)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newListMap := make(map[int]*employee.Employee, len(list))
	newList := make([]*employee.Employee, len(list))

	for m := range chResult {
		select {
		case err := <-errCh:
			return []*employee.Employee{}, err
		default:
		}
		for k, v := range m {
			newListMap[k] = v
		}
	}

	if len(errCh) > 0 {
		return []*employee.Employee{}, <-errCh
	}

	for i := 0; i < len(list); i++ {
		newList[i] = newListMap[i]
	}

	return newList, nil
}

func pMapEmployerEmployeePtrErrNoOrder(f func(*employer.Employer) (*employee.Employee, error), list []*employer.Employer, worker int) ([]*employee.Employee, error) {
	chJobs := make(chan *employer.Employer, len(list))
	go func() {
		for _, v := range list {
			chJobs <- v
		}
		close(chJobs)
	}()

	chResult := make(chan *employee.Employee, worker/3)

	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan *employee.Employee, chJobs chan *employer.Employer, errCh chan error) {
			defer wg.Done()
			if len(errCh) > 0 {
				return
			}
			for v := range chJobs {
				r, err := f(v)
				if err != nil {
					errCh <- err
					return
				}
				chResult <- r
			}
		}(chResult, chJobs, errCh)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newList := make([]*employee.Employee, len(list))
	i := 0

	for v := range chResult {
		select {
		case err := <-errCh:
			return []*employee.Employee{}, err
		default:
		}
		newList[i] = v
		i++
	}

	if len(errCh) > 0 {
		return []*employee.Employee{}, <-errCh
	}

	return newList, nil
}

// FilterMapEmployerEmployee filters given list, then apply function(2nd argument) on each item in the list and returns a new list
// Takes 3 inputs
//	1. Function: takes one input type - employer.Employer and returns true/false.
//	2. Function: takes employer.Employer as argument and returns employee.Employee
// 	3. List of type employer.Employer
//
// Returns:
//	New List of type employee.Employee
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapEmployerEmployee(fFilter func(employer.Employer) bool, fMap func(employer.Employer) employee.Employee, list []employer.Employer) []employee.Employee {
	if fFilter == nil || fMap == nil {
		return []employee.Employee{}
	}
	var newList []employee.Employee
	for _, v := range list {
		if fFilter(v) {
			newList = append(newList, fMap(v))
		}
	}
	return newList
}

// FilterMapEmployerEmployeePtrErr filters given list, then apply function(2nd argument) on each item in the list and returns a new list, error
// Takes 3 inputs
//	1. Function: takes one input type - *employer.Employer and returns (bool, error).
//	2. Function: takes *employer.Employer as argument and returns (*employee.Employee, error)
// 	3. List of type *employer.Employer
//
// Returns:
//	New List of type *employee.Employee, error
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapEmployerEmployeePtrErr(fFilter func(*employer.Employer) (bool, error), fMap func(*employer.Employer) (*employee.Employee, error), list []*employer.Employer) ([]*employee.Employee, error) {
	if fFilter == nil || fMap == nil {
		return []*employee.Employee{}, nil
	}
	var newList []*employee.Employee
	for _, v := range list {
		r, err := fFilter(v)
		if err != nil {
			return nil, err
		}
		if r {
			r, err := fMap(v)
			if err != nil {
				return nil, err
			}
			newList = append(newList, r)
		}
	}
	return newList, nil
}

// FilterMapEmployerEmployeeErr filters given list, then apply function(2nd argument) on each item in the list and returns a new list, error
// Takes 3 inputs
//	1. Function: takes one input type - employer.Employer and returns (bool, error).
//	2. Function: takes employer.Employer as argument and returns (employee.Employee, error)
// 	3. List of type employer.Employer
//
// Returns:
//	New List of type employee.Employee, error
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapEmployerEmployeeErr(fFilter func(employer.Employer) (bool, error), fMap func(employer.Employer) (employee.Employee, error), list []employer.Employer) ([]employee.Employee, error) {
	if fFilter == nil || fMap == nil {
		return []employee.Employee{}, nil
	}
	var newList []employee.Employee
	for _, v := range list {
		r, err := fFilter(v)
		if err != nil {
			return nil, err
		}
		if r {
			r, err := fMap(v)
			if err != nil {
				return nil, err
			}
			newList = append(newList, r)
		}
	}
	return newList, nil
}

// MapEmployerInt takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list
func MapEmployerInt(f func(employer.Employer) int, list []employer.Employer) []int {
	if f == nil {
		return []int{}
	}
	newList := make([]int, len(list))
	for i, v := range list {
		newList[i] = f(v)
	}
	return newList
}

// MapEmployerIntErr takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list and error
func MapEmployerIntErr(f func(employer.Employer) (int, error), list []employer.Employer) ([]int, error) {
	if f == nil {
		return []int{}, nil
	}
	newList := make([]int, len(list))
	for i, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		newList[i] = r
	}
	return newList, nil
}

// MapEmployerIntPtr takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list
func MapEmployerIntPtr(f func(*employer.Employer) *int, list []*employer.Employer) []*int {
	if f == nil {
		return []*int{}
	}
	newList := make([]*int, len(list))
	for i, v := range list {
		newList[i] = f(v)
	}
	return newList
}

// MapEmployerIntPtrErr takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list, error
func MapEmployerIntPtrErr(f func(*employer.Employer) (*int, error), list []*employer.Employer) ([]*int, error) {
	if f == nil {
		return []*int{}, nil
	}
	newList := make([]*int, len(list))
	for i, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		newList[i] = r
	}
	return newList, nil
}

// PMapEmployerInt applies the function(1st argument) on each item in the list and returns a new list.
//  Order of new list is guaranteed. This feature can be disabled by passing: Optional{RandomOrder: true} to gain performance
//  Run in parallel. no_of_goroutines = no_of_items_in_list or 3rd argument can be passed to fix the number of goroutines.
//
// Takes 3 inputs. 3rd argument is optional
//  1. Function - takes 1 input
//  2. List
//  3. optional argument - fp.Optional{FixedPool: <some_number>}
func PMapEmployerInt(f func(employer.Employer) int, list []employer.Employer, optional ...fp.Optional) []int {
	if f == nil {
		return []int{}
	}

	var worker = len(list)
	if optional != nil && len(optional) > 0 {
		if optional[0].FixedPool > 0 && optional[0].FixedPool < worker {
			worker = optional[0].FixedPool
		}

		if optional[0].RandomOrder == true {
			return pMapEmployerIntNoOrder(f, list, worker)
		}
	}

	return pMapEmployerIntPreserveOrder(f, list, worker)
}

func pMapEmployerIntPreserveOrder(f func(employer.Employer) int, list []employer.Employer, worker int) []int {
	chJobs := make(chan map[int]employer.Employer, len(list))
	go func() {
		for i, v := range list {
			chJobs <- map[int]employer.Employer{i: v}
		}
		close(chJobs)
	}()

	chResult := make(chan map[int]int, worker/3)

	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan map[int]int, chJobs chan map[int]employer.Employer) {
			defer wg.Done()

			for m := range chJobs {
				for k, v := range m {
					chResult <- map[int]int{k: f(v)}
				}
			}
		}(chResult, chJobs)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newListMap := make(map[int]int, len(list))
	newList := make([]int, len(list))

	for m := range chResult {
		for k, v := range m {
			newListMap[k] = v
		}
	}

	for i := 0; i < len(list); i++ {
		newList[i] = newListMap[i]
	}

	return newList
}

func pMapEmployerIntNoOrder(f func(employer.Employer) int, list []employer.Employer, worker int) []int {
	chJobs := make(chan employer.Employer, len(list))
	go func() {
		for _, v := range list {
			chJobs <- v
		}
		close(chJobs)
	}()

	chResult := make(chan int, worker/3)

	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan int, chJobs chan employer.Employer) {
			defer wg.Done()

			for v := range chJobs {
				chResult <- f(v)
			}
		}(chResult, chJobs)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newList := make([]int, len(list))
	i := 0

	for v := range chResult {
		newList[i] = v
		i++
	}

	return newList
}

// PMapEmployerIntErr applies the function(1st argument) on each item in the list and returns a new list and error.
//  Order of new list is guaranteed. This feature can be disabled by passing: Optional{RandomOrder: true} to gain performance
//  Run in parallel. no_of_goroutines = no_of_items_in_list or 3rd argument can be passed to fix the number of goroutines.
//
// Takes 3 inputs. 3rd argument is optional
//  1. Function - takes 1 input
//  2. List
//  3. optional argument - fp.Optional{FixedPool: <some_number>}
func PMapEmployerIntErr(f func(employer.Employer) (int, error), list []employer.Employer, optional ...fp.Optional) ([]int, error) {
	if f == nil {
		return []int{}, nil
	}

	var worker = len(list)
	if optional != nil && len(optional) > 0 {
		if optional[0].FixedPool > 0 && optional[0].FixedPool < worker {
			worker = optional[0].FixedPool
		}

		if optional[0].RandomOrder == true {
			return pMapEmployerIntErrNoOrder(f, list, worker)
		}
	}

	return pMapEmployerIntErrPreserveOrder(f, list, worker)
}

func pMapEmployerIntErrPreserveOrder(f func(employer.Employer) (int, error), list []employer.Employer, worker int) ([]int, error) {
	chJobs := make(chan map[int]employer.Employer, len(list))
	go func() {
		for i, v := range list {
			chJobs <- map[int]employer.Employer{i: v}
		}
		close(chJobs)
	}()

	chResult := make(chan map[int]int, worker/3)

	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan map[int]int, chJobs chan map[int]employer.Employer, errCh chan error) {
			defer wg.Done()
			if len(errCh) > 0 {
				return
			}
			for m := range chJobs {
				for k, v := range m {
					r, err := f(v)
					if err != nil {
						errCh <- err
						return
					}
					chResult <- map[int]int{k: r}
				}
			}
		}(chResult, chJobs, errCh)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newListMap := make(map[int]int, len(list))
	newList := make([]int, len(list))

	for m := range chResult {
		select {
		case err := <-errCh:
			return []int{}, err
		default:
		}
		for k, v := range m {
			newListMap[k] = v
		}
	}

	if len(errCh) > 0 {
		return []int{}, <-errCh
	}

	for i := 0; i < len(list); i++ {
		newList[i] = newListMap[i]
	}

	return newList, nil
}

func pMapEmployerIntErrNoOrder(f func(employer.Employer) (int, error), list []employer.Employer, worker int) ([]int, error) {
	chJobs := make(chan employer.Employer, len(list))
	go func() {
		for _, v := range list {
			chJobs <- v
		}
		close(chJobs)
	}()

	chResult := make(chan int, worker/3)

	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan int, chJobs chan employer.Employer, errCh chan error) {
			defer wg.Done()
			if len(errCh) > 0 {
				return
			}
			for v := range chJobs {
				r, err := f(v)
				if err != nil {
					errCh <- err
					return
				}
				chResult <- r
			}
		}(chResult, chJobs, errCh)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newList := make([]int, len(list))
	i := 0

	for v := range chResult {
		select {
		case err := <-errCh:
			return []int{}, err
		default:
		}
		newList[i] = v
		i++
	}

	if len(errCh) > 0 {
		return []int{}, <-errCh
	}

	return newList, nil
}

// PMapEmployerIntPtr applies the function(1st argument) on each item in the list and returns a new list.
//  Order of new list is guaranteed. This feature can be disabled by passing: Optional{RandomOrder: true} to gain performance
//  Run in parallel. no_of_goroutines = no_of_items_in_list or 3rd argument can be passed to fix the number of goroutines.
//
// Takes 3 inputs. 3rd argument is optional
//  1. Function - takes 1 input
//  2. List
//  3. optional argument - fp.Optional{FixedPool: <some_number>}
func PMapEmployerIntPtr(f func(*employer.Employer) *int, list []*employer.Employer, optional ...fp.Optional) []*int {
	if f == nil {
		return []*int{}
	}

	var worker = len(list)
	if optional != nil && len(optional) > 0 {
		if optional[0].FixedPool > 0 && optional[0].FixedPool < worker {
			worker = optional[0].FixedPool
		}

		if optional[0].RandomOrder == true {
			return pMapEmployerIntPtrNoOrder(f, list, worker)
		}
	}

	return pMapEmployerIntPtrPreserveOrder(f, list, worker)
}

func pMapEmployerIntPtrPreserveOrder(f func(*employer.Employer) *int, list []*employer.Employer, worker int) []*int {
	chJobs := make(chan map[int]*employer.Employer, len(list))
	go func() {
		for i, v := range list {
			chJobs <- map[int]*employer.Employer{i: v}
		}
		close(chJobs)
	}()

	chResult := make(chan map[int]*int, worker/3)

	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan map[int]*int, chJobs chan map[int]*employer.Employer) {
			defer wg.Done()

			for m := range chJobs {
				for k, v := range m {
					chResult <- map[int]*int{k: f(v)}
				}
			}
		}(chResult, chJobs)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newListMap := make(map[int]*int, len(list))
	newList := make([]*int, len(list))

	for m := range chResult {
		for k, v := range m {
			newListMap[k] = v
		}
	}

	for i := 0; i < len(list); i++ {
		newList[i] = newListMap[i]
	}

	return newList
}

func pMapEmployerIntPtrNoOrder(f func(*employer.Employer) *int, list []*employer.Employer, worker int) []*int {
	chJobs := make(chan *employer.Employer, len(list))
	go func() {
		for _, v := range list {
			chJobs <- v
		}
		close(chJobs)
	}()

	chResult := make(chan *int, worker/3)

	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan *int, chJobs chan *employer.Employer) {
			defer wg.Done()

			for v := range chJobs {
				chResult <- f(v)
			}
		}(chResult, chJobs)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newList := make([]*int, len(list))
	i := 0

	for v := range chResult {
		newList[i] = v
		i++
	}

	return newList
}

// PMapEmployerIntPtrErr applies the function(1st argument) on each item in the list and returns a new list and error.
//  Order of new list is guaranteed. This feature can be disabled by passing: Optional{RandomOrder: true} to gain performance
//  Run in parallel. no_of_goroutines = no_of_items_in_list or 3rd argument can be passed to fix the number of goroutines.
//
// Takes 3 inputs. 3rd argument is optional
//  1. Function - takes 1 input
//  2. List
//  3. optional argument - fp.Optional{FixedPool: <some_number>}
func PMapEmployerIntPtrErr(f func(*employer.Employer) (*int, error), list []*employer.Employer, optional ...fp.Optional) ([]*int, error) {
	if f == nil {
		return []*int{}, nil
	}

	var worker = len(list)
	if optional != nil && len(optional) > 0 {
		if optional[0].FixedPool > 0 && optional[0].FixedPool < worker {
			worker = optional[0].FixedPool
		}

		if optional[0].RandomOrder == true {
			return pMapEmployerIntPtrErrNoOrder(f, list, worker)
		}
	}

	return pMapEmployerIntPtrErrPreserveOrder(f, list, worker)
}

func pMapEmployerIntPtrErrPreserveOrder(f func(*employer.Employer) (*int, error), list []*employer.Employer, worker int) ([]*int, error) {
	chJobs := make(chan map[int]*employer.Employer, len(list))
	go func() {
		for i, v := range list {
			chJobs <- map[int]*employer.Employer{i: v}
		}
		close(chJobs)
	}()

	chResult := make(chan map[int]*int, worker/3)

	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan map[int]*int, chJobs chan map[int]*employer.Employer, errCh chan error) {
			defer wg.Done()
			if len(errCh) > 0 {
				return
			}
			for m := range chJobs {
				for k, v := range m {
					r, err := f(v)
					if err != nil {
						errCh <- err
						return
					}
					chResult <- map[int]*int{k: r}
				}
			}
		}(chResult, chJobs, errCh)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newListMap := make(map[int]*int, len(list))
	newList := make([]*int, len(list))

	for m := range chResult {
		select {
		case err := <-errCh:
			return []*int{}, err
		default:
		}
		for k, v := range m {
			newListMap[k] = v
		}
	}

	if len(errCh) > 0 {
		return []*int{}, <-errCh
	}

	for i := 0; i < len(list); i++ {
		newList[i] = newListMap[i]
	}

	return newList, nil
}

func pMapEmployerIntPtrErrNoOrder(f func(*employer.Employer) (*int, error), list []*employer.Employer, worker int) ([]*int, error) {
	chJobs := make(chan *employer.Employer, len(list))
	go func() {
		for _, v := range list {
			chJobs <- v
		}
		close(chJobs)
	}()

	chResult := make(chan *int, worker/3)

	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan *int, chJobs chan *employer.Employer, errCh chan error) {
			defer wg.Done()
			if len(errCh) > 0 {
				return
			}
			for v := range chJobs {
				r, err := f(v)
				if err != nil {
					errCh <- err
					return
				}
				chResult <- r
			}
		}(chResult, chJobs, errCh)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newList := make([]*int, len(list))
	i := 0

	for v := range chResult {
		select {
		case err := <-errCh:
			return []*int{}, err
		default:
		}
		newList[i] = v
		i++
	}

	if len(errCh) > 0 {
		return []*int{}, <-errCh
	}

	return newList, nil
}

// FilterMapEmployerInt filters given list, then apply function(2nd argument) on each item in the list and returns a new list
// Takes 3 inputs
//	1. Function: takes one input type - employer.Employer and returns true/false.
//	2. Function: takes employer.Employer as argument and returns int
// 	3. List of type employer.Employer
//
// Returns:
//	New List of type int
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapEmployerInt(fFilter func(employer.Employer) bool, fMap func(employer.Employer) int, list []employer.Employer) []int {
	if fFilter == nil || fMap == nil {
		return []int{}
	}
	var newList []int
	for _, v := range list {
		if fFilter(v) {
			newList = append(newList, fMap(v))
		}
	}
	return newList
}

// FilterMapEmployerIntPtrErr filters given list, then apply function(2nd argument) on each item in the list and returns a new list, error
// Takes 3 inputs
//	1. Function: takes one input type - *employer.Employer and returns (bool, error).
//	2. Function: takes *employer.Employer as argument and returns (*int, error)
// 	3. List of type *employer.Employer
//
// Returns:
//	New List of type *int, error
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapEmployerIntPtrErr(fFilter func(*employer.Employer) (bool, error), fMap func(*employer.Employer) (*int, error), list []*employer.Employer) ([]*int, error) {
	if fFilter == nil || fMap == nil {
		return []*int{}, nil
	}
	var newList []*int
	for _, v := range list {
		r, err := fFilter(v)
		if err != nil {
			return nil, err
		}
		if r {
			r, err := fMap(v)
			if err != nil {
				return nil, err
			}
			newList = append(newList, r)
		}
	}
	return newList, nil
}

// FilterMapEmployerIntErr filters given list, then apply function(2nd argument) on each item in the list and returns a new list, error
// Takes 3 inputs
//	1. Function: takes one input type - employer.Employer and returns (bool, error).
//	2. Function: takes employer.Employer as argument and returns (int, error)
// 	3. List of type employer.Employer
//
// Returns:
//	New List of type int, error
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapEmployerIntErr(fFilter func(employer.Employer) (bool, error), fMap func(employer.Employer) (int, error), list []employer.Employer) ([]int, error) {
	if fFilter == nil || fMap == nil {
		return []int{}, nil
	}
	var newList []int
	for _, v := range list {
		r, err := fFilter(v)
		if err != nil {
			return nil, err
		}
		if r {
			r, err := fMap(v)
			if err != nil {
				return nil, err
			}
			newList = append(newList, r)
		}
	}
	return newList, nil
}

// MapEmployeeEmployer takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list
func MapEmployeeEmployer(f func(employee.Employee) employer.Employer, list []employee.Employee) []employer.Employer {
	if f == nil {
		return []employer.Employer{}
	}
	newList := make([]employer.Employer, len(list))
	for i, v := range list {
		newList[i] = f(v)
	}
	return newList
}

// MapEmployeeEmployerErr takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list and error
func MapEmployeeEmployerErr(f func(employee.Employee) (employer.Employer, error), list []employee.Employee) ([]employer.Employer, error) {
	if f == nil {
		return []employer.Employer{}, nil
	}
	newList := make([]employer.Employer, len(list))
	for i, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		newList[i] = r
	}
	return newList, nil
}

// MapEmployeeEmployerPtr takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list
func MapEmployeeEmployerPtr(f func(*employee.Employee) *employer.Employer, list []*employee.Employee) []*employer.Employer {
	if f == nil {
		return []*employer.Employer{}
	}
	newList := make([]*employer.Employer, len(list))
	for i, v := range list {
		newList[i] = f(v)
	}
	return newList
}

// MapEmployeeEmployerPtrErr takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list, error
func MapEmployeeEmployerPtrErr(f func(*employee.Employee) (*employer.Employer, error), list []*employee.Employee) ([]*employer.Employer, error) {
	if f == nil {
		return []*employer.Employer{}, nil
	}
	newList := make([]*employer.Employer, len(list))
	for i, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		newList[i] = r
	}
	return newList, nil
}

// PMapEmployeeEmployer applies the function(1st argument) on each item in the list and returns a new list.
//  Order of new list is guaranteed. This feature can be disabled by passing: Optional{RandomOrder: true} to gain performance
//  Run in parallel. no_of_goroutines = no_of_items_in_list or 3rd argument can be passed to fix the number of goroutines.
//
// Takes 3 inputs. 3rd argument is optional
//  1. Function - takes 1 input
//  2. List
//  3. optional argument - fp.Optional{FixedPool: <some_number>}
func PMapEmployeeEmployer(f func(employee.Employee) employer.Employer, list []employee.Employee, optional ...fp.Optional) []employer.Employer {
	if f == nil {
		return []employer.Employer{}
	}

	var worker = len(list)
	if optional != nil && len(optional) > 0 {
		if optional[0].FixedPool > 0 && optional[0].FixedPool < worker {
			worker = optional[0].FixedPool
		}

		if optional[0].RandomOrder == true {
			return pMapEmployeeEmployerNoOrder(f, list, worker)
		}
	}

	return pMapEmployeeEmployerPreserveOrder(f, list, worker)
}

func pMapEmployeeEmployerPreserveOrder(f func(employee.Employee) employer.Employer, list []employee.Employee, worker int) []employer.Employer {
	chJobs := make(chan map[int]employee.Employee, len(list))
	go func() {
		for i, v := range list {
			chJobs <- map[int]employee.Employee{i: v}
		}
		close(chJobs)
	}()

	chResult := make(chan map[int]employer.Employer, worker/3)

	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan map[int]employer.Employer, chJobs chan map[int]employee.Employee) {
			defer wg.Done()

			for m := range chJobs {
				for k, v := range m {
					chResult <- map[int]employer.Employer{k: f(v)}
				}
			}
		}(chResult, chJobs)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newListMap := make(map[int]employer.Employer, len(list))
	newList := make([]employer.Employer, len(list))

	for m := range chResult {
		for k, v := range m {
			newListMap[k] = v
		}
	}

	for i := 0; i < len(list); i++ {
		newList[i] = newListMap[i]
	}

	return newList
}

func pMapEmployeeEmployerNoOrder(f func(employee.Employee) employer.Employer, list []employee.Employee, worker int) []employer.Employer {
	chJobs := make(chan employee.Employee, len(list))
	go func() {
		for _, v := range list {
			chJobs <- v
		}
		close(chJobs)
	}()

	chResult := make(chan employer.Employer, worker/3)

	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan employer.Employer, chJobs chan employee.Employee) {
			defer wg.Done()

			for v := range chJobs {
				chResult <- f(v)
			}
		}(chResult, chJobs)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newList := make([]employer.Employer, len(list))
	i := 0

	for v := range chResult {
		newList[i] = v
		i++
	}

	return newList
}

// PMapEmployeeEmployerErr applies the function(1st argument) on each item in the list and returns a new list and error.
//  Order of new list is guaranteed. This feature can be disabled by passing: Optional{RandomOrder: true} to gain performance
//  Run in parallel. no_of_goroutines = no_of_items_in_list or 3rd argument can be passed to fix the number of goroutines.
//
// Takes 3 inputs. 3rd argument is optional
//  1. Function - takes 1 input
//  2. List
//  3. optional argument - fp.Optional{FixedPool: <some_number>}
func PMapEmployeeEmployerErr(f func(employee.Employee) (employer.Employer, error), list []employee.Employee, optional ...fp.Optional) ([]employer.Employer, error) {
	if f == nil {
		return []employer.Employer{}, nil
	}

	var worker = len(list)
	if optional != nil && len(optional) > 0 {
		if optional[0].FixedPool > 0 && optional[0].FixedPool < worker {
			worker = optional[0].FixedPool
		}

		if optional[0].RandomOrder == true {
			return pMapEmployeeEmployerErrNoOrder(f, list, worker)
		}
	}

	return pMapEmployeeEmployerErrPreserveOrder(f, list, worker)
}

func pMapEmployeeEmployerErrPreserveOrder(f func(employee.Employee) (employer.Employer, error), list []employee.Employee, worker int) ([]employer.Employer, error) {
	chJobs := make(chan map[int]employee.Employee, len(list))
	go func() {
		for i, v := range list {
			chJobs <- map[int]employee.Employee{i: v}
		}
		close(chJobs)
	}()

	chResult := make(chan map[int]employer.Employer, worker/3)

	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan map[int]employer.Employer, chJobs chan map[int]employee.Employee, errCh chan error) {
			defer wg.Done()
			if len(errCh) > 0 {
				return
			}
			for m := range chJobs {
				for k, v := range m {
					r, err := f(v)
					if err != nil {
						errCh <- err
						return
					}
					chResult <- map[int]employer.Employer{k: r}
				}
			}
		}(chResult, chJobs, errCh)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newListMap := make(map[int]employer.Employer, len(list))
	newList := make([]employer.Employer, len(list))

	for m := range chResult {
		select {
		case err := <-errCh:
			return []employer.Employer{}, err
		default:
		}
		for k, v := range m {
			newListMap[k] = v
		}
	}

	if len(errCh) > 0 {
		return []employer.Employer{}, <-errCh
	}

	for i := 0; i < len(list); i++ {
		newList[i] = newListMap[i]
	}

	return newList, nil
}

func pMapEmployeeEmployerErrNoOrder(f func(employee.Employee) (employer.Employer, error), list []employee.Employee, worker int) ([]employer.Employer, error) {
	chJobs := make(chan employee.Employee, len(list))
	go func() {
		for _, v := range list {
			chJobs <- v
		}
		close(chJobs)
	}()

	chResult := make(chan employer.Employer, worker/3)

	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan employer.Employer, chJobs chan employee.Employee, errCh chan error) {
			defer wg.Done()
			if len(errCh) > 0 {
				return
			}
			for v := range chJobs {
				r, err := f(v)
				if err != nil {
					errCh <- err
					return
				}
				chResult <- r
			}
		}(chResult, chJobs, errCh)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newList := make([]employer.Employer, len(list))
	i := 0

	for v := range chResult {
		select {
		case err := <-errCh:
			return []employer.Employer{}, err
		default:
		}
		newList[i] = v
		i++
	}

	if len(errCh) > 0 {
		return []employer.Employer{}, <-errCh
	}

	return newList, nil
}

// PMapEmployeeEmployerPtr applies the function(1st argument) on each item in the list and returns a new list.
//  Order of new list is guaranteed. This feature can be disabled by passing: Optional{RandomOrder: true} to gain performance
//  Run in parallel. no_of_goroutines = no_of_items_in_list or 3rd argument can be passed to fix the number of goroutines.
//
// Takes 3 inputs. 3rd argument is optional
//  1. Function - takes 1 input
//  2. List
//  3. optional argument - fp.Optional{FixedPool: <some_number>}
func PMapEmployeeEmployerPtr(f func(*employee.Employee) *employer.Employer, list []*employee.Employee, optional ...fp.Optional) []*employer.Employer {
	if f == nil {
		return []*employer.Employer{}
	}

	var worker = len(list)
	if optional != nil && len(optional) > 0 {
		if optional[0].FixedPool > 0 && optional[0].FixedPool < worker {
			worker = optional[0].FixedPool
		}

		if optional[0].RandomOrder == true {
			return pMapEmployeeEmployerPtrNoOrder(f, list, worker)
		}
	}

	return pMapEmployeeEmployerPtrPreserveOrder(f, list, worker)
}

func pMapEmployeeEmployerPtrPreserveOrder(f func(*employee.Employee) *employer.Employer, list []*employee.Employee, worker int) []*employer.Employer {
	chJobs := make(chan map[int]*employee.Employee, len(list))
	go func() {
		for i, v := range list {
			chJobs <- map[int]*employee.Employee{i: v}
		}
		close(chJobs)
	}()

	chResult := make(chan map[int]*employer.Employer, worker/3)

	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan map[int]*employer.Employer, chJobs chan map[int]*employee.Employee) {
			defer wg.Done()

			for m := range chJobs {
				for k, v := range m {
					chResult <- map[int]*employer.Employer{k: f(v)}
				}
			}
		}(chResult, chJobs)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newListMap := make(map[int]*employer.Employer, len(list))
	newList := make([]*employer.Employer, len(list))

	for m := range chResult {
		for k, v := range m {
			newListMap[k] = v
		}
	}

	for i := 0; i < len(list); i++ {
		newList[i] = newListMap[i]
	}

	return newList
}

func pMapEmployeeEmployerPtrNoOrder(f func(*employee.Employee) *employer.Employer, list []*employee.Employee, worker int) []*employer.Employer {
	chJobs := make(chan *employee.Employee, len(list))
	go func() {
		for _, v := range list {
			chJobs <- v
		}
		close(chJobs)
	}()

	chResult := make(chan *employer.Employer, worker/3)

	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan *employer.Employer, chJobs chan *employee.Employee) {
			defer wg.Done()

			for v := range chJobs {
				chResult <- f(v)
			}
		}(chResult, chJobs)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newList := make([]*employer.Employer, len(list))
	i := 0

	for v := range chResult {
		newList[i] = v
		i++
	}

	return newList
}

// PMapEmployeeEmployerPtrErr applies the function(1st argument) on each item in the list and returns a new list and error.
//  Order of new list is guaranteed. This feature can be disabled by passing: Optional{RandomOrder: true} to gain performance
//  Run in parallel. no_of_goroutines = no_of_items_in_list or 3rd argument can be passed to fix the number of goroutines.
//
// Takes 3 inputs. 3rd argument is optional
//  1. Function - takes 1 input
//  2. List
//  3. optional argument - fp.Optional{FixedPool: <some_number>}
func PMapEmployeeEmployerPtrErr(f func(*employee.Employee) (*employer.Employer, error), list []*employee.Employee, optional ...fp.Optional) ([]*employer.Employer, error) {
	if f == nil {
		return []*employer.Employer{}, nil
	}

	var worker = len(list)
	if optional != nil && len(optional) > 0 {
		if optional[0].FixedPool > 0 && optional[0].FixedPool < worker {
			worker = optional[0].FixedPool
		}

		if optional[0].RandomOrder == true {
			return pMapEmployeeEmployerPtrErrNoOrder(f, list, worker)
		}
	}

	return pMapEmployeeEmployerPtrErrPreserveOrder(f, list, worker)
}

func pMapEmployeeEmployerPtrErrPreserveOrder(f func(*employee.Employee) (*employer.Employer, error), list []*employee.Employee, worker int) ([]*employer.Employer, error) {
	chJobs := make(chan map[int]*employee.Employee, len(list))
	go func() {
		for i, v := range list {
			chJobs <- map[int]*employee.Employee{i: v}
		}
		close(chJobs)
	}()

	chResult := make(chan map[int]*employer.Employer, worker/3)

	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan map[int]*employer.Employer, chJobs chan map[int]*employee.Employee, errCh chan error) {
			defer wg.Done()
			if len(errCh) > 0 {
				return
			}
			for m := range chJobs {
				for k, v := range m {
					r, err := f(v)
					if err != nil {
						errCh <- err
						return
					}
					chResult <- map[int]*employer.Employer{k: r}
				}
			}
		}(chResult, chJobs, errCh)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newListMap := make(map[int]*employer.Employer, len(list))
	newList := make([]*employer.Employer, len(list))

	for m := range chResult {
		select {
		case err := <-errCh:
			return []*employer.Employer{}, err
		default:
		}
		for k, v := range m {
			newListMap[k] = v
		}
	}

	if len(errCh) > 0 {
		return []*employer.Employer{}, <-errCh
	}

	for i := 0; i < len(list); i++ {
		newList[i] = newListMap[i]
	}

	return newList, nil
}

func pMapEmployeeEmployerPtrErrNoOrder(f func(*employee.Employee) (*employer.Employer, error), list []*employee.Employee, worker int) ([]*employer.Employer, error) {
	chJobs := make(chan *employee.Employee, len(list))
	go func() {
		for _, v := range list {
			chJobs <- v
		}
		close(chJobs)
	}()

	chResult := make(chan *employer.Employer, worker/3)

	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan *employer.Employer, chJobs chan *employee.Employee, errCh chan error) {
			defer wg.Done()
			if len(errCh) > 0 {
				return
			}
			for v := range chJobs {
				r, err := f(v)
				if err != nil {
					errCh <- err
					return
				}
				chResult <- r
			}
		}(chResult, chJobs, errCh)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newList := make([]*employer.Employer, len(list))
	i := 0

	for v := range chResult {
		select {
		case err := <-errCh:
			return []*employer.Employer{}, err
		default:
		}
		newList[i] = v
		i++
	}

	if len(errCh) > 0 {
		return []*employer.Employer{}, <-errCh
	}

	return newList, nil
}

// FilterMapEmployeeEmployer filters given list, then apply function(2nd argument) on each item in the list and returns a new list
// Takes 3 inputs
//	1. Function: takes one input type - employee.Employee and returns true/false.
//	2. Function: takes employee.Employee as argument and returns employer.Employer
// 	3. List of type employee.Employee
//
// Returns:
//	New List of type employer.Employer
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapEmployeeEmployer(fFilter func(employee.Employee) bool, fMap func(employee.Employee) employer.Employer, list []employee.Employee) []employer.Employer {
	if fFilter == nil || fMap == nil {
		return []employer.Employer{}
	}
	var newList []employer.Employer
	for _, v := range list {
		if fFilter(v) {
			newList = append(newList, fMap(v))
		}
	}
	return newList
}

// FilterMapEmployeeEmployerPtrErr filters given list, then apply function(2nd argument) on each item in the list and returns a new list, error
// Takes 3 inputs
//	1. Function: takes one input type - *employee.Employee and returns (bool, error).
//	2. Function: takes *employee.Employee as argument and returns (*employer.Employer, error)
// 	3. List of type *employee.Employee
//
// Returns:
//	New List of type *employer.Employer, error
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapEmployeeEmployerPtrErr(fFilter func(*employee.Employee) (bool, error), fMap func(*employee.Employee) (*employer.Employer, error), list []*employee.Employee) ([]*employer.Employer, error) {
	if fFilter == nil || fMap == nil {
		return []*employer.Employer{}, nil
	}
	var newList []*employer.Employer
	for _, v := range list {
		r, err := fFilter(v)
		if err != nil {
			return nil, err
		}
		if r {
			r, err := fMap(v)
			if err != nil {
				return nil, err
			}
			newList = append(newList, r)
		}
	}
	return newList, nil
}

// FilterMapEmployeeEmployerErr filters given list, then apply function(2nd argument) on each item in the list and returns a new list, error
// Takes 3 inputs
//	1. Function: takes one input type - employee.Employee and returns (bool, error).
//	2. Function: takes employee.Employee as argument and returns (employer.Employer, error)
// 	3. List of type employee.Employee
//
// Returns:
//	New List of type employer.Employer, error
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapEmployeeEmployerErr(fFilter func(employee.Employee) (bool, error), fMap func(employee.Employee) (employer.Employer, error), list []employee.Employee) ([]employer.Employer, error) {
	if fFilter == nil || fMap == nil {
		return []employer.Employer{}, nil
	}
	var newList []employer.Employer
	for _, v := range list {
		r, err := fFilter(v)
		if err != nil {
			return nil, err
		}
		if r {
			r, err := fMap(v)
			if err != nil {
				return nil, err
			}
			newList = append(newList, r)
		}
	}
	return newList, nil
}

// MapEmployeeInt takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list
func MapEmployeeInt(f func(employee.Employee) int, list []employee.Employee) []int {
	if f == nil {
		return []int{}
	}
	newList := make([]int, len(list))
	for i, v := range list {
		newList[i] = f(v)
	}
	return newList
}

// MapEmployeeIntErr takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list and error
func MapEmployeeIntErr(f func(employee.Employee) (int, error), list []employee.Employee) ([]int, error) {
	if f == nil {
		return []int{}, nil
	}
	newList := make([]int, len(list))
	for i, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		newList[i] = r
	}
	return newList, nil
}

// MapEmployeeIntPtr takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list
func MapEmployeeIntPtr(f func(*employee.Employee) *int, list []*employee.Employee) []*int {
	if f == nil {
		return []*int{}
	}
	newList := make([]*int, len(list))
	for i, v := range list {
		newList[i] = f(v)
	}
	return newList
}

// MapEmployeeIntPtrErr takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list, error
func MapEmployeeIntPtrErr(f func(*employee.Employee) (*int, error), list []*employee.Employee) ([]*int, error) {
	if f == nil {
		return []*int{}, nil
	}
	newList := make([]*int, len(list))
	for i, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		newList[i] = r
	}
	return newList, nil
}

// PMapEmployeeInt applies the function(1st argument) on each item in the list and returns a new list.
//  Order of new list is guaranteed. This feature can be disabled by passing: Optional{RandomOrder: true} to gain performance
//  Run in parallel. no_of_goroutines = no_of_items_in_list or 3rd argument can be passed to fix the number of goroutines.
//
// Takes 3 inputs. 3rd argument is optional
//  1. Function - takes 1 input
//  2. List
//  3. optional argument - fp.Optional{FixedPool: <some_number>}
func PMapEmployeeInt(f func(employee.Employee) int, list []employee.Employee, optional ...fp.Optional) []int {
	if f == nil {
		return []int{}
	}

	var worker = len(list)
	if optional != nil && len(optional) > 0 {
		if optional[0].FixedPool > 0 && optional[0].FixedPool < worker {
			worker = optional[0].FixedPool
		}

		if optional[0].RandomOrder == true {
			return pMapEmployeeIntNoOrder(f, list, worker)
		}
	}

	return pMapEmployeeIntPreserveOrder(f, list, worker)
}

func pMapEmployeeIntPreserveOrder(f func(employee.Employee) int, list []employee.Employee, worker int) []int {
	chJobs := make(chan map[int]employee.Employee, len(list))
	go func() {
		for i, v := range list {
			chJobs <- map[int]employee.Employee{i: v}
		}
		close(chJobs)
	}()

	chResult := make(chan map[int]int, worker/3)

	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan map[int]int, chJobs chan map[int]employee.Employee) {
			defer wg.Done()

			for m := range chJobs {
				for k, v := range m {
					chResult <- map[int]int{k: f(v)}
				}
			}
		}(chResult, chJobs)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newListMap := make(map[int]int, len(list))
	newList := make([]int, len(list))

	for m := range chResult {
		for k, v := range m {
			newListMap[k] = v
		}
	}

	for i := 0; i < len(list); i++ {
		newList[i] = newListMap[i]
	}

	return newList
}

func pMapEmployeeIntNoOrder(f func(employee.Employee) int, list []employee.Employee, worker int) []int {
	chJobs := make(chan employee.Employee, len(list))
	go func() {
		for _, v := range list {
			chJobs <- v
		}
		close(chJobs)
	}()

	chResult := make(chan int, worker/3)

	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan int, chJobs chan employee.Employee) {
			defer wg.Done()

			for v := range chJobs {
				chResult <- f(v)
			}
		}(chResult, chJobs)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newList := make([]int, len(list))
	i := 0

	for v := range chResult {
		newList[i] = v
		i++
	}

	return newList
}

// PMapEmployeeIntErr applies the function(1st argument) on each item in the list and returns a new list and error.
//  Order of new list is guaranteed. This feature can be disabled by passing: Optional{RandomOrder: true} to gain performance
//  Run in parallel. no_of_goroutines = no_of_items_in_list or 3rd argument can be passed to fix the number of goroutines.
//
// Takes 3 inputs. 3rd argument is optional
//  1. Function - takes 1 input
//  2. List
//  3. optional argument - fp.Optional{FixedPool: <some_number>}
func PMapEmployeeIntErr(f func(employee.Employee) (int, error), list []employee.Employee, optional ...fp.Optional) ([]int, error) {
	if f == nil {
		return []int{}, nil
	}

	var worker = len(list)
	if optional != nil && len(optional) > 0 {
		if optional[0].FixedPool > 0 && optional[0].FixedPool < worker {
			worker = optional[0].FixedPool
		}

		if optional[0].RandomOrder == true {
			return pMapEmployeeIntErrNoOrder(f, list, worker)
		}
	}

	return pMapEmployeeIntErrPreserveOrder(f, list, worker)
}

func pMapEmployeeIntErrPreserveOrder(f func(employee.Employee) (int, error), list []employee.Employee, worker int) ([]int, error) {
	chJobs := make(chan map[int]employee.Employee, len(list))
	go func() {
		for i, v := range list {
			chJobs <- map[int]employee.Employee{i: v}
		}
		close(chJobs)
	}()

	chResult := make(chan map[int]int, worker/3)

	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan map[int]int, chJobs chan map[int]employee.Employee, errCh chan error) {
			defer wg.Done()
			if len(errCh) > 0 {
				return
			}
			for m := range chJobs {
				for k, v := range m {
					r, err := f(v)
					if err != nil {
						errCh <- err
						return
					}
					chResult <- map[int]int{k: r}
				}
			}
		}(chResult, chJobs, errCh)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newListMap := make(map[int]int, len(list))
	newList := make([]int, len(list))

	for m := range chResult {
		select {
		case err := <-errCh:
			return []int{}, err
		default:
		}
		for k, v := range m {
			newListMap[k] = v
		}
	}

	if len(errCh) > 0 {
		return []int{}, <-errCh
	}

	for i := 0; i < len(list); i++ {
		newList[i] = newListMap[i]
	}

	return newList, nil
}

func pMapEmployeeIntErrNoOrder(f func(employee.Employee) (int, error), list []employee.Employee, worker int) ([]int, error) {
	chJobs := make(chan employee.Employee, len(list))
	go func() {
		for _, v := range list {
			chJobs <- v
		}
		close(chJobs)
	}()

	chResult := make(chan int, worker/3)

	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan int, chJobs chan employee.Employee, errCh chan error) {
			defer wg.Done()
			if len(errCh) > 0 {
				return
			}
			for v := range chJobs {
				r, err := f(v)
				if err != nil {
					errCh <- err
					return
				}
				chResult <- r
			}
		}(chResult, chJobs, errCh)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newList := make([]int, len(list))
	i := 0

	for v := range chResult {
		select {
		case err := <-errCh:
			return []int{}, err
		default:
		}
		newList[i] = v
		i++
	}

	if len(errCh) > 0 {
		return []int{}, <-errCh
	}

	return newList, nil
}

// PMapEmployeeIntPtr applies the function(1st argument) on each item in the list and returns a new list.
//  Order of new list is guaranteed. This feature can be disabled by passing: Optional{RandomOrder: true} to gain performance
//  Run in parallel. no_of_goroutines = no_of_items_in_list or 3rd argument can be passed to fix the number of goroutines.
//
// Takes 3 inputs. 3rd argument is optional
//  1. Function - takes 1 input
//  2. List
//  3. optional argument - fp.Optional{FixedPool: <some_number>}
func PMapEmployeeIntPtr(f func(*employee.Employee) *int, list []*employee.Employee, optional ...fp.Optional) []*int {
	if f == nil {
		return []*int{}
	}

	var worker = len(list)
	if optional != nil && len(optional) > 0 {
		if optional[0].FixedPool > 0 && optional[0].FixedPool < worker {
			worker = optional[0].FixedPool
		}

		if optional[0].RandomOrder == true {
			return pMapEmployeeIntPtrNoOrder(f, list, worker)
		}
	}

	return pMapEmployeeIntPtrPreserveOrder(f, list, worker)
}

func pMapEmployeeIntPtrPreserveOrder(f func(*employee.Employee) *int, list []*employee.Employee, worker int) []*int {
	chJobs := make(chan map[int]*employee.Employee, len(list))
	go func() {
		for i, v := range list {
			chJobs <- map[int]*employee.Employee{i: v}
		}
		close(chJobs)
	}()

	chResult := make(chan map[int]*int, worker/3)

	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan map[int]*int, chJobs chan map[int]*employee.Employee) {
			defer wg.Done()

			for m := range chJobs {
				for k, v := range m {
					chResult <- map[int]*int{k: f(v)}
				}
			}
		}(chResult, chJobs)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newListMap := make(map[int]*int, len(list))
	newList := make([]*int, len(list))

	for m := range chResult {
		for k, v := range m {
			newListMap[k] = v
		}
	}

	for i := 0; i < len(list); i++ {
		newList[i] = newListMap[i]
	}

	return newList
}

func pMapEmployeeIntPtrNoOrder(f func(*employee.Employee) *int, list []*employee.Employee, worker int) []*int {
	chJobs := make(chan *employee.Employee, len(list))
	go func() {
		for _, v := range list {
			chJobs <- v
		}
		close(chJobs)
	}()

	chResult := make(chan *int, worker/3)

	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan *int, chJobs chan *employee.Employee) {
			defer wg.Done()

			for v := range chJobs {
				chResult <- f(v)
			}
		}(chResult, chJobs)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newList := make([]*int, len(list))
	i := 0

	for v := range chResult {
		newList[i] = v
		i++
	}

	return newList
}

// PMapEmployeeIntPtrErr applies the function(1st argument) on each item in the list and returns a new list and error.
//  Order of new list is guaranteed. This feature can be disabled by passing: Optional{RandomOrder: true} to gain performance
//  Run in parallel. no_of_goroutines = no_of_items_in_list or 3rd argument can be passed to fix the number of goroutines.
//
// Takes 3 inputs. 3rd argument is optional
//  1. Function - takes 1 input
//  2. List
//  3. optional argument - fp.Optional{FixedPool: <some_number>}
func PMapEmployeeIntPtrErr(f func(*employee.Employee) (*int, error), list []*employee.Employee, optional ...fp.Optional) ([]*int, error) {
	if f == nil {
		return []*int{}, nil
	}

	var worker = len(list)
	if optional != nil && len(optional) > 0 {
		if optional[0].FixedPool > 0 && optional[0].FixedPool < worker {
			worker = optional[0].FixedPool
		}

		if optional[0].RandomOrder == true {
			return pMapEmployeeIntPtrErrNoOrder(f, list, worker)
		}
	}

	return pMapEmployeeIntPtrErrPreserveOrder(f, list, worker)
}

func pMapEmployeeIntPtrErrPreserveOrder(f func(*employee.Employee) (*int, error), list []*employee.Employee, worker int) ([]*int, error) {
	chJobs := make(chan map[int]*employee.Employee, len(list))
	go func() {
		for i, v := range list {
			chJobs <- map[int]*employee.Employee{i: v}
		}
		close(chJobs)
	}()

	chResult := make(chan map[int]*int, worker/3)

	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan map[int]*int, chJobs chan map[int]*employee.Employee, errCh chan error) {
			defer wg.Done()
			if len(errCh) > 0 {
				return
			}
			for m := range chJobs {
				for k, v := range m {
					r, err := f(v)
					if err != nil {
						errCh <- err
						return
					}
					chResult <- map[int]*int{k: r}
				}
			}
		}(chResult, chJobs, errCh)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newListMap := make(map[int]*int, len(list))
	newList := make([]*int, len(list))

	for m := range chResult {
		select {
		case err := <-errCh:
			return []*int{}, err
		default:
		}
		for k, v := range m {
			newListMap[k] = v
		}
	}

	if len(errCh) > 0 {
		return []*int{}, <-errCh
	}

	for i := 0; i < len(list); i++ {
		newList[i] = newListMap[i]
	}

	return newList, nil
}

func pMapEmployeeIntPtrErrNoOrder(f func(*employee.Employee) (*int, error), list []*employee.Employee, worker int) ([]*int, error) {
	chJobs := make(chan *employee.Employee, len(list))
	go func() {
		for _, v := range list {
			chJobs <- v
		}
		close(chJobs)
	}()

	chResult := make(chan *int, worker/3)

	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan *int, chJobs chan *employee.Employee, errCh chan error) {
			defer wg.Done()
			if len(errCh) > 0 {
				return
			}
			for v := range chJobs {
				r, err := f(v)
				if err != nil {
					errCh <- err
					return
				}
				chResult <- r
			}
		}(chResult, chJobs, errCh)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newList := make([]*int, len(list))
	i := 0

	for v := range chResult {
		select {
		case err := <-errCh:
			return []*int{}, err
		default:
		}
		newList[i] = v
		i++
	}

	if len(errCh) > 0 {
		return []*int{}, <-errCh
	}

	return newList, nil
}

// FilterMapEmployeeInt filters given list, then apply function(2nd argument) on each item in the list and returns a new list
// Takes 3 inputs
//	1. Function: takes one input type - employee.Employee and returns true/false.
//	2. Function: takes employee.Employee as argument and returns int
// 	3. List of type employee.Employee
//
// Returns:
//	New List of type int
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapEmployeeInt(fFilter func(employee.Employee) bool, fMap func(employee.Employee) int, list []employee.Employee) []int {
	if fFilter == nil || fMap == nil {
		return []int{}
	}
	var newList []int
	for _, v := range list {
		if fFilter(v) {
			newList = append(newList, fMap(v))
		}
	}
	return newList
}

// FilterMapEmployeeIntPtrErr filters given list, then apply function(2nd argument) on each item in the list and returns a new list, error
// Takes 3 inputs
//	1. Function: takes one input type - *employee.Employee and returns (bool, error).
//	2. Function: takes *employee.Employee as argument and returns (*int, error)
// 	3. List of type *employee.Employee
//
// Returns:
//	New List of type *int, error
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapEmployeeIntPtrErr(fFilter func(*employee.Employee) (bool, error), fMap func(*employee.Employee) (*int, error), list []*employee.Employee) ([]*int, error) {
	if fFilter == nil || fMap == nil {
		return []*int{}, nil
	}
	var newList []*int
	for _, v := range list {
		r, err := fFilter(v)
		if err != nil {
			return nil, err
		}
		if r {
			r, err := fMap(v)
			if err != nil {
				return nil, err
			}
			newList = append(newList, r)
		}
	}
	return newList, nil
}

// FilterMapEmployeeIntErr filters given list, then apply function(2nd argument) on each item in the list and returns a new list, error
// Takes 3 inputs
//	1. Function: takes one input type - employee.Employee and returns (bool, error).
//	2. Function: takes employee.Employee as argument and returns (int, error)
// 	3. List of type employee.Employee
//
// Returns:
//	New List of type int, error
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapEmployeeIntErr(fFilter func(employee.Employee) (bool, error), fMap func(employee.Employee) (int, error), list []employee.Employee) ([]int, error) {
	if fFilter == nil || fMap == nil {
		return []int{}, nil
	}
	var newList []int
	for _, v := range list {
		r, err := fFilter(v)
		if err != nil {
			return nil, err
		}
		if r {
			r, err := fMap(v)
			if err != nil {
				return nil, err
			}
			newList = append(newList, r)
		}
	}
	return newList, nil
}

// MapIntEmployer takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list
func MapIntEmployer(f func(int) employer.Employer, list []int) []employer.Employer {
	if f == nil {
		return []employer.Employer{}
	}
	newList := make([]employer.Employer, len(list))
	for i, v := range list {
		newList[i] = f(v)
	}
	return newList
}

// MapIntEmployerErr takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list and error
func MapIntEmployerErr(f func(int) (employer.Employer, error), list []int) ([]employer.Employer, error) {
	if f == nil {
		return []employer.Employer{}, nil
	}
	newList := make([]employer.Employer, len(list))
	for i, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		newList[i] = r
	}
	return newList, nil
}

// MapIntEmployerPtr takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list
func MapIntEmployerPtr(f func(*int) *employer.Employer, list []*int) []*employer.Employer {
	if f == nil {
		return []*employer.Employer{}
	}
	newList := make([]*employer.Employer, len(list))
	for i, v := range list {
		newList[i] = f(v)
	}
	return newList
}

// MapIntEmployerPtrErr takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list, error
func MapIntEmployerPtrErr(f func(*int) (*employer.Employer, error), list []*int) ([]*employer.Employer, error) {
	if f == nil {
		return []*employer.Employer{}, nil
	}
	newList := make([]*employer.Employer, len(list))
	for i, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		newList[i] = r
	}
	return newList, nil
}

// PMapIntEmployer applies the function(1st argument) on each item in the list and returns a new list.
//  Order of new list is guaranteed. This feature can be disabled by passing: Optional{RandomOrder: true} to gain performance
//  Run in parallel. no_of_goroutines = no_of_items_in_list or 3rd argument can be passed to fix the number of goroutines.
//
// Takes 3 inputs. 3rd argument is optional
//  1. Function - takes 1 input
//  2. List
//  3. optional argument - fp.Optional{FixedPool: <some_number>}
func PMapIntEmployer(f func(int) employer.Employer, list []int, optional ...fp.Optional) []employer.Employer {
	if f == nil {
		return []employer.Employer{}
	}

	var worker = len(list)
	if optional != nil && len(optional) > 0 {
		if optional[0].FixedPool > 0 && optional[0].FixedPool < worker {
			worker = optional[0].FixedPool
		}

		if optional[0].RandomOrder == true {
			return pMapIntEmployerNoOrder(f, list, worker)
		}
	}

	return pMapIntEmployerPreserveOrder(f, list, worker)
}

func pMapIntEmployerPreserveOrder(f func(int) employer.Employer, list []int, worker int) []employer.Employer {
	chJobs := make(chan map[int]int, len(list))
	go func() {
		for i, v := range list {
			chJobs <- map[int]int{i: v}
		}
		close(chJobs)
	}()

	chResult := make(chan map[int]employer.Employer, worker/3)

	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan map[int]employer.Employer, chJobs chan map[int]int) {
			defer wg.Done()

			for m := range chJobs {
				for k, v := range m {
					chResult <- map[int]employer.Employer{k: f(v)}
				}
			}
		}(chResult, chJobs)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newListMap := make(map[int]employer.Employer, len(list))
	newList := make([]employer.Employer, len(list))

	for m := range chResult {
		for k, v := range m {
			newListMap[k] = v
		}
	}

	for i := 0; i < len(list); i++ {
		newList[i] = newListMap[i]
	}

	return newList
}

func pMapIntEmployerNoOrder(f func(int) employer.Employer, list []int, worker int) []employer.Employer {
	chJobs := make(chan int, len(list))
	go func() {
		for _, v := range list {
			chJobs <- v
		}
		close(chJobs)
	}()

	chResult := make(chan employer.Employer, worker/3)

	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan employer.Employer, chJobs chan int) {
			defer wg.Done()

			for v := range chJobs {
				chResult <- f(v)
			}
		}(chResult, chJobs)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newList := make([]employer.Employer, len(list))
	i := 0

	for v := range chResult {
		newList[i] = v
		i++
	}

	return newList
}

// PMapIntEmployerErr applies the function(1st argument) on each item in the list and returns a new list and error.
//  Order of new list is guaranteed. This feature can be disabled by passing: Optional{RandomOrder: true} to gain performance
//  Run in parallel. no_of_goroutines = no_of_items_in_list or 3rd argument can be passed to fix the number of goroutines.
//
// Takes 3 inputs. 3rd argument is optional
//  1. Function - takes 1 input
//  2. List
//  3. optional argument - fp.Optional{FixedPool: <some_number>}
func PMapIntEmployerErr(f func(int) (employer.Employer, error), list []int, optional ...fp.Optional) ([]employer.Employer, error) {
	if f == nil {
		return []employer.Employer{}, nil
	}

	var worker = len(list)
	if optional != nil && len(optional) > 0 {
		if optional[0].FixedPool > 0 && optional[0].FixedPool < worker {
			worker = optional[0].FixedPool
		}

		if optional[0].RandomOrder == true {
			return pMapIntEmployerErrNoOrder(f, list, worker)
		}
	}

	return pMapIntEmployerErrPreserveOrder(f, list, worker)
}

func pMapIntEmployerErrPreserveOrder(f func(int) (employer.Employer, error), list []int, worker int) ([]employer.Employer, error) {
	chJobs := make(chan map[int]int, len(list))
	go func() {
		for i, v := range list {
			chJobs <- map[int]int{i: v}
		}
		close(chJobs)
	}()

	chResult := make(chan map[int]employer.Employer, worker/3)

	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan map[int]employer.Employer, chJobs chan map[int]int, errCh chan error) {
			defer wg.Done()
			if len(errCh) > 0 {
				return
			}
			for m := range chJobs {
				for k, v := range m {
					r, err := f(v)
					if err != nil {
						errCh <- err
						return
					}
					chResult <- map[int]employer.Employer{k: r}
				}
			}
		}(chResult, chJobs, errCh)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newListMap := make(map[int]employer.Employer, len(list))
	newList := make([]employer.Employer, len(list))

	for m := range chResult {
		select {
		case err := <-errCh:
			return []employer.Employer{}, err
		default:
		}
		for k, v := range m {
			newListMap[k] = v
		}
	}

	if len(errCh) > 0 {
		return []employer.Employer{}, <-errCh
	}

	for i := 0; i < len(list); i++ {
		newList[i] = newListMap[i]
	}

	return newList, nil
}

func pMapIntEmployerErrNoOrder(f func(int) (employer.Employer, error), list []int, worker int) ([]employer.Employer, error) {
	chJobs := make(chan int, len(list))
	go func() {
		for _, v := range list {
			chJobs <- v
		}
		close(chJobs)
	}()

	chResult := make(chan employer.Employer, worker/3)

	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan employer.Employer, chJobs chan int, errCh chan error) {
			defer wg.Done()
			if len(errCh) > 0 {
				return
			}
			for v := range chJobs {
				r, err := f(v)
				if err != nil {
					errCh <- err
					return
				}
				chResult <- r
			}
		}(chResult, chJobs, errCh)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newList := make([]employer.Employer, len(list))
	i := 0

	for v := range chResult {
		select {
		case err := <-errCh:
			return []employer.Employer{}, err
		default:
		}
		newList[i] = v
		i++
	}

	if len(errCh) > 0 {
		return []employer.Employer{}, <-errCh
	}

	return newList, nil
}

// PMapIntEmployerPtr applies the function(1st argument) on each item in the list and returns a new list.
//  Order of new list is guaranteed. This feature can be disabled by passing: Optional{RandomOrder: true} to gain performance
//  Run in parallel. no_of_goroutines = no_of_items_in_list or 3rd argument can be passed to fix the number of goroutines.
//
// Takes 3 inputs. 3rd argument is optional
//  1. Function - takes 1 input
//  2. List
//  3. optional argument - fp.Optional{FixedPool: <some_number>}
func PMapIntEmployerPtr(f func(*int) *employer.Employer, list []*int, optional ...fp.Optional) []*employer.Employer {
	if f == nil {
		return []*employer.Employer{}
	}

	var worker = len(list)
	if optional != nil && len(optional) > 0 {
		if optional[0].FixedPool > 0 && optional[0].FixedPool < worker {
			worker = optional[0].FixedPool
		}

		if optional[0].RandomOrder == true {
			return pMapIntEmployerPtrNoOrder(f, list, worker)
		}
	}

	return pMapIntEmployerPtrPreserveOrder(f, list, worker)
}

func pMapIntEmployerPtrPreserveOrder(f func(*int) *employer.Employer, list []*int, worker int) []*employer.Employer {
	chJobs := make(chan map[int]*int, len(list))
	go func() {
		for i, v := range list {
			chJobs <- map[int]*int{i: v}
		}
		close(chJobs)
	}()

	chResult := make(chan map[int]*employer.Employer, worker/3)

	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan map[int]*employer.Employer, chJobs chan map[int]*int) {
			defer wg.Done()

			for m := range chJobs {
				for k, v := range m {
					chResult <- map[int]*employer.Employer{k: f(v)}
				}
			}
		}(chResult, chJobs)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newListMap := make(map[int]*employer.Employer, len(list))
	newList := make([]*employer.Employer, len(list))

	for m := range chResult {
		for k, v := range m {
			newListMap[k] = v
		}
	}

	for i := 0; i < len(list); i++ {
		newList[i] = newListMap[i]
	}

	return newList
}

func pMapIntEmployerPtrNoOrder(f func(*int) *employer.Employer, list []*int, worker int) []*employer.Employer {
	chJobs := make(chan *int, len(list))
	go func() {
		for _, v := range list {
			chJobs <- v
		}
		close(chJobs)
	}()

	chResult := make(chan *employer.Employer, worker/3)

	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan *employer.Employer, chJobs chan *int) {
			defer wg.Done()

			for v := range chJobs {
				chResult <- f(v)
			}
		}(chResult, chJobs)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newList := make([]*employer.Employer, len(list))
	i := 0

	for v := range chResult {
		newList[i] = v
		i++
	}

	return newList
}

// PMapIntEmployerPtrErr applies the function(1st argument) on each item in the list and returns a new list and error.
//  Order of new list is guaranteed. This feature can be disabled by passing: Optional{RandomOrder: true} to gain performance
//  Run in parallel. no_of_goroutines = no_of_items_in_list or 3rd argument can be passed to fix the number of goroutines.
//
// Takes 3 inputs. 3rd argument is optional
//  1. Function - takes 1 input
//  2. List
//  3. optional argument - fp.Optional{FixedPool: <some_number>}
func PMapIntEmployerPtrErr(f func(*int) (*employer.Employer, error), list []*int, optional ...fp.Optional) ([]*employer.Employer, error) {
	if f == nil {
		return []*employer.Employer{}, nil
	}

	var worker = len(list)
	if optional != nil && len(optional) > 0 {
		if optional[0].FixedPool > 0 && optional[0].FixedPool < worker {
			worker = optional[0].FixedPool
		}

		if optional[0].RandomOrder == true {
			return pMapIntEmployerPtrErrNoOrder(f, list, worker)
		}
	}

	return pMapIntEmployerPtrErrPreserveOrder(f, list, worker)
}

func pMapIntEmployerPtrErrPreserveOrder(f func(*int) (*employer.Employer, error), list []*int, worker int) ([]*employer.Employer, error) {
	chJobs := make(chan map[int]*int, len(list))
	go func() {
		for i, v := range list {
			chJobs <- map[int]*int{i: v}
		}
		close(chJobs)
	}()

	chResult := make(chan map[int]*employer.Employer, worker/3)

	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan map[int]*employer.Employer, chJobs chan map[int]*int, errCh chan error) {
			defer wg.Done()
			if len(errCh) > 0 {
				return
			}
			for m := range chJobs {
				for k, v := range m {
					r, err := f(v)
					if err != nil {
						errCh <- err
						return
					}
					chResult <- map[int]*employer.Employer{k: r}
				}
			}
		}(chResult, chJobs, errCh)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newListMap := make(map[int]*employer.Employer, len(list))
	newList := make([]*employer.Employer, len(list))

	for m := range chResult {
		select {
		case err := <-errCh:
			return []*employer.Employer{}, err
		default:
		}
		for k, v := range m {
			newListMap[k] = v
		}
	}

	if len(errCh) > 0 {
		return []*employer.Employer{}, <-errCh
	}

	for i := 0; i < len(list); i++ {
		newList[i] = newListMap[i]
	}

	return newList, nil
}

func pMapIntEmployerPtrErrNoOrder(f func(*int) (*employer.Employer, error), list []*int, worker int) ([]*employer.Employer, error) {
	chJobs := make(chan *int, len(list))
	go func() {
		for _, v := range list {
			chJobs <- v
		}
		close(chJobs)
	}()

	chResult := make(chan *employer.Employer, worker/3)

	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan *employer.Employer, chJobs chan *int, errCh chan error) {
			defer wg.Done()
			if len(errCh) > 0 {
				return
			}
			for v := range chJobs {
				r, err := f(v)
				if err != nil {
					errCh <- err
					return
				}
				chResult <- r
			}
		}(chResult, chJobs, errCh)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newList := make([]*employer.Employer, len(list))
	i := 0

	for v := range chResult {
		select {
		case err := <-errCh:
			return []*employer.Employer{}, err
		default:
		}
		newList[i] = v
		i++
	}

	if len(errCh) > 0 {
		return []*employer.Employer{}, <-errCh
	}

	return newList, nil
}

// FilterMapIntEmployer filters given list, then apply function(2nd argument) on each item in the list and returns a new list
// Takes 3 inputs
//	1. Function: takes one input type - int and returns true/false.
//	2. Function: takes int as argument and returns employer.Employer
// 	3. List of type int
//
// Returns:
//	New List of type employer.Employer
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapIntEmployer(fFilter func(int) bool, fMap func(int) employer.Employer, list []int) []employer.Employer {
	if fFilter == nil || fMap == nil {
		return []employer.Employer{}
	}
	var newList []employer.Employer
	for _, v := range list {
		if fFilter(v) {
			newList = append(newList, fMap(v))
		}
	}
	return newList
}

// FilterMapIntEmployerPtrErr filters given list, then apply function(2nd argument) on each item in the list and returns a new list, error
// Takes 3 inputs
//	1. Function: takes one input type - *int and returns (bool, error).
//	2. Function: takes *int as argument and returns (*employer.Employer, error)
// 	3. List of type *int
//
// Returns:
//	New List of type *employer.Employer, error
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapIntEmployerPtrErr(fFilter func(*int) (bool, error), fMap func(*int) (*employer.Employer, error), list []*int) ([]*employer.Employer, error) {
	if fFilter == nil || fMap == nil {
		return []*employer.Employer{}, nil
	}
	var newList []*employer.Employer
	for _, v := range list {
		r, err := fFilter(v)
		if err != nil {
			return nil, err
		}
		if r {
			r, err := fMap(v)
			if err != nil {
				return nil, err
			}
			newList = append(newList, r)
		}
	}
	return newList, nil
}

// FilterMapIntEmployerErr filters given list, then apply function(2nd argument) on each item in the list and returns a new list, error
// Takes 3 inputs
//	1. Function: takes one input type - int and returns (bool, error).
//	2. Function: takes int as argument and returns (employer.Employer, error)
// 	3. List of type int
//
// Returns:
//	New List of type employer.Employer, error
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapIntEmployerErr(fFilter func(int) (bool, error), fMap func(int) (employer.Employer, error), list []int) ([]employer.Employer, error) {
	if fFilter == nil || fMap == nil {
		return []employer.Employer{}, nil
	}
	var newList []employer.Employer
	for _, v := range list {
		r, err := fFilter(v)
		if err != nil {
			return nil, err
		}
		if r {
			r, err := fMap(v)
			if err != nil {
				return nil, err
			}
			newList = append(newList, r)
		}
	}
	return newList, nil
}

// MapIntEmployee takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list
func MapIntEmployee(f func(int) employee.Employee, list []int) []employee.Employee {
	if f == nil {
		return []employee.Employee{}
	}
	newList := make([]employee.Employee, len(list))
	for i, v := range list {
		newList[i] = f(v)
	}
	return newList
}

// MapIntEmployeeErr takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list and error
func MapIntEmployeeErr(f func(int) (employee.Employee, error), list []int) ([]employee.Employee, error) {
	if f == nil {
		return []employee.Employee{}, nil
	}
	newList := make([]employee.Employee, len(list))
	for i, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		newList[i] = r
	}
	return newList, nil
}

// MapIntEmployeePtr takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list
func MapIntEmployeePtr(f func(*int) *employee.Employee, list []*int) []*employee.Employee {
	if f == nil {
		return []*employee.Employee{}
	}
	newList := make([]*employee.Employee, len(list))
	for i, v := range list {
		newList[i] = f(v)
	}
	return newList
}

// MapIntEmployeePtrErr takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list, error
func MapIntEmployeePtrErr(f func(*int) (*employee.Employee, error), list []*int) ([]*employee.Employee, error) {
	if f == nil {
		return []*employee.Employee{}, nil
	}
	newList := make([]*employee.Employee, len(list))
	for i, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		newList[i] = r
	}
	return newList, nil
}

// PMapIntEmployee applies the function(1st argument) on each item in the list and returns a new list.
//  Order of new list is guaranteed. This feature can be disabled by passing: Optional{RandomOrder: true} to gain performance
//  Run in parallel. no_of_goroutines = no_of_items_in_list or 3rd argument can be passed to fix the number of goroutines.
//
// Takes 3 inputs. 3rd argument is optional
//  1. Function - takes 1 input
//  2. List
//  3. optional argument - fp.Optional{FixedPool: <some_number>}
func PMapIntEmployee(f func(int) employee.Employee, list []int, optional ...fp.Optional) []employee.Employee {
	if f == nil {
		return []employee.Employee{}
	}

	var worker = len(list)
	if optional != nil && len(optional) > 0 {
		if optional[0].FixedPool > 0 && optional[0].FixedPool < worker {
			worker = optional[0].FixedPool
		}

		if optional[0].RandomOrder == true {
			return pMapIntEmployeeNoOrder(f, list, worker)
		}
	}

	return pMapIntEmployeePreserveOrder(f, list, worker)
}

func pMapIntEmployeePreserveOrder(f func(int) employee.Employee, list []int, worker int) []employee.Employee {
	chJobs := make(chan map[int]int, len(list))
	go func() {
		for i, v := range list {
			chJobs <- map[int]int{i: v}
		}
		close(chJobs)
	}()

	chResult := make(chan map[int]employee.Employee, worker/3)

	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan map[int]employee.Employee, chJobs chan map[int]int) {
			defer wg.Done()

			for m := range chJobs {
				for k, v := range m {
					chResult <- map[int]employee.Employee{k: f(v)}
				}
			}
		}(chResult, chJobs)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newListMap := make(map[int]employee.Employee, len(list))
	newList := make([]employee.Employee, len(list))

	for m := range chResult {
		for k, v := range m {
			newListMap[k] = v
		}
	}

	for i := 0; i < len(list); i++ {
		newList[i] = newListMap[i]
	}

	return newList
}

func pMapIntEmployeeNoOrder(f func(int) employee.Employee, list []int, worker int) []employee.Employee {
	chJobs := make(chan int, len(list))
	go func() {
		for _, v := range list {
			chJobs <- v
		}
		close(chJobs)
	}()

	chResult := make(chan employee.Employee, worker/3)

	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan employee.Employee, chJobs chan int) {
			defer wg.Done()

			for v := range chJobs {
				chResult <- f(v)
			}
		}(chResult, chJobs)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newList := make([]employee.Employee, len(list))
	i := 0

	for v := range chResult {
		newList[i] = v
		i++
	}

	return newList
}

// PMapIntEmployeeErr applies the function(1st argument) on each item in the list and returns a new list and error.
//  Order of new list is guaranteed. This feature can be disabled by passing: Optional{RandomOrder: true} to gain performance
//  Run in parallel. no_of_goroutines = no_of_items_in_list or 3rd argument can be passed to fix the number of goroutines.
//
// Takes 3 inputs. 3rd argument is optional
//  1. Function - takes 1 input
//  2. List
//  3. optional argument - fp.Optional{FixedPool: <some_number>}
func PMapIntEmployeeErr(f func(int) (employee.Employee, error), list []int, optional ...fp.Optional) ([]employee.Employee, error) {
	if f == nil {
		return []employee.Employee{}, nil
	}

	var worker = len(list)
	if optional != nil && len(optional) > 0 {
		if optional[0].FixedPool > 0 && optional[0].FixedPool < worker {
			worker = optional[0].FixedPool
		}

		if optional[0].RandomOrder == true {
			return pMapIntEmployeeErrNoOrder(f, list, worker)
		}
	}

	return pMapIntEmployeeErrPreserveOrder(f, list, worker)
}

func pMapIntEmployeeErrPreserveOrder(f func(int) (employee.Employee, error), list []int, worker int) ([]employee.Employee, error) {
	chJobs := make(chan map[int]int, len(list))
	go func() {
		for i, v := range list {
			chJobs <- map[int]int{i: v}
		}
		close(chJobs)
	}()

	chResult := make(chan map[int]employee.Employee, worker/3)

	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan map[int]employee.Employee, chJobs chan map[int]int, errCh chan error) {
			defer wg.Done()
			if len(errCh) > 0 {
				return
			}
			for m := range chJobs {
				for k, v := range m {
					r, err := f(v)
					if err != nil {
						errCh <- err
						return
					}
					chResult <- map[int]employee.Employee{k: r}
				}
			}
		}(chResult, chJobs, errCh)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newListMap := make(map[int]employee.Employee, len(list))
	newList := make([]employee.Employee, len(list))

	for m := range chResult {
		select {
		case err := <-errCh:
			return []employee.Employee{}, err
		default:
		}
		for k, v := range m {
			newListMap[k] = v
		}
	}

	if len(errCh) > 0 {
		return []employee.Employee{}, <-errCh
	}

	for i := 0; i < len(list); i++ {
		newList[i] = newListMap[i]
	}

	return newList, nil
}

func pMapIntEmployeeErrNoOrder(f func(int) (employee.Employee, error), list []int, worker int) ([]employee.Employee, error) {
	chJobs := make(chan int, len(list))
	go func() {
		for _, v := range list {
			chJobs <- v
		}
		close(chJobs)
	}()

	chResult := make(chan employee.Employee, worker/3)

	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan employee.Employee, chJobs chan int, errCh chan error) {
			defer wg.Done()
			if len(errCh) > 0 {
				return
			}
			for v := range chJobs {
				r, err := f(v)
				if err != nil {
					errCh <- err
					return
				}
				chResult <- r
			}
		}(chResult, chJobs, errCh)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newList := make([]employee.Employee, len(list))
	i := 0

	for v := range chResult {
		select {
		case err := <-errCh:
			return []employee.Employee{}, err
		default:
		}
		newList[i] = v
		i++
	}

	if len(errCh) > 0 {
		return []employee.Employee{}, <-errCh
	}

	return newList, nil
}

// PMapIntEmployeePtr applies the function(1st argument) on each item in the list and returns a new list.
//  Order of new list is guaranteed. This feature can be disabled by passing: Optional{RandomOrder: true} to gain performance
//  Run in parallel. no_of_goroutines = no_of_items_in_list or 3rd argument can be passed to fix the number of goroutines.
//
// Takes 3 inputs. 3rd argument is optional
//  1. Function - takes 1 input
//  2. List
//  3. optional argument - fp.Optional{FixedPool: <some_number>}
func PMapIntEmployeePtr(f func(*int) *employee.Employee, list []*int, optional ...fp.Optional) []*employee.Employee {
	if f == nil {
		return []*employee.Employee{}
	}

	var worker = len(list)
	if optional != nil && len(optional) > 0 {
		if optional[0].FixedPool > 0 && optional[0].FixedPool < worker {
			worker = optional[0].FixedPool
		}

		if optional[0].RandomOrder == true {
			return pMapIntEmployeePtrNoOrder(f, list, worker)
		}
	}

	return pMapIntEmployeePtrPreserveOrder(f, list, worker)
}

func pMapIntEmployeePtrPreserveOrder(f func(*int) *employee.Employee, list []*int, worker int) []*employee.Employee {
	chJobs := make(chan map[int]*int, len(list))
	go func() {
		for i, v := range list {
			chJobs <- map[int]*int{i: v}
		}
		close(chJobs)
	}()

	chResult := make(chan map[int]*employee.Employee, worker/3)

	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan map[int]*employee.Employee, chJobs chan map[int]*int) {
			defer wg.Done()

			for m := range chJobs {
				for k, v := range m {
					chResult <- map[int]*employee.Employee{k: f(v)}
				}
			}
		}(chResult, chJobs)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newListMap := make(map[int]*employee.Employee, len(list))
	newList := make([]*employee.Employee, len(list))

	for m := range chResult {
		for k, v := range m {
			newListMap[k] = v
		}
	}

	for i := 0; i < len(list); i++ {
		newList[i] = newListMap[i]
	}

	return newList
}

func pMapIntEmployeePtrNoOrder(f func(*int) *employee.Employee, list []*int, worker int) []*employee.Employee {
	chJobs := make(chan *int, len(list))
	go func() {
		for _, v := range list {
			chJobs <- v
		}
		close(chJobs)
	}()

	chResult := make(chan *employee.Employee, worker/3)

	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan *employee.Employee, chJobs chan *int) {
			defer wg.Done()

			for v := range chJobs {
				chResult <- f(v)
			}
		}(chResult, chJobs)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newList := make([]*employee.Employee, len(list))
	i := 0

	for v := range chResult {
		newList[i] = v
		i++
	}

	return newList
}

// PMapIntEmployeePtrErr applies the function(1st argument) on each item in the list and returns a new list and error.
//  Order of new list is guaranteed. This feature can be disabled by passing: Optional{RandomOrder: true} to gain performance
//  Run in parallel. no_of_goroutines = no_of_items_in_list or 3rd argument can be passed to fix the number of goroutines.
//
// Takes 3 inputs. 3rd argument is optional
//  1. Function - takes 1 input
//  2. List
//  3. optional argument - fp.Optional{FixedPool: <some_number>}
func PMapIntEmployeePtrErr(f func(*int) (*employee.Employee, error), list []*int, optional ...fp.Optional) ([]*employee.Employee, error) {
	if f == nil {
		return []*employee.Employee{}, nil
	}

	var worker = len(list)
	if optional != nil && len(optional) > 0 {
		if optional[0].FixedPool > 0 && optional[0].FixedPool < worker {
			worker = optional[0].FixedPool
		}

		if optional[0].RandomOrder == true {
			return pMapIntEmployeePtrErrNoOrder(f, list, worker)
		}
	}

	return pMapIntEmployeePtrErrPreserveOrder(f, list, worker)
}

func pMapIntEmployeePtrErrPreserveOrder(f func(*int) (*employee.Employee, error), list []*int, worker int) ([]*employee.Employee, error) {
	chJobs := make(chan map[int]*int, len(list))
	go func() {
		for i, v := range list {
			chJobs <- map[int]*int{i: v}
		}
		close(chJobs)
	}()

	chResult := make(chan map[int]*employee.Employee, worker/3)

	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan map[int]*employee.Employee, chJobs chan map[int]*int, errCh chan error) {
			defer wg.Done()
			if len(errCh) > 0 {
				return
			}
			for m := range chJobs {
				for k, v := range m {
					r, err := f(v)
					if err != nil {
						errCh <- err
						return
					}
					chResult <- map[int]*employee.Employee{k: r}
				}
			}
		}(chResult, chJobs, errCh)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newListMap := make(map[int]*employee.Employee, len(list))
	newList := make([]*employee.Employee, len(list))

	for m := range chResult {
		select {
		case err := <-errCh:
			return []*employee.Employee{}, err
		default:
		}
		for k, v := range m {
			newListMap[k] = v
		}
	}

	if len(errCh) > 0 {
		return []*employee.Employee{}, <-errCh
	}

	for i := 0; i < len(list); i++ {
		newList[i] = newListMap[i]
	}

	return newList, nil
}

func pMapIntEmployeePtrErrNoOrder(f func(*int) (*employee.Employee, error), list []*int, worker int) ([]*employee.Employee, error) {
	chJobs := make(chan *int, len(list))
	go func() {
		for _, v := range list {
			chJobs <- v
		}
		close(chJobs)
	}()

	chResult := make(chan *employee.Employee, worker/3)

	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan *employee.Employee, chJobs chan *int, errCh chan error) {
			defer wg.Done()
			if len(errCh) > 0 {
				return
			}
			for v := range chJobs {
				r, err := f(v)
				if err != nil {
					errCh <- err
					return
				}
				chResult <- r
			}
		}(chResult, chJobs, errCh)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newList := make([]*employee.Employee, len(list))
	i := 0

	for v := range chResult {
		select {
		case err := <-errCh:
			return []*employee.Employee{}, err
		default:
		}
		newList[i] = v
		i++
	}

	if len(errCh) > 0 {
		return []*employee.Employee{}, <-errCh
	}

	return newList, nil
}

// FilterMapIntEmployee filters given list, then apply function(2nd argument) on each item in the list and returns a new list
// Takes 3 inputs
//	1. Function: takes one input type - int and returns true/false.
//	2. Function: takes int as argument and returns employee.Employee
// 	3. List of type int
//
// Returns:
//	New List of type employee.Employee
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapIntEmployee(fFilter func(int) bool, fMap func(int) employee.Employee, list []int) []employee.Employee {
	if fFilter == nil || fMap == nil {
		return []employee.Employee{}
	}
	var newList []employee.Employee
	for _, v := range list {
		if fFilter(v) {
			newList = append(newList, fMap(v))
		}
	}
	return newList
}

// FilterMapIntEmployeePtrErr filters given list, then apply function(2nd argument) on each item in the list and returns a new list, error
// Takes 3 inputs
//	1. Function: takes one input type - *int and returns (bool, error).
//	2. Function: takes *int as argument and returns (*employee.Employee, error)
// 	3. List of type *int
//
// Returns:
//	New List of type *employee.Employee, error
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapIntEmployeePtrErr(fFilter func(*int) (bool, error), fMap func(*int) (*employee.Employee, error), list []*int) ([]*employee.Employee, error) {
	if fFilter == nil || fMap == nil {
		return []*employee.Employee{}, nil
	}
	var newList []*employee.Employee
	for _, v := range list {
		r, err := fFilter(v)
		if err != nil {
			return nil, err
		}
		if r {
			r, err := fMap(v)
			if err != nil {
				return nil, err
			}
			newList = append(newList, r)
		}
	}
	return newList, nil
}

// FilterMapIntEmployeeErr filters given list, then apply function(2nd argument) on each item in the list and returns a new list, error
// Takes 3 inputs
//	1. Function: takes one input type - int and returns (bool, error).
//	2. Function: takes int as argument and returns (employee.Employee, error)
// 	3. List of type int
//
// Returns:
//	New List of type employee.Employee, error
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapIntEmployeeErr(fFilter func(int) (bool, error), fMap func(int) (employee.Employee, error), list []int) ([]employee.Employee, error) {
	if fFilter == nil || fMap == nil {
		return []employee.Employee{}, nil
	}
	var newList []employee.Employee
	for _, v := range list {
		r, err := fFilter(v)
		if err != nil {
			return nil, err
		}
		if r {
			r, err := fMap(v)
			if err != nil {
				return nil, err
			}
			newList = append(newList, r)
		}
	}
	return newList, nil
}

