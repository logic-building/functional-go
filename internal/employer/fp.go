// Code generated by 'gofp'. DO NOT EDIT.
package employer
import "sync" 
import "github.com/logic-building/functional-go/internal/employee" 

func Map(f func(Employer) Employer, list []Employer) []Employer {
	if f == nil {
		return []Employer{}
	}
	newList := make([]Employer, len(list))
	for i, v := range list {
		newList[i] = f(v)
	}
	return newList
}

func MapPtr(f func(*Employer) *Employer, list []*Employer) []*Employer {
	if f == nil {
		return []*Employer{}
	}
	newList := make([]*Employer, len(list))
	for i, v := range list {
		newList[i] = f(v)
	}
	return newList
}

// MapPtrErr takes 2 arguments:
//  1. A function input argument: *Employer and return types (*Employer, error)
//  2. A list of type []*Employer

// Returns:
// 	([]*Employer, error)
func MapPtrErr(f func(*Employer) (*Employer, error), list []*Employer) ([]*Employer, error) {
	if f == nil {
		return []*Employer{}, nil
	}
	newList := make([]*Employer, len(list))
	for i, v := range list {
		var err error
		newList[i], err = f(v)
		if err != nil {
			return nil, err
		}
	}
	return newList, nil
}

// MapErr takes 2 arguments:
//  1. A function input argument: Employer and return types (Employer, error)
//  2. A list of type []Employer

// Returns:
// 	([]Employer, error)
func MapErr(f func(Employer) (Employer, error), list []Employer) ([]Employer, error) {
	if f == nil {
		return []Employer{}, nil
	}
	newList := make([]Employer, len(list))
	for i, v := range list {
		var err error
		newList[i], err = f(v)
		if err != nil {
			return nil, err
		}
	}
	return newList, nil
}

func Filter(f func(Employer) bool, list []Employer) []Employer {
	if f == nil {
		return []Employer{}
	}
	var newList []Employer
	for _, v := range list {
		if f(v) {
			newList = append(newList, v)
		}
	}
	return newList
}

func FilterPtr(f func(*Employer) bool, list []*Employer) []*Employer {
	if f == nil {
		return []*Employer{}
	}
	var newList []*Employer
	for _, v := range list {
		if f(v) {
			newList = append(newList, v)
		}
	}
	return newList
}

// FilterPtrErr takes two arguments
//  1. Funtion: takes 1 argument of type Employer and returns (bool, error)
//  2. slice of type []*Employer

// Returns: 
//  new filtered list and error
func FilterPtrErr(f func(*Employer) (bool, error), list []*Employer) ([]*Employer, error) {
	if f == nil {
		return []*Employer{}, nil
	}
	var newList []*Employer
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if r {
			newList = append(newList, v)
		}
	}
	return newList, nil
}

// FilterErr takes two arguments
//  1. Funtion: takes 1 argument of type Employer and returns (bool, error)
//  2. slice of type []Employer

// Returns: 
//  new filtered list and error
func FilterErr(f func(Employer) (bool, error), list []Employer) ([]Employer, error) {
	if f == nil {
		return []Employer{}, nil
	}
	var newList []Employer
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if r {
			newList = append(newList, v)
		}
	}
	return newList, nil
}

func Remove(f func(Employer) bool, list []Employer) []Employer {
	if f == nil {
		return []Employer{}
	}
	var newList []Employer
	for _, v := range list {
		if !f(v) {
			newList = append(newList, v)
		}
	}
	return newList
}

func RemovePtr(f func(*Employer) bool, list []*Employer) []*Employer {
	if f == nil {
		return []*Employer{}
	}
	var newList []*Employer
	for _, v := range list {
		if !f(v) {
			newList = append(newList, v)
		}
	}
	return newList
}

// RemovePtrErr removes the items from the given list based on supplied function and returns new list
//
// Takes 2 inputs:
//	1. Function: input type *Employer and return types(bool, error)
//	2. List of type: []*Employer
//
// Returns:
//	New list and error: ([]*Employer, error)
//	Empty list if both of arguments are nil or either one is nil.
func RemovePtrErr(f func(*Employer) (bool, error), list []*Employer) ([]*Employer, error) {
	if f == nil {
		return []*Employer{}, nil
	}
	var newList []*Employer
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if !r {
			newList = append(newList, v)
		}
	}
	return newList, nil
}

// RemoveErr removes the items from the given list based on supplied function and returns new list
//
// Takes 2 inputs:
//	1. Function: input type Employer and return types(bool, error)
//	2. List of type: []Employer
//
// Returns:
//	New list and error: ([]Employer, error)
//	Empty list if both of arguments are nil or either one is nil.
func RemoveErr(f func(Employer) (bool, error), list []Employer) ([]Employer, error) {
	if f == nil {
		return []Employer{}, nil
	}
	var newList []Employer
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if !r {
			newList = append(newList, v)
		}
	}
	return newList, nil
}

func Some(f func(Employer) bool, list []Employer) bool {
	if f == nil {
		return false
	}
	for _, v := range list {
		if f(v) {
			return true
		}
	}
	return false
}

func SomePtr(f func(*Employer) bool, list []*Employer) bool {
	if f == nil {
		return false
	}
	for _, v := range list {
		if f(v) {
			return true
		}
	}
	return false
}

// SomePtrErr finds item in the list based on supplied function.
//
// Takes 2 input:
//	1. Function
//	2. List
//
// Returns:
//	(bool,err).
//	True if condition satisfies, else false
func SomePtrErr(f func(*Employer) (bool, error), list []*Employer) (bool, error) {
	if f == nil {
		return false, nil
	}
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return false, err
		}
		if r {
			return true, nil
		}
	}
	return false, nil
}

// SomeErr finds item in the list based on supplied function.
//
// Takes 2 input:
//	1. Function
//	2. List
//
// Returns:
//	(bool,err).
//	True if condition satisfies, else false
func SomeErr(f func(Employer) (bool, error), list []Employer) (bool, error) {
	if f == nil {
		return false, nil
	}
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return false, err
		}
		if r {
			return true, nil
		}
	}
	return false, nil
}

func Every(f func(Employer) bool, list []Employer) bool {
	if f == nil || len(list) == 0 {
		return false
	}
	for _, v := range list {
		if !f(v) {
			return false
		}
	}
	return true
}

func EveryPtr(f func(*Employer) bool, list []*Employer) bool {
	if f == nil || len(list) == 0 {
		return false
	}
	for _, v := range list {
		if !f(v) {
			return false
		}
	}
	return true
}

// EveryPtrErr returns true if supplied function returns logical true for every item in the list

func EveryPtrErr(f func(*Employer) (bool, error), list []*Employer) (bool, error) {
	if f == nil || len(list) == 0 {
		return false, nil
	}
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return false, err
		}
		if !r {
			return false, nil
		}
	}
	return true, nil
}

// EveryErr returns true if supplied function returns logical true for every item in the list

func EveryErr(f func(Employer) (bool, error), list []Employer) (bool, error) {
	if f == nil || len(list) == 0 {
		return false, nil
	}
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return false, err
		}
		if !r {
			return false, nil
		}
	}
	return true, nil
}

func DropWhile(f func(Employer) bool, list []Employer) []Employer {
	if f == nil {
		return []Employer{}
	}
	var newList []Employer
	for i, v := range list {
		if !f(v) {
			listLen := len(list)
			newList = make([]Employer, listLen-i)
			j := 0
			for i < listLen {
				newList[j] = list[i]
				i++
				j++
			}
			return newList
		}
	}
	return newList
}

func DropWhilePtr(f func(*Employer) bool, list []*Employer) []*Employer {
	if f == nil {
		return []*Employer{}
	}
	var newList []*Employer
	for i, v := range list {
		if !f(v) {
			listLen := len(list)
			newList = make([]*Employer, listLen-i)
			j := 0
			for i < listLen {
				newList[j] = list[i]
				i++
				j++
			}
			return newList
		}
	}
	return newList
}

/// DropWhilePtrErr drops the items from the list as long as condition satisfies.
//
// Takes two inputs
//	1. Function: takes one input and returns (boolean, error)
//	2. list
//
// Returns:
// 	New List, error
//  Empty list if either one of arguments or both of them are nil

func DropWhilePtrErr(f func(*Employer) (bool, error), list []*Employer) ([]*Employer, error) {
	if f == nil {
		return []*Employer{}, nil
	}
	var newList []*Employer
	for i, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if !r {
			listLen := len(list)
			newList = make([]*Employer, listLen-i)
			j := 0
			for i < listLen {
				newList[j] = list[i]
				i++
				j++
			}
			return newList, nil
		}
	}
	return newList, nil
}

/// DropWhileErr drops the items from the list as long as condition satisfies.
//
// Takes two inputs
//	1. Function: takes one input and returns (boolean, error)
//	2. list
//
// Returns:
// 	New List, error
//  Empty list if either one of arguments or both of them are nil

func DropWhileErr(f func(Employer) (bool, error), list []Employer) ([]Employer, error) {
	if f == nil {
		return []Employer{}, nil
	}
	var newList []Employer
	for i, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if !r {
			listLen := len(list)
			newList = make([]Employer, listLen-i)
			j := 0
			for i < listLen {
				newList[j] = list[i]
				i++
				j++
			}
			return newList, nil
		}
	}
	return newList, nil
}

func TakeWhile(f func(Employer) bool, list []Employer) []Employer {
	if f == nil {
		return []Employer{}
	}
	var newList []Employer
	for _, v := range list {
		if !f(v) {
			return newList
		}
		newList = append(newList, v)
	}
	return newList
}

func TakeWhilePtr(f func(*Employer) bool, list []*Employer) []*Employer {
	if f == nil {
		return []*Employer{}
	}
	var newList []*Employer
	for _, v := range list {
		if !f(v) {
			return newList
		}
		newList = append(newList, v)
	}
	return newList
}

// TakeWhilePtrErr returns new list based on condition in the supplied function. It returns new list once condition fails.
//
// Takes 2 inputs:
//	1. Function - 1 input of type *Employer and returns ([]*Employer, error)
//	2. List
//
// Returns:
//	New List, error.
//	Empty list if all the parameters are nil or either of one parameter is nil
func TakeWhilePtrErr(f func(*Employer) (bool, error), list []*Employer) ([]*Employer, error) {
	if f == nil {
		return []*Employer{}, nil
	}
	var newList []*Employer
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if !r {
			return newList, nil
		}
		newList = append(newList, v)
	}
	return newList, nil
}

// TakeWhileErr returns new list based on condition in the supplied function. It returns new list once condition fails.
//
// Takes 2 inputs:
//	1. Function - 1 input of type Employer and returns ([]Employer, error)
//	2. List
//
// Returns:
//	New List, error.
//	Empty list if all the parameters are nil or either of one parameter is nil
func TakeWhileErr(f func(Employer) (bool, error), list []Employer) ([]Employer, error) {
	if f == nil {
		return []Employer{}, nil
	}
	var newList []Employer
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if !r {
			return newList, nil
		}
		newList = append(newList, v)
	}
	return newList, nil
}

func PMap(f func(Employer) Employer, list []Employer) []Employer {
	if f == nil {
		return []Employer{}
	}

	ch := make(chan map[int]Employer)
	var wg sync.WaitGroup

	for i, v := range list {
		wg.Add(1)

		go func(wg *sync.WaitGroup, ch chan map[int]Employer, i int, v Employer) {
			defer wg.Done()
			ch <- map[int]Employer{i: f(v)}
		}(&wg, ch, i, v)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	newList := make([]Employer, len(list))
	for m := range ch {
		for k, v := range m {
			newList[k] = v
		}
	}
	return newList
}

// PMapPtr applies the function(1st argument) on each item of the list and returns new list.
// Run in parallel. no_of_goroutines = no_of_items_in_list
func PMapPtr(f func(*Employer) *Employer, list []*Employer) []*Employer {
	if f == nil {
		return []*Employer{}
	}

	ch := make(chan map[int]*Employer)
	var wg sync.WaitGroup

	for i, v := range list {
		wg.Add(1)

		go func(wg *sync.WaitGroup, ch chan map[int]*Employer, i int, v *Employer) {
			defer wg.Done()
			ch <- map[int]*Employer{i: f(v)}
		}(&wg, ch, i, v)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	newList := make([]*Employer, len(list))
	for m := range ch {
		for k, v := range m {
			newList[k] = v
		}
	}
	return newList
}

// PMapPtrErr applies the function(1st argument) on each item of the list and returns new list.
// Run in parallel. no_of_goroutines = no_of_items_in_list
func PMapPtrErr(f func(*Employer) (*Employer, error), list []*Employer) ([]*Employer, error) {
	if f == nil {
		return []*Employer{}, nil
	}

	ch := make(chan map[int]*Employer, len(list))
	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i, v := range list {
		wg.Add(1)

		go func(wg *sync.WaitGroup, ch chan map[int]*Employer, i int, v *Employer) {
			defer wg.Done()
			if len(errCh) >= 1 {
				return
			}
			r, err := f(v)
			if err != nil {
				errCh <- err
				return
			}
			ch <- map[int]*Employer{i: r}
		}(&wg, ch, i, v)
	}

	wg.Wait()
	close(ch)
	close(errCh)

	for err := range errCh {
		if err != nil {
			return nil, err
		}
	}

	newList := make([]*Employer, len(list))
	for m := range ch {
		for k, v := range m {
			newList[k] = v
		}
	}
	return newList, nil
}

// PMapErr applies the function(1st argument) on each item of the list and returns new list.
// Run in parallel. no_of_goroutines = no_of_items_in_list
func PMapErr(f func(Employer) (Employer, error), list []Employer) ([]Employer, error) {
	if f == nil {
		return []Employer{}, nil
	}

	ch := make(chan map[int]Employer, len(list))
	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i, v := range list {
		wg.Add(1)

		go func(wg *sync.WaitGroup, ch chan map[int]Employer, i int, v Employer) {
			defer wg.Done()
			if len(errCh) >= 1 {
				return
			}
			r, err := f(v)
			if err != nil {
				errCh <- err
				return
			}
			ch <- map[int]Employer{i: r}
		}(&wg, ch, i, v)
	}

	wg.Wait()
	close(ch)
	close(errCh)

	for err := range errCh {
		if err != nil {
			return nil, err
		}
	}

	newList := make([]Employer, len(list))
	for m := range ch {
		for k, v := range m {
			newList[k] = v
		}
	}
	return newList, nil
}

func FilterMap(fFilter func(Employer) bool, fMap func(Employer) Employer, list []Employer) []Employer {
	if fFilter == nil || fMap == nil {
		return []Employer{}
	}
	var newList []Employer
	for _, v := range list {
		if fFilter(v) {
			newList = append(newList, fMap(v))
		}
	}
	return newList
}

func FilterMapPtr(fFilter func(*Employer) bool, fMap func(*Employer) *Employer, list []*Employer) []*Employer {
	if fFilter == nil || fMap == nil {
		return []*Employer{}
	}
	var newList []*Employer
	for _, v := range list {
		if fFilter(v) {
			newList = append(newList, fMap(v))
		}
	}
	return newList
}

// FilterMapPtrErr filters given list, then apply function(2nd argument) on each item in the list and returns a new list
// Takes 3 inputs
//	1. Function: takes one input(*Employer) and returns (bool, error).
//	2. Function: takes *Employer as argument and returns (*Employer, error)
// 	3. Slice of type []*Employer
//
// Returns:
//	New List ([]*Employer, error).
//  Empty list if all there parameters are nil or either of parameter is nil
//
func FilterMapPtrErr(fFilter func(*Employer) (bool, error), fMap func(*Employer) (*Employer, error), list []*Employer) ([]*Employer, error) {
	if fFilter == nil || fMap == nil {
		return []*Employer{}, nil
	}
	var newList []*Employer
	for _, v := range list {
		r, err := fFilter(v)
		if err != nil {
			return nil, err
		}
		if r {
			r, err := fMap(v)
			if err != nil {
				return nil, err
			}
			newList = append(newList, r)
		}
	}
	return newList, nil
}

// FilterMapErr filters given list, then apply function(2nd argument) on each item in the list and returns a new list
// Takes 3 inputs
//	1. Function: takes one input(Employer) and returns (bool, error).
//	2. Function: takes Employer as argument and returns (Employer, error)
// 	3. Slice of type []Employer
//
// Returns:
//	New List ([]Employer, error).
//  Empty list if all there parameters are nil or either of parameter is nil
//
func FilterMapErr(fFilter func(Employer) (bool, error), fMap func(Employer) (Employer, error), list []Employer) ([]Employer, error) {
	if fFilter == nil || fMap == nil {
		return []Employer{}, nil
	}
	var newList []Employer
	for _, v := range list {
		r, err := fFilter(v)
		if err != nil {
			return nil, err
		}
		if r {
			r, err := fMap(v)
			if err != nil {
				return nil, err
			}
			newList = append(newList, r)
		}
	}
	return newList, nil
}

func Rest(l []Employer) []Employer {
	if l == nil {
		return []Employer{}
	}

	len := len(l)
	if len == 0 || len == 1 {
		return []Employer{}
	}

	newList := make([]Employer, len-1)

	for i, v := range l[1:] {
		newList[i] = v
	}

	return newList
}


// Rest removes 1st item of the list and return new list having rest of the items
func RestPtr(l []*Employer) []*Employer {
	if l == nil {
		return []*Employer{}
	}

	len := len(l)
	if len == 0 || len == 1 {
		return []*Employer{}
	}

	newList := make([]*Employer, len-1)

	for i, v := range l[1:] {
		newList[i] = v
	}

	return newList
}

func Reduce(f func(Employer, Employer) Employer, list []Employer, initializer ...Employer) Employer {
	var init Employer 
	lenList := len(list)

	if initializer != nil {
		init = initializer[0]
	} else if lenList > 0 {
		init = list[0]
		if lenList == 1 {
			return list[0]
		}
		if lenList >= 2 {
			list = list[1:]
		}
	}
	
	if lenList == 0 {
		return init
	}
	r := f(init, list[0])
	return Reduce(f, list[1:], r)
}

func ReducePtr(f func(*Employer, *Employer) *Employer, list []*Employer, initializer ...Employer) *Employer {
	var initVal Employer
	var init *Employer = &initVal
	lenList := len(list)

	if initializer != nil {
		init = &initializer[0]
	} else if lenList > 0 {
		init = list[0]
		if lenList == 1 {
			return list[0]
		}
		if lenList >= 2 {
			list = list[1:]
		}
	}

	if lenList == 0 {
		return init
	}

	r := f(init, list[0])
	return ReducePtr(f, list[1:], *r)
}

// ReducePtrErr reduces a list to a single value by combining elements via a supplied function
//
// Takes three inputs
//	A. function - takes two arguments (*Employer, *Employer)
//	B. list of type []*Employer
// 	C. initializer (optional of type Employer)
//
// Returns:
//	single value, error: (*Employer, error)

func ReducePtrErr(f func(*Employer, *Employer) (*Employer, error), list []*Employer, initializer ...Employer) (*Employer, error) {
	var initVal Employer
	var init *Employer = &initVal
	lenList := len(list)

	if initializer != nil {
		init = &initializer[0]
	} else if lenList > 0 {
		init = list[0]
		if lenList == 1 {
			return list[0], nil
		}
		if lenList >= 2 {
			list = list[1:]
		}
	}

	if lenList == 0 {
		return init, nil
	}

	r, err := f(init, list[0])
	if err != nil {
		return nil, err
	}
	return ReducePtrErr(f, list[1:], *r)
}

// ReduceErr reduces a list to a single value by combining elements via a supplied function
//
// Takes three inputs
//	A. function - takes two arguments (Employer, Employer)
//	B. list of type []Employer
// 	C. initializer (optional of type Employer)
//
// Returns:
//	single value, error: (Employer, error)

func ReduceErr(f func(Employer, Employer) (Employer, error), list []Employer, initializer ...Employer) (Employer, error) {
	var initVal Employer
	var init Employer = initVal
	lenList := len(list)

	if initializer != nil {
		init = initializer[0]
	} else if lenList > 0 {
		init = list[0]
		if lenList == 1 {
			return list[0], nil
		}
		if lenList >= 2 {
			list = list[1:]
		}
	}

	if lenList == 0 {
		return init, nil
	}

	r, err := f(init, list[0])
	if err != nil {
		return r, err
	}
	return ReduceErr(f, list[1:], r)
}

// DropLast drops last item from the list and returns new list.
// Returns empty list if there is only one item in the list or list empty
func DropLast(list []Employer) []Employer {
	listLen := len(list)

	if list == nil || listLen == 0 || listLen == 1 {
		return []Employer{}
	}

	newList := make([]Employer, listLen-1)

	for i := 0; i < listLen-1; i++ {
		newList[i] = list[i]
	}
	return newList
}

// DropLastPtr drops last item from the list and returns new list.
// Returns empty list if there is only one item in the list or list empty
func DropLastPtr(list []*Employer) []*Employer {
	listLen := len(list)

	if list == nil || listLen == 0 || listLen == 1 {
		return []*Employer{}
	}

	newList := make([]*Employer, listLen-1)

	for i := 0; i < listLen-1; i++ {
		newList[i] = list[i]
	}
	return newList
}

func MapEmployee(f func(employee.Employee) employee.Employee, list []employee.Employee) []employee.Employee {
	if f == nil {
		return []employee.Employee{}
	}
	newList := make([]employee.Employee, len(list))
	for i, v := range list {
		newList[i] = f(v)
	}
	return newList
}

func MapEmployeePtr(f func(*employee.Employee) *employee.Employee, list []*employee.Employee) []*employee.Employee {
	if f == nil {
		return []*employee.Employee{}
	}
	newList := make([]*employee.Employee, len(list))
	for i, v := range list {
		newList[i] = f(v)
	}
	return newList
}

// MapEmployeePtrErr takes 2 arguments:
//  1. A function input argument: *employee.Employee and return types (*employee.Employee, error)
//  2. A list of type []*employee.Employee

// Returns:
// 	([]*employee.Employee, error)
func MapEmployeePtrErr(f func(*employee.Employee) (*employee.Employee, error), list []*employee.Employee) ([]*employee.Employee, error) {
	if f == nil {
		return []*employee.Employee{}, nil
	}
	newList := make([]*employee.Employee, len(list))
	for i, v := range list {
		var err error
		newList[i], err = f(v)
		if err != nil {
			return nil, err
		}
	}
	return newList, nil
}

// MapEmployeeErr takes 2 arguments:
//  1. A function input argument: employee.Employee and return types (employee.Employee, error)
//  2. A list of type []employee.Employee

// Returns:
// 	([]employee.Employee, error)
func MapEmployeeErr(f func(employee.Employee) (employee.Employee, error), list []employee.Employee) ([]employee.Employee, error) {
	if f == nil {
		return []employee.Employee{}, nil
	}
	newList := make([]employee.Employee, len(list))
	for i, v := range list {
		var err error
		newList[i], err = f(v)
		if err != nil {
			return nil, err
		}
	}
	return newList, nil
}

func FilterEmployee(f func(employee.Employee) bool, list []employee.Employee) []employee.Employee {
	if f == nil {
		return []employee.Employee{}
	}
	var newList []employee.Employee
	for _, v := range list {
		if f(v) {
			newList = append(newList, v)
		}
	}
	return newList
}

func FilterEmployeePtr(f func(*employee.Employee) bool, list []*employee.Employee) []*employee.Employee {
	if f == nil {
		return []*employee.Employee{}
	}
	var newList []*employee.Employee
	for _, v := range list {
		if f(v) {
			newList = append(newList, v)
		}
	}
	return newList
}

// FilterEmployeePtrErr takes two arguments
//  1. Funtion: takes 1 argument of type employee.Employee and returns (bool, error)
//  2. slice of type []*employee.Employee

// Returns: 
//  new filtered list and error
func FilterEmployeePtrErr(f func(*employee.Employee) (bool, error), list []*employee.Employee) ([]*employee.Employee, error) {
	if f == nil {
		return []*employee.Employee{}, nil
	}
	var newList []*employee.Employee
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if r {
			newList = append(newList, v)
		}
	}
	return newList, nil
}

// FilterEmployeeErr takes two arguments
//  1. Funtion: takes 1 argument of type employee.Employee and returns (bool, error)
//  2. slice of type []employee.Employee

// Returns: 
//  new filtered list and error
func FilterEmployeeErr(f func(employee.Employee) (bool, error), list []employee.Employee) ([]employee.Employee, error) {
	if f == nil {
		return []employee.Employee{}, nil
	}
	var newList []employee.Employee
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if r {
			newList = append(newList, v)
		}
	}
	return newList, nil
}

func RemoveEmployee(f func(employee.Employee) bool, list []employee.Employee) []employee.Employee {
	if f == nil {
		return []employee.Employee{}
	}
	var newList []employee.Employee
	for _, v := range list {
		if !f(v) {
			newList = append(newList, v)
		}
	}
	return newList
}

func RemoveEmployeePtr(f func(*employee.Employee) bool, list []*employee.Employee) []*employee.Employee {
	if f == nil {
		return []*employee.Employee{}
	}
	var newList []*employee.Employee
	for _, v := range list {
		if !f(v) {
			newList = append(newList, v)
		}
	}
	return newList
}

// RemoveEmployeePtrErr removes the items from the given list based on supplied function and returns new list
//
// Takes 2 inputs:
//	1. Function: input type *employee.Employee and return types(bool, error)
//	2. List of type: []*employee.Employee
//
// Returns:
//	New list and error: ([]*employee.Employee, error)
//	Empty list if both of arguments are nil or either one is nil.
func RemoveEmployeePtrErr(f func(*employee.Employee) (bool, error), list []*employee.Employee) ([]*employee.Employee, error) {
	if f == nil {
		return []*employee.Employee{}, nil
	}
	var newList []*employee.Employee
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if !r {
			newList = append(newList, v)
		}
	}
	return newList, nil
}

// RemoveEmployeeErr removes the items from the given list based on supplied function and returns new list
//
// Takes 2 inputs:
//	1. Function: input type employee.Employee and return types(bool, error)
//	2. List of type: []employee.Employee
//
// Returns:
//	New list and error: ([]employee.Employee, error)
//	Empty list if both of arguments are nil or either one is nil.
func RemoveEmployeeErr(f func(employee.Employee) (bool, error), list []employee.Employee) ([]employee.Employee, error) {
	if f == nil {
		return []employee.Employee{}, nil
	}
	var newList []employee.Employee
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if !r {
			newList = append(newList, v)
		}
	}
	return newList, nil
}

func SomeEmployee(f func(employee.Employee) bool, list []employee.Employee) bool {
	if f == nil {
		return false
	}
	for _, v := range list {
		if f(v) {
			return true
		}
	}
	return false
}

func SomeEmployeePtr(f func(*employee.Employee) bool, list []*employee.Employee) bool {
	if f == nil {
		return false
	}
	for _, v := range list {
		if f(v) {
			return true
		}
	}
	return false
}

// SomeEmployeePtrErr finds item in the list based on supplied function.
//
// Takes 2 input:
//	1. Function
//	2. List
//
// Returns:
//	(bool,err).
//	True if condition satisfies, else false
func SomeEmployeePtrErr(f func(*employee.Employee) (bool, error), list []*employee.Employee) (bool, error) {
	if f == nil {
		return false, nil
	}
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return false, err
		}
		if r {
			return true, nil
		}
	}
	return false, nil
}

// SomeEmployeeErr finds item in the list based on supplied function.
//
// Takes 2 input:
//	1. Function
//	2. List
//
// Returns:
//	(bool,err).
//	True if condition satisfies, else false
func SomeEmployeeErr(f func(employee.Employee) (bool, error), list []employee.Employee) (bool, error) {
	if f == nil {
		return false, nil
	}
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return false, err
		}
		if r {
			return true, nil
		}
	}
	return false, nil
}

func EveryEmployee(f func(employee.Employee) bool, list []employee.Employee) bool {
	if f == nil || len(list) == 0 {
		return false
	}
	for _, v := range list {
		if !f(v) {
			return false
		}
	}
	return true
}

func EveryEmployeePtr(f func(*employee.Employee) bool, list []*employee.Employee) bool {
	if f == nil || len(list) == 0 {
		return false
	}
	for _, v := range list {
		if !f(v) {
			return false
		}
	}
	return true
}

// EveryEmployeePtrErr returns true if supplied function returns logical true for every item in the list

func EveryEmployeePtrErr(f func(*employee.Employee) (bool, error), list []*employee.Employee) (bool, error) {
	if f == nil || len(list) == 0 {
		return false, nil
	}
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return false, err
		}
		if !r {
			return false, nil
		}
	}
	return true, nil
}

// EveryEmployeeErr returns true if supplied function returns logical true for every item in the list

func EveryEmployeeErr(f func(employee.Employee) (bool, error), list []employee.Employee) (bool, error) {
	if f == nil || len(list) == 0 {
		return false, nil
	}
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return false, err
		}
		if !r {
			return false, nil
		}
	}
	return true, nil
}

func DropWhileEmployee(f func(employee.Employee) bool, list []employee.Employee) []employee.Employee {
	if f == nil {
		return []employee.Employee{}
	}
	var newList []employee.Employee
	for i, v := range list {
		if !f(v) {
			listLen := len(list)
			newList = make([]employee.Employee, listLen-i)
			j := 0
			for i < listLen {
				newList[j] = list[i]
				i++
				j++
			}
			return newList
		}
	}
	return newList
}

func DropWhileEmployeePtr(f func(*employee.Employee) bool, list []*employee.Employee) []*employee.Employee {
	if f == nil {
		return []*employee.Employee{}
	}
	var newList []*employee.Employee
	for i, v := range list {
		if !f(v) {
			listLen := len(list)
			newList = make([]*employee.Employee, listLen-i)
			j := 0
			for i < listLen {
				newList[j] = list[i]
				i++
				j++
			}
			return newList
		}
	}
	return newList
}

/// DropWhileEmployeePtrErr drops the items from the list as long as condition satisfies.
//
// Takes two inputs
//	1. Function: takes one input and returns (boolean, error)
//	2. list
//
// Returns:
// 	New List, error
//  Empty list if either one of arguments or both of them are nil

func DropWhileEmployeePtrErr(f func(*employee.Employee) (bool, error), list []*employee.Employee) ([]*employee.Employee, error) {
	if f == nil {
		return []*employee.Employee{}, nil
	}
	var newList []*employee.Employee
	for i, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if !r {
			listLen := len(list)
			newList = make([]*employee.Employee, listLen-i)
			j := 0
			for i < listLen {
				newList[j] = list[i]
				i++
				j++
			}
			return newList, nil
		}
	}
	return newList, nil
}

/// DropWhileEmployeeErr drops the items from the list as long as condition satisfies.
//
// Takes two inputs
//	1. Function: takes one input and returns (boolean, error)
//	2. list
//
// Returns:
// 	New List, error
//  Empty list if either one of arguments or both of them are nil

func DropWhileEmployeeErr(f func(employee.Employee) (bool, error), list []employee.Employee) ([]employee.Employee, error) {
	if f == nil {
		return []employee.Employee{}, nil
	}
	var newList []employee.Employee
	for i, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if !r {
			listLen := len(list)
			newList = make([]employee.Employee, listLen-i)
			j := 0
			for i < listLen {
				newList[j] = list[i]
				i++
				j++
			}
			return newList, nil
		}
	}
	return newList, nil
}

func TakeWhileEmployee(f func(employee.Employee) bool, list []employee.Employee) []employee.Employee {
	if f == nil {
		return []employee.Employee{}
	}
	var newList []employee.Employee
	for _, v := range list {
		if !f(v) {
			return newList
		}
		newList = append(newList, v)
	}
	return newList
}

func TakeWhileEmployeePtr(f func(*employee.Employee) bool, list []*employee.Employee) []*employee.Employee {
	if f == nil {
		return []*employee.Employee{}
	}
	var newList []*employee.Employee
	for _, v := range list {
		if !f(v) {
			return newList
		}
		newList = append(newList, v)
	}
	return newList
}

// TakeWhileEmployeePtrErr returns new list based on condition in the supplied function. It returns new list once condition fails.
//
// Takes 2 inputs:
//	1. Function - 1 input of type *employee.Employee and returns ([]*employee.Employee, error)
//	2. List
//
// Returns:
//	New List, error.
//	Empty list if all the parameters are nil or either of one parameter is nil
func TakeWhileEmployeePtrErr(f func(*employee.Employee) (bool, error), list []*employee.Employee) ([]*employee.Employee, error) {
	if f == nil {
		return []*employee.Employee{}, nil
	}
	var newList []*employee.Employee
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if !r {
			return newList, nil
		}
		newList = append(newList, v)
	}
	return newList, nil
}

// TakeWhileEmployeeErr returns new list based on condition in the supplied function. It returns new list once condition fails.
//
// Takes 2 inputs:
//	1. Function - 1 input of type employee.Employee and returns ([]employee.Employee, error)
//	2. List
//
// Returns:
//	New List, error.
//	Empty list if all the parameters are nil or either of one parameter is nil
func TakeWhileEmployeeErr(f func(employee.Employee) (bool, error), list []employee.Employee) ([]employee.Employee, error) {
	if f == nil {
		return []employee.Employee{}, nil
	}
	var newList []employee.Employee
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if !r {
			return newList, nil
		}
		newList = append(newList, v)
	}
	return newList, nil
}

func PMapEmployee(f func(employee.Employee) employee.Employee, list []employee.Employee) []employee.Employee {
	if f == nil {
		return []employee.Employee{}
	}

	ch := make(chan map[int]employee.Employee)
	var wg sync.WaitGroup

	for i, v := range list {
		wg.Add(1)

		go func(wg *sync.WaitGroup, ch chan map[int]employee.Employee, i int, v employee.Employee) {
			defer wg.Done()
			ch <- map[int]employee.Employee{i: f(v)}
		}(&wg, ch, i, v)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	newList := make([]employee.Employee, len(list))
	for m := range ch {
		for k, v := range m {
			newList[k] = v
		}
	}
	return newList
}

// PMapEmployeePtr applies the function(1st argument) on each item of the list and returns new list.
// Run in parallel. no_of_goroutines = no_of_items_in_list
func PMapEmployeePtr(f func(*employee.Employee) *employee.Employee, list []*employee.Employee) []*employee.Employee {
	if f == nil {
		return []*employee.Employee{}
	}

	ch := make(chan map[int]*employee.Employee)
	var wg sync.WaitGroup

	for i, v := range list {
		wg.Add(1)

		go func(wg *sync.WaitGroup, ch chan map[int]*employee.Employee, i int, v *employee.Employee) {
			defer wg.Done()
			ch <- map[int]*employee.Employee{i: f(v)}
		}(&wg, ch, i, v)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	newList := make([]*employee.Employee, len(list))
	for m := range ch {
		for k, v := range m {
			newList[k] = v
		}
	}
	return newList
}

// PMapEmployeePtrErr applies the function(1st argument) on each item of the list and returns new list.
// Run in parallel. no_of_goroutines = no_of_items_in_list
func PMapEmployeePtrErr(f func(*employee.Employee) (*employee.Employee, error), list []*employee.Employee) ([]*employee.Employee, error) {
	if f == nil {
		return []*employee.Employee{}, nil
	}

	ch := make(chan map[int]*employee.Employee, len(list))
	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i, v := range list {
		wg.Add(1)

		go func(wg *sync.WaitGroup, ch chan map[int]*employee.Employee, i int, v *employee.Employee) {
			defer wg.Done()
			if len(errCh) >= 1 {
				return
			}
			r, err := f(v)
			if err != nil {
				errCh <- err
				return
			}
			ch <- map[int]*employee.Employee{i: r}
		}(&wg, ch, i, v)
	}

	wg.Wait()
	close(ch)
	close(errCh)

	for err := range errCh {
		if err != nil {
			return nil, err
		}
	}

	newList := make([]*employee.Employee, len(list))
	for m := range ch {
		for k, v := range m {
			newList[k] = v
		}
	}
	return newList, nil
}

// PMapEmployeeErr applies the function(1st argument) on each item of the list and returns new list.
// Run in parallel. no_of_goroutines = no_of_items_in_list
func PMapEmployeeErr(f func(employee.Employee) (employee.Employee, error), list []employee.Employee) ([]employee.Employee, error) {
	if f == nil {
		return []employee.Employee{}, nil
	}

	ch := make(chan map[int]employee.Employee, len(list))
	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i, v := range list {
		wg.Add(1)

		go func(wg *sync.WaitGroup, ch chan map[int]employee.Employee, i int, v employee.Employee) {
			defer wg.Done()
			if len(errCh) >= 1 {
				return
			}
			r, err := f(v)
			if err != nil {
				errCh <- err
				return
			}
			ch <- map[int]employee.Employee{i: r}
		}(&wg, ch, i, v)
	}

	wg.Wait()
	close(ch)
	close(errCh)

	for err := range errCh {
		if err != nil {
			return nil, err
		}
	}

	newList := make([]employee.Employee, len(list))
	for m := range ch {
		for k, v := range m {
			newList[k] = v
		}
	}
	return newList, nil
}

func FilterMapEmployee(fFilter func(employee.Employee) bool, fMap func(employee.Employee) employee.Employee, list []employee.Employee) []employee.Employee {
	if fFilter == nil || fMap == nil {
		return []employee.Employee{}
	}
	var newList []employee.Employee
	for _, v := range list {
		if fFilter(v) {
			newList = append(newList, fMap(v))
		}
	}
	return newList
}

func FilterMapEmployeePtr(fFilter func(*employee.Employee) bool, fMap func(*employee.Employee) *employee.Employee, list []*employee.Employee) []*employee.Employee {
	if fFilter == nil || fMap == nil {
		return []*employee.Employee{}
	}
	var newList []*employee.Employee
	for _, v := range list {
		if fFilter(v) {
			newList = append(newList, fMap(v))
		}
	}
	return newList
}

// FilterMapEmployeePtrErr filters given list, then apply function(2nd argument) on each item in the list and returns a new list
// Takes 3 inputs
//	1. Function: takes one input(*employee.Employee) and returns (bool, error).
//	2. Function: takes *employee.Employee as argument and returns (*employee.Employee, error)
// 	3. Slice of type []*employee.Employee
//
// Returns:
//	New List ([]*employee.Employee, error).
//  Empty list if all there parameters are nil or either of parameter is nil
//
func FilterMapEmployeePtrErr(fFilter func(*employee.Employee) (bool, error), fMap func(*employee.Employee) (*employee.Employee, error), list []*employee.Employee) ([]*employee.Employee, error) {
	if fFilter == nil || fMap == nil {
		return []*employee.Employee{}, nil
	}
	var newList []*employee.Employee
	for _, v := range list {
		r, err := fFilter(v)
		if err != nil {
			return nil, err
		}
		if r {
			r, err := fMap(v)
			if err != nil {
				return nil, err
			}
			newList = append(newList, r)
		}
	}
	return newList, nil
}

// FilterMapEmployeeErr filters given list, then apply function(2nd argument) on each item in the list and returns a new list
// Takes 3 inputs
//	1. Function: takes one input(employee.Employee) and returns (bool, error).
//	2. Function: takes employee.Employee as argument and returns (employee.Employee, error)
// 	3. Slice of type []employee.Employee
//
// Returns:
//	New List ([]employee.Employee, error).
//  Empty list if all there parameters are nil or either of parameter is nil
//
func FilterMapEmployeeErr(fFilter func(employee.Employee) (bool, error), fMap func(employee.Employee) (employee.Employee, error), list []employee.Employee) ([]employee.Employee, error) {
	if fFilter == nil || fMap == nil {
		return []employee.Employee{}, nil
	}
	var newList []employee.Employee
	for _, v := range list {
		r, err := fFilter(v)
		if err != nil {
			return nil, err
		}
		if r {
			r, err := fMap(v)
			if err != nil {
				return nil, err
			}
			newList = append(newList, r)
		}
	}
	return newList, nil
}

func RestEmployee(l []employee.Employee) []employee.Employee {
	if l == nil {
		return []employee.Employee{}
	}

	len := len(l)
	if len == 0 || len == 1 {
		return []employee.Employee{}
	}

	newList := make([]employee.Employee, len-1)

	for i, v := range l[1:] {
		newList[i] = v
	}

	return newList
}


// RestEmployee removes 1st item of the list and return new list having rest of the items
func RestEmployeePtr(l []*employee.Employee) []*employee.Employee {
	if l == nil {
		return []*employee.Employee{}
	}

	len := len(l)
	if len == 0 || len == 1 {
		return []*employee.Employee{}
	}

	newList := make([]*employee.Employee, len-1)

	for i, v := range l[1:] {
		newList[i] = v
	}

	return newList
}

func ReduceEmployee(f func(employee.Employee, employee.Employee) employee.Employee, list []employee.Employee, initializer ...employee.Employee) employee.Employee {
	var init employee.Employee 
	lenList := len(list)

	if initializer != nil {
		init = initializer[0]
	} else if lenList > 0 {
		init = list[0]
		if lenList == 1 {
			return list[0]
		}
		if lenList >= 2 {
			list = list[1:]
		}
	}
	
	if lenList == 0 {
		return init
	}
	r := f(init, list[0])
	return ReduceEmployee(f, list[1:], r)
}

func ReduceEmployeePtr(f func(*employee.Employee, *employee.Employee) *employee.Employee, list []*employee.Employee, initializer ...employee.Employee) *employee.Employee {
	var initVal employee.Employee
	var init *employee.Employee = &initVal
	lenList := len(list)

	if initializer != nil {
		init = &initializer[0]
	} else if lenList > 0 {
		init = list[0]
		if lenList == 1 {
			return list[0]
		}
		if lenList >= 2 {
			list = list[1:]
		}
	}

	if lenList == 0 {
		return init
	}

	r := f(init, list[0])
	return ReduceEmployeePtr(f, list[1:], *r)
}

// ReduceEmployeePtrErr reduces a list to a single value by combining elements via a supplied function
//
// Takes three inputs
//	A. function - takes two arguments (*employee.Employee, *employee.Employee)
//	B. list of type []*employee.Employee
// 	C. initializer (optional of type employee.Employee)
//
// Returns:
//	single value, error: (*employee.Employee, error)

func ReduceEmployeePtrErr(f func(*employee.Employee, *employee.Employee) (*employee.Employee, error), list []*employee.Employee, initializer ...employee.Employee) (*employee.Employee, error) {
	var initVal employee.Employee
	var init *employee.Employee = &initVal
	lenList := len(list)

	if initializer != nil {
		init = &initializer[0]
	} else if lenList > 0 {
		init = list[0]
		if lenList == 1 {
			return list[0], nil
		}
		if lenList >= 2 {
			list = list[1:]
		}
	}

	if lenList == 0 {
		return init, nil
	}

	r, err := f(init, list[0])
	if err != nil {
		return nil, err
	}
	return ReduceEmployeePtrErr(f, list[1:], *r)
}

// ReduceEmployeeErr reduces a list to a single value by combining elements via a supplied function
//
// Takes three inputs
//	A. function - takes two arguments (employee.Employee, employee.Employee)
//	B. list of type []employee.Employee
// 	C. initializer (optional of type employee.Employee)
//
// Returns:
//	single value, error: (employee.Employee, error)

func ReduceEmployeeErr(f func(employee.Employee, employee.Employee) (employee.Employee, error), list []employee.Employee, initializer ...employee.Employee) (employee.Employee, error) {
	var initVal employee.Employee
	var init employee.Employee = initVal
	lenList := len(list)

	if initializer != nil {
		init = initializer[0]
	} else if lenList > 0 {
		init = list[0]
		if lenList == 1 {
			return list[0], nil
		}
		if lenList >= 2 {
			list = list[1:]
		}
	}

	if lenList == 0 {
		return init, nil
	}

	r, err := f(init, list[0])
	if err != nil {
		return r, err
	}
	return ReduceEmployeeErr(f, list[1:], r)
}

// DropLastEmployee drops last item from the list and returns new list.
// Returns empty list if there is only one item in the list or list empty
func DropLastEmployee(list []employee.Employee) []employee.Employee {
	listLen := len(list)

	if list == nil || listLen == 0 || listLen == 1 {
		return []employee.Employee{}
	}

	newList := make([]employee.Employee, listLen-1)

	for i := 0; i < listLen-1; i++ {
		newList[i] = list[i]
	}
	return newList
}

// DropLastEmployeePtr drops last item from the list and returns new list.
// Returns empty list if there is only one item in the list or list empty
func DropLastEmployeePtr(list []*employee.Employee) []*employee.Employee {
	listLen := len(list)

	if list == nil || listLen == 0 || listLen == 1 {
		return []*employee.Employee{}
	}

	newList := make([]*employee.Employee, listLen-1)

	for i := 0; i < listLen-1; i++ {
		newList[i] = list[i]
	}
	return newList
}


// MapEmployerEmployee takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list
func MapEmployerEmployee(f func(Employer) employee.Employee, list []Employer) []employee.Employee {
	if f == nil {
		return []employee.Employee{}
	}
	newList := make([]employee.Employee, len(list))
	for i, v := range list {
		newList[i] = f(v)
	}
	return newList
}

// MapEmployerEmployee takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list and error
func MapEmployerEmployeeErr(f func(Employer) (employee.Employee, error), list []Employer) ([]employee.Employee, error) {
	if f == nil {
		return []employee.Employee{}, nil
	}
	newList := make([]employee.Employee, len(list))
	for i, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		newList[i] = r
	}
	return newList, nil
}

// MapEmployerEmployee takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list
func MapEmployerEmployeePtr(f func(*Employer) *employee.Employee, list []*Employer) []*employee.Employee {
	if f == nil {
		return []*employee.Employee{}
	}
	newList := make([]*employee.Employee, len(list))
	for i, v := range list {
		newList[i] = f(v)
	}
	return newList
}

// MapEmployerEmployeePtrErr takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list, error
func MapEmployerEmployeePtrErr(f func(*Employer) (*employee.Employee, error), list []*Employer) ([]*employee.Employee, error) {
	if f == nil {
		return []*employee.Employee{}, nil
	}
	newList := make([]*employee.Employee, len(list))
	for i, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		newList[i] = r
	}
	return newList, nil
}

// PMapEmployerEmployee applies the function(1st argument) on each item of the list and returns new list.
// Run in parallel. no_of_goroutines = no_of_items_in_list
//
// Takes 2 inputs
//	1. Function - takes 1 input type: Employer output type: employee.Employee
//	2. List
//
// Returns
//	New List of type employee.Employee
//	Empty list if all arguments are nil or either one is nil
func PMapEmployerEmployee(f func(Employer) employee.Employee, list []Employer) []employee.Employee {
	if f == nil {
		return []employee.Employee{}
	}

	ch := make(chan map[int]employee.Employee)
	var wg sync.WaitGroup

	for i, v := range list {
		wg.Add(1)

		go func(wg *sync.WaitGroup, ch chan map[int]employee.Employee, i int, v Employer) {
			defer wg.Done()
			ch <- map[int]employee.Employee{i: f(v)}
		}(&wg, ch, i, v)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	newList := make([]employee.Employee, len(list))
	for m := range ch {
		for k, v := range m {
			newList[k] = v
		}
	}
	return newList
}

// PMapEmployerEmployeeErr applies the function(1st argument) on each item of the list and returns new list and error.
// Run in parallel. no_of_goroutines = no_of_items_in_list
//
// Takes 2 inputs
//	1. Function - takes 1 input type: Employer output type: (employee.Employee, error)
//	2. List
//
// Returns
//	New List of type (employee.Employee, error)
//	Empty list if all arguments are nil or either one is nil
func PMapEmployerEmployeeErr(f func(Employer) (employee.Employee, error), list []Employer) ([]employee.Employee, error) {
	if f == nil {
		return []employee.Employee{}, nil
	}

	ch := make(chan map[int]employee.Employee, len(list))
	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i, v := range list {
		wg.Add(1)

		go func(wg *sync.WaitGroup, ch chan map[int]employee.Employee, i int, v Employer) {
			defer wg.Done()
			if len(errCh) >= 1 {
				return
			}
			r, err := f(v)
			if err != nil {
				errCh <- err
				return
			}
			ch <- map[int]employee.Employee{i: r}
		}(&wg, ch, i, v)
	}

	wg.Wait()
	close(ch)
	close(errCh)
	
	for err := range errCh {
		if err != nil {
			return nil, err
		}
	}

	newList := make([]employee.Employee, len(list))
	for m := range ch {
		for k, v := range m {
			newList[k] = v
		}
	}
	return newList, nil
}

// PMapEmployerEmployeePtr applies the function(1st argument) on each item of the list and returns new list.
// Run in parallel. no_of_goroutines = no_of_items_in_list
//
// Takes 2 inputs
//	1. Function - takes 1 input type: *Employer output type: *employee.Employee
//	2. List
//
// Returns
//	New List of type *employee.Employee
//	Empty list if all arguments are nil or either one is nil
func PMapEmployerEmployeePtr(f func(*Employer) *employee.Employee, list []*Employer) []*employee.Employee {
	if f == nil {
		return []*employee.Employee{}
	}

	ch := make(chan map[int]*employee.Employee)
	var wg sync.WaitGroup

	for i, v := range list {
		wg.Add(1)

		go func(wg *sync.WaitGroup, ch chan map[int]*employee.Employee, i int, v *Employer) {
			defer wg.Done()
			ch <- map[int]*employee.Employee{i: f(v)}
		}(&wg, ch, i, v)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	newList := make([]*employee.Employee, len(list))
	for m := range ch {
		for k, v := range m {
			newList[k] = v
		}
	}
	return newList
}

// PMapEmployerEmployeePtrErr applies the function(1st argument) on each item of the list and returns new list and error.
// Run in parallel. no_of_goroutines = no_of_items_in_list
//
// Takes 2 inputs
//	1. Function - takes 1 input type: *Employer output type: (*employee.Employee, error)
//	2. List
//
// Returns
//	New List of type (*employee.Employee, error)
//	Empty list if all arguments are nil or either one is nil
func PMapEmployerEmployeePtrErr(f func(*Employer) (*employee.Employee, error), list []*Employer) ([]*employee.Employee, error) {
	if f == nil {
		return []*employee.Employee{}, nil
	}

	ch := make(chan map[int]*employee.Employee, len(list))
	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i, v := range list {
		wg.Add(1)

		go func(wg *sync.WaitGroup, ch chan map[int]*employee.Employee, i int, v *Employer) {
			defer wg.Done()
			if len(errCh) >= 1 {
				return
			}
			r, err := f(v)
			if err != nil {
				errCh <- err
				return
			}
			ch <- map[int]*employee.Employee{i: r}
		}(&wg, ch, i, v)
	}

	wg.Wait()
	close(ch)
	close(errCh)
	
	for err := range errCh {
		if err != nil {
			return nil, err
		}
	}

	newList := make([]*employee.Employee, len(list))
	for m := range ch {
		for k, v := range m {
			newList[k] = v
		}
	}
	return newList, nil
}

// FilterMapEmployerEmployee filters given list, then apply function(2nd argument) on each item in the list and returns a new list
// Takes 3 inputs
//	1. Function: takes one input type - Employer and returns true/false.
//	2. Function: takes Employer as argument and returns employee.Employee
// 	3. List of type Employer
//
// Returns:
//	New List of type employee.Employee
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapEmployerEmployee(fFilter func(Employer) bool, fMap func(Employer) employee.Employee, list []Employer) []employee.Employee {
	if fFilter == nil || fMap == nil {
		return []employee.Employee{}
	}
	var newList []employee.Employee
	for _, v := range list {
		if fFilter(v) {
			newList = append(newList, fMap(v))
		}
	}
	return newList
}

// FilterMapEmployerEmployeePtrErr filters given list, then apply function(2nd argument) on each item in the list and returns a new list, error
// Takes 3 inputs
//	1. Function: takes one input type - *Employer and returns (bool, error).
//	2. Function: takes *Employer as argument and returns (*employee.Employee, error)
// 	3. List of type *Employer
//
// Returns:
//	New List of type *employee.Employee, error
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapEmployerEmployeePtrErr(fFilter func(*Employer) (bool, error), fMap func(*Employer) (*employee.Employee, error), list []*Employer) ([]*employee.Employee, error) {
	if fFilter == nil || fMap == nil {
		return []*employee.Employee{}, nil
	}
	var newList []*employee.Employee
	for _, v := range list {
		r, err := fFilter(v)
		if err != nil {
			return nil, err
		}
		if r {
			r, err := fMap(v)
			if err != nil {
				return nil, err
			}
			newList = append(newList, r)
		}
	}
	return newList, nil
}

// FilterMapEmployerEmployeeErr filters given list, then apply function(2nd argument) on each item in the list and returns a new list, error
// Takes 3 inputs
//	1. Function: takes one input type - Employer and returns (bool, error).
//	2. Function: takes Employer as argument and returns (employee.Employee, error)
// 	3. List of type Employer
//
// Returns:
//	New List of type employee.Employee, error
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapEmployerEmployeeErr(fFilter func(Employer) (bool, error), fMap func(Employer) (employee.Employee, error), list []Employer) ([]employee.Employee, error) {
	if fFilter == nil || fMap == nil {
		return []employee.Employee{}, nil
	}
	var newList []employee.Employee
	for _, v := range list {
		r, err := fFilter(v)
		if err != nil {
			return nil, err
		}
		if r {
			r, err := fMap(v)
			if err != nil {
				return nil, err
			}
			newList = append(newList, r)
		}
	}
	return newList, nil
}

// MapEmployerInt takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list
func MapEmployerInt(f func(Employer) int, list []Employer) []int {
	if f == nil {
		return []int{}
	}
	newList := make([]int, len(list))
	for i, v := range list {
		newList[i] = f(v)
	}
	return newList
}

// MapEmployerInt takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list and error
func MapEmployerIntErr(f func(Employer) (int, error), list []Employer) ([]int, error) {
	if f == nil {
		return []int{}, nil
	}
	newList := make([]int, len(list))
	for i, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		newList[i] = r
	}
	return newList, nil
}

// MapEmployerInt takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list
func MapEmployerIntPtr(f func(*Employer) *int, list []*Employer) []*int {
	if f == nil {
		return []*int{}
	}
	newList := make([]*int, len(list))
	for i, v := range list {
		newList[i] = f(v)
	}
	return newList
}

// MapEmployerIntPtrErr takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list, error
func MapEmployerIntPtrErr(f func(*Employer) (*int, error), list []*Employer) ([]*int, error) {
	if f == nil {
		return []*int{}, nil
	}
	newList := make([]*int, len(list))
	for i, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		newList[i] = r
	}
	return newList, nil
}

// PMapEmployerInt applies the function(1st argument) on each item of the list and returns new list.
// Run in parallel. no_of_goroutines = no_of_items_in_list
//
// Takes 2 inputs
//	1. Function - takes 1 input type: Employer output type: int
//	2. List
//
// Returns
//	New List of type int
//	Empty list if all arguments are nil or either one is nil
func PMapEmployerInt(f func(Employer) int, list []Employer) []int {
	if f == nil {
		return []int{}
	}

	ch := make(chan map[int]int)
	var wg sync.WaitGroup

	for i, v := range list {
		wg.Add(1)

		go func(wg *sync.WaitGroup, ch chan map[int]int, i int, v Employer) {
			defer wg.Done()
			ch <- map[int]int{i: f(v)}
		}(&wg, ch, i, v)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	newList := make([]int, len(list))
	for m := range ch {
		for k, v := range m {
			newList[k] = v
		}
	}
	return newList
}

// PMapEmployerIntErr applies the function(1st argument) on each item of the list and returns new list and error.
// Run in parallel. no_of_goroutines = no_of_items_in_list
//
// Takes 2 inputs
//	1. Function - takes 1 input type: Employer output type: (int, error)
//	2. List
//
// Returns
//	New List of type (int, error)
//	Empty list if all arguments are nil or either one is nil
func PMapEmployerIntErr(f func(Employer) (int, error), list []Employer) ([]int, error) {
	if f == nil {
		return []int{}, nil
	}

	ch := make(chan map[int]int, len(list))
	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i, v := range list {
		wg.Add(1)

		go func(wg *sync.WaitGroup, ch chan map[int]int, i int, v Employer) {
			defer wg.Done()
			if len(errCh) >= 1 {
				return
			}
			r, err := f(v)
			if err != nil {
				errCh <- err
				return
			}
			ch <- map[int]int{i: r}
		}(&wg, ch, i, v)
	}

	wg.Wait()
	close(ch)
	close(errCh)
	
	for err := range errCh {
		if err != nil {
			return nil, err
		}
	}

	newList := make([]int, len(list))
	for m := range ch {
		for k, v := range m {
			newList[k] = v
		}
	}
	return newList, nil
}

// PMapEmployerIntPtr applies the function(1st argument) on each item of the list and returns new list.
// Run in parallel. no_of_goroutines = no_of_items_in_list
//
// Takes 2 inputs
//	1. Function - takes 1 input type: *Employer output type: *int
//	2. List
//
// Returns
//	New List of type *int
//	Empty list if all arguments are nil or either one is nil
func PMapEmployerIntPtr(f func(*Employer) *int, list []*Employer) []*int {
	if f == nil {
		return []*int{}
	}

	ch := make(chan map[int]*int)
	var wg sync.WaitGroup

	for i, v := range list {
		wg.Add(1)

		go func(wg *sync.WaitGroup, ch chan map[int]*int, i int, v *Employer) {
			defer wg.Done()
			ch <- map[int]*int{i: f(v)}
		}(&wg, ch, i, v)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	newList := make([]*int, len(list))
	for m := range ch {
		for k, v := range m {
			newList[k] = v
		}
	}
	return newList
}

// PMapEmployerIntPtrErr applies the function(1st argument) on each item of the list and returns new list and error.
// Run in parallel. no_of_goroutines = no_of_items_in_list
//
// Takes 2 inputs
//	1. Function - takes 1 input type: *Employer output type: (*int, error)
//	2. List
//
// Returns
//	New List of type (*int, error)
//	Empty list if all arguments are nil or either one is nil
func PMapEmployerIntPtrErr(f func(*Employer) (*int, error), list []*Employer) ([]*int, error) {
	if f == nil {
		return []*int{}, nil
	}

	ch := make(chan map[int]*int, len(list))
	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i, v := range list {
		wg.Add(1)

		go func(wg *sync.WaitGroup, ch chan map[int]*int, i int, v *Employer) {
			defer wg.Done()
			if len(errCh) >= 1 {
				return
			}
			r, err := f(v)
			if err != nil {
				errCh <- err
				return
			}
			ch <- map[int]*int{i: r}
		}(&wg, ch, i, v)
	}

	wg.Wait()
	close(ch)
	close(errCh)
	
	for err := range errCh {
		if err != nil {
			return nil, err
		}
	}

	newList := make([]*int, len(list))
	for m := range ch {
		for k, v := range m {
			newList[k] = v
		}
	}
	return newList, nil
}

// FilterMapEmployerInt filters given list, then apply function(2nd argument) on each item in the list and returns a new list
// Takes 3 inputs
//	1. Function: takes one input type - Employer and returns true/false.
//	2. Function: takes Employer as argument and returns int
// 	3. List of type Employer
//
// Returns:
//	New List of type int
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapEmployerInt(fFilter func(Employer) bool, fMap func(Employer) int, list []Employer) []int {
	if fFilter == nil || fMap == nil {
		return []int{}
	}
	var newList []int
	for _, v := range list {
		if fFilter(v) {
			newList = append(newList, fMap(v))
		}
	}
	return newList
}

// FilterMapEmployerIntPtrErr filters given list, then apply function(2nd argument) on each item in the list and returns a new list, error
// Takes 3 inputs
//	1. Function: takes one input type - *Employer and returns (bool, error).
//	2. Function: takes *Employer as argument and returns (*int, error)
// 	3. List of type *Employer
//
// Returns:
//	New List of type *int, error
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapEmployerIntPtrErr(fFilter func(*Employer) (bool, error), fMap func(*Employer) (*int, error), list []*Employer) ([]*int, error) {
	if fFilter == nil || fMap == nil {
		return []*int{}, nil
	}
	var newList []*int
	for _, v := range list {
		r, err := fFilter(v)
		if err != nil {
			return nil, err
		}
		if r {
			r, err := fMap(v)
			if err != nil {
				return nil, err
			}
			newList = append(newList, r)
		}
	}
	return newList, nil
}

// FilterMapEmployerIntErr filters given list, then apply function(2nd argument) on each item in the list and returns a new list, error
// Takes 3 inputs
//	1. Function: takes one input type - Employer and returns (bool, error).
//	2. Function: takes Employer as argument and returns (int, error)
// 	3. List of type Employer
//
// Returns:
//	New List of type int, error
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapEmployerIntErr(fFilter func(Employer) (bool, error), fMap func(Employer) (int, error), list []Employer) ([]int, error) {
	if fFilter == nil || fMap == nil {
		return []int{}, nil
	}
	var newList []int
	for _, v := range list {
		r, err := fFilter(v)
		if err != nil {
			return nil, err
		}
		if r {
			r, err := fMap(v)
			if err != nil {
				return nil, err
			}
			newList = append(newList, r)
		}
	}
	return newList, nil
}

// MapEmployeeEmployer takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list
func MapEmployeeEmployer(f func(employee.Employee) Employer, list []employee.Employee) []Employer {
	if f == nil {
		return []Employer{}
	}
	newList := make([]Employer, len(list))
	for i, v := range list {
		newList[i] = f(v)
	}
	return newList
}

// MapEmployeeEmployer takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list and error
func MapEmployeeEmployerErr(f func(employee.Employee) (Employer, error), list []employee.Employee) ([]Employer, error) {
	if f == nil {
		return []Employer{}, nil
	}
	newList := make([]Employer, len(list))
	for i, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		newList[i] = r
	}
	return newList, nil
}

// MapEmployeeEmployer takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list
func MapEmployeeEmployerPtr(f func(*employee.Employee) *Employer, list []*employee.Employee) []*Employer {
	if f == nil {
		return []*Employer{}
	}
	newList := make([]*Employer, len(list))
	for i, v := range list {
		newList[i] = f(v)
	}
	return newList
}

// MapEmployeeEmployerPtrErr takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list, error
func MapEmployeeEmployerPtrErr(f func(*employee.Employee) (*Employer, error), list []*employee.Employee) ([]*Employer, error) {
	if f == nil {
		return []*Employer{}, nil
	}
	newList := make([]*Employer, len(list))
	for i, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		newList[i] = r
	}
	return newList, nil
}

// PMapEmployeeEmployer applies the function(1st argument) on each item of the list and returns new list.
// Run in parallel. no_of_goroutines = no_of_items_in_list
//
// Takes 2 inputs
//	1. Function - takes 1 input type: employee.Employee output type: Employer
//	2. List
//
// Returns
//	New List of type Employer
//	Empty list if all arguments are nil or either one is nil
func PMapEmployeeEmployer(f func(employee.Employee) Employer, list []employee.Employee) []Employer {
	if f == nil {
		return []Employer{}
	}

	ch := make(chan map[int]Employer)
	var wg sync.WaitGroup

	for i, v := range list {
		wg.Add(1)

		go func(wg *sync.WaitGroup, ch chan map[int]Employer, i int, v employee.Employee) {
			defer wg.Done()
			ch <- map[int]Employer{i: f(v)}
		}(&wg, ch, i, v)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	newList := make([]Employer, len(list))
	for m := range ch {
		for k, v := range m {
			newList[k] = v
		}
	}
	return newList
}

// PMapEmployeeEmployerErr applies the function(1st argument) on each item of the list and returns new list and error.
// Run in parallel. no_of_goroutines = no_of_items_in_list
//
// Takes 2 inputs
//	1. Function - takes 1 input type: employee.Employee output type: (Employer, error)
//	2. List
//
// Returns
//	New List of type (Employer, error)
//	Empty list if all arguments are nil or either one is nil
func PMapEmployeeEmployerErr(f func(employee.Employee) (Employer, error), list []employee.Employee) ([]Employer, error) {
	if f == nil {
		return []Employer{}, nil
	}

	ch := make(chan map[int]Employer, len(list))
	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i, v := range list {
		wg.Add(1)

		go func(wg *sync.WaitGroup, ch chan map[int]Employer, i int, v employee.Employee) {
			defer wg.Done()
			if len(errCh) >= 1 {
				return
			}
			r, err := f(v)
			if err != nil {
				errCh <- err
				return
			}
			ch <- map[int]Employer{i: r}
		}(&wg, ch, i, v)
	}

	wg.Wait()
	close(ch)
	close(errCh)
	
	for err := range errCh {
		if err != nil {
			return nil, err
		}
	}

	newList := make([]Employer, len(list))
	for m := range ch {
		for k, v := range m {
			newList[k] = v
		}
	}
	return newList, nil
}

// PMapEmployeeEmployerPtr applies the function(1st argument) on each item of the list and returns new list.
// Run in parallel. no_of_goroutines = no_of_items_in_list
//
// Takes 2 inputs
//	1. Function - takes 1 input type: *employee.Employee output type: *Employer
//	2. List
//
// Returns
//	New List of type *Employer
//	Empty list if all arguments are nil or either one is nil
func PMapEmployeeEmployerPtr(f func(*employee.Employee) *Employer, list []*employee.Employee) []*Employer {
	if f == nil {
		return []*Employer{}
	}

	ch := make(chan map[int]*Employer)
	var wg sync.WaitGroup

	for i, v := range list {
		wg.Add(1)

		go func(wg *sync.WaitGroup, ch chan map[int]*Employer, i int, v *employee.Employee) {
			defer wg.Done()
			ch <- map[int]*Employer{i: f(v)}
		}(&wg, ch, i, v)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	newList := make([]*Employer, len(list))
	for m := range ch {
		for k, v := range m {
			newList[k] = v
		}
	}
	return newList
}

// PMapEmployeeEmployerPtrErr applies the function(1st argument) on each item of the list and returns new list and error.
// Run in parallel. no_of_goroutines = no_of_items_in_list
//
// Takes 2 inputs
//	1. Function - takes 1 input type: *employee.Employee output type: (*Employer, error)
//	2. List
//
// Returns
//	New List of type (*Employer, error)
//	Empty list if all arguments are nil or either one is nil
func PMapEmployeeEmployerPtrErr(f func(*employee.Employee) (*Employer, error), list []*employee.Employee) ([]*Employer, error) {
	if f == nil {
		return []*Employer{}, nil
	}

	ch := make(chan map[int]*Employer, len(list))
	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i, v := range list {
		wg.Add(1)

		go func(wg *sync.WaitGroup, ch chan map[int]*Employer, i int, v *employee.Employee) {
			defer wg.Done()
			if len(errCh) >= 1 {
				return
			}
			r, err := f(v)
			if err != nil {
				errCh <- err
				return
			}
			ch <- map[int]*Employer{i: r}
		}(&wg, ch, i, v)
	}

	wg.Wait()
	close(ch)
	close(errCh)
	
	for err := range errCh {
		if err != nil {
			return nil, err
		}
	}

	newList := make([]*Employer, len(list))
	for m := range ch {
		for k, v := range m {
			newList[k] = v
		}
	}
	return newList, nil
}

// FilterMapEmployeeEmployer filters given list, then apply function(2nd argument) on each item in the list and returns a new list
// Takes 3 inputs
//	1. Function: takes one input type - employee.Employee and returns true/false.
//	2. Function: takes employee.Employee as argument and returns Employer
// 	3. List of type employee.Employee
//
// Returns:
//	New List of type Employer
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapEmployeeEmployer(fFilter func(employee.Employee) bool, fMap func(employee.Employee) Employer, list []employee.Employee) []Employer {
	if fFilter == nil || fMap == nil {
		return []Employer{}
	}
	var newList []Employer
	for _, v := range list {
		if fFilter(v) {
			newList = append(newList, fMap(v))
		}
	}
	return newList
}

// FilterMapEmployeeEmployerPtrErr filters given list, then apply function(2nd argument) on each item in the list and returns a new list, error
// Takes 3 inputs
//	1. Function: takes one input type - *employee.Employee and returns (bool, error).
//	2. Function: takes *employee.Employee as argument and returns (*Employer, error)
// 	3. List of type *employee.Employee
//
// Returns:
//	New List of type *Employer, error
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapEmployeeEmployerPtrErr(fFilter func(*employee.Employee) (bool, error), fMap func(*employee.Employee) (*Employer, error), list []*employee.Employee) ([]*Employer, error) {
	if fFilter == nil || fMap == nil {
		return []*Employer{}, nil
	}
	var newList []*Employer
	for _, v := range list {
		r, err := fFilter(v)
		if err != nil {
			return nil, err
		}
		if r {
			r, err := fMap(v)
			if err != nil {
				return nil, err
			}
			newList = append(newList, r)
		}
	}
	return newList, nil
}

// FilterMapEmployeeEmployerErr filters given list, then apply function(2nd argument) on each item in the list and returns a new list, error
// Takes 3 inputs
//	1. Function: takes one input type - employee.Employee and returns (bool, error).
//	2. Function: takes employee.Employee as argument and returns (Employer, error)
// 	3. List of type employee.Employee
//
// Returns:
//	New List of type Employer, error
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapEmployeeEmployerErr(fFilter func(employee.Employee) (bool, error), fMap func(employee.Employee) (Employer, error), list []employee.Employee) ([]Employer, error) {
	if fFilter == nil || fMap == nil {
		return []Employer{}, nil
	}
	var newList []Employer
	for _, v := range list {
		r, err := fFilter(v)
		if err != nil {
			return nil, err
		}
		if r {
			r, err := fMap(v)
			if err != nil {
				return nil, err
			}
			newList = append(newList, r)
		}
	}
	return newList, nil
}

// MapEmployeeInt takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list
func MapEmployeeInt(f func(employee.Employee) int, list []employee.Employee) []int {
	if f == nil {
		return []int{}
	}
	newList := make([]int, len(list))
	for i, v := range list {
		newList[i] = f(v)
	}
	return newList
}

// MapEmployeeInt takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list and error
func MapEmployeeIntErr(f func(employee.Employee) (int, error), list []employee.Employee) ([]int, error) {
	if f == nil {
		return []int{}, nil
	}
	newList := make([]int, len(list))
	for i, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		newList[i] = r
	}
	return newList, nil
}

// MapEmployeeInt takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list
func MapEmployeeIntPtr(f func(*employee.Employee) *int, list []*employee.Employee) []*int {
	if f == nil {
		return []*int{}
	}
	newList := make([]*int, len(list))
	for i, v := range list {
		newList[i] = f(v)
	}
	return newList
}

// MapEmployeeIntPtrErr takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list, error
func MapEmployeeIntPtrErr(f func(*employee.Employee) (*int, error), list []*employee.Employee) ([]*int, error) {
	if f == nil {
		return []*int{}, nil
	}
	newList := make([]*int, len(list))
	for i, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		newList[i] = r
	}
	return newList, nil
}

// PMapEmployeeInt applies the function(1st argument) on each item of the list and returns new list.
// Run in parallel. no_of_goroutines = no_of_items_in_list
//
// Takes 2 inputs
//	1. Function - takes 1 input type: employee.Employee output type: int
//	2. List
//
// Returns
//	New List of type int
//	Empty list if all arguments are nil or either one is nil
func PMapEmployeeInt(f func(employee.Employee) int, list []employee.Employee) []int {
	if f == nil {
		return []int{}
	}

	ch := make(chan map[int]int)
	var wg sync.WaitGroup

	for i, v := range list {
		wg.Add(1)

		go func(wg *sync.WaitGroup, ch chan map[int]int, i int, v employee.Employee) {
			defer wg.Done()
			ch <- map[int]int{i: f(v)}
		}(&wg, ch, i, v)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	newList := make([]int, len(list))
	for m := range ch {
		for k, v := range m {
			newList[k] = v
		}
	}
	return newList
}

// PMapEmployeeIntErr applies the function(1st argument) on each item of the list and returns new list and error.
// Run in parallel. no_of_goroutines = no_of_items_in_list
//
// Takes 2 inputs
//	1. Function - takes 1 input type: employee.Employee output type: (int, error)
//	2. List
//
// Returns
//	New List of type (int, error)
//	Empty list if all arguments are nil or either one is nil
func PMapEmployeeIntErr(f func(employee.Employee) (int, error), list []employee.Employee) ([]int, error) {
	if f == nil {
		return []int{}, nil
	}

	ch := make(chan map[int]int, len(list))
	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i, v := range list {
		wg.Add(1)

		go func(wg *sync.WaitGroup, ch chan map[int]int, i int, v employee.Employee) {
			defer wg.Done()
			if len(errCh) >= 1 {
				return
			}
			r, err := f(v)
			if err != nil {
				errCh <- err
				return
			}
			ch <- map[int]int{i: r}
		}(&wg, ch, i, v)
	}

	wg.Wait()
	close(ch)
	close(errCh)
	
	for err := range errCh {
		if err != nil {
			return nil, err
		}
	}

	newList := make([]int, len(list))
	for m := range ch {
		for k, v := range m {
			newList[k] = v
		}
	}
	return newList, nil
}

// PMapEmployeeIntPtr applies the function(1st argument) on each item of the list and returns new list.
// Run in parallel. no_of_goroutines = no_of_items_in_list
//
// Takes 2 inputs
//	1. Function - takes 1 input type: *employee.Employee output type: *int
//	2. List
//
// Returns
//	New List of type *int
//	Empty list if all arguments are nil or either one is nil
func PMapEmployeeIntPtr(f func(*employee.Employee) *int, list []*employee.Employee) []*int {
	if f == nil {
		return []*int{}
	}

	ch := make(chan map[int]*int)
	var wg sync.WaitGroup

	for i, v := range list {
		wg.Add(1)

		go func(wg *sync.WaitGroup, ch chan map[int]*int, i int, v *employee.Employee) {
			defer wg.Done()
			ch <- map[int]*int{i: f(v)}
		}(&wg, ch, i, v)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	newList := make([]*int, len(list))
	for m := range ch {
		for k, v := range m {
			newList[k] = v
		}
	}
	return newList
}

// PMapEmployeeIntPtrErr applies the function(1st argument) on each item of the list and returns new list and error.
// Run in parallel. no_of_goroutines = no_of_items_in_list
//
// Takes 2 inputs
//	1. Function - takes 1 input type: *employee.Employee output type: (*int, error)
//	2. List
//
// Returns
//	New List of type (*int, error)
//	Empty list if all arguments are nil or either one is nil
func PMapEmployeeIntPtrErr(f func(*employee.Employee) (*int, error), list []*employee.Employee) ([]*int, error) {
	if f == nil {
		return []*int{}, nil
	}

	ch := make(chan map[int]*int, len(list))
	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i, v := range list {
		wg.Add(1)

		go func(wg *sync.WaitGroup, ch chan map[int]*int, i int, v *employee.Employee) {
			defer wg.Done()
			if len(errCh) >= 1 {
				return
			}
			r, err := f(v)
			if err != nil {
				errCh <- err
				return
			}
			ch <- map[int]*int{i: r}
		}(&wg, ch, i, v)
	}

	wg.Wait()
	close(ch)
	close(errCh)
	
	for err := range errCh {
		if err != nil {
			return nil, err
		}
	}

	newList := make([]*int, len(list))
	for m := range ch {
		for k, v := range m {
			newList[k] = v
		}
	}
	return newList, nil
}

// FilterMapEmployeeInt filters given list, then apply function(2nd argument) on each item in the list and returns a new list
// Takes 3 inputs
//	1. Function: takes one input type - employee.Employee and returns true/false.
//	2. Function: takes employee.Employee as argument and returns int
// 	3. List of type employee.Employee
//
// Returns:
//	New List of type int
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapEmployeeInt(fFilter func(employee.Employee) bool, fMap func(employee.Employee) int, list []employee.Employee) []int {
	if fFilter == nil || fMap == nil {
		return []int{}
	}
	var newList []int
	for _, v := range list {
		if fFilter(v) {
			newList = append(newList, fMap(v))
		}
	}
	return newList
}

// FilterMapEmployeeIntPtrErr filters given list, then apply function(2nd argument) on each item in the list and returns a new list, error
// Takes 3 inputs
//	1. Function: takes one input type - *employee.Employee and returns (bool, error).
//	2. Function: takes *employee.Employee as argument and returns (*int, error)
// 	3. List of type *employee.Employee
//
// Returns:
//	New List of type *int, error
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapEmployeeIntPtrErr(fFilter func(*employee.Employee) (bool, error), fMap func(*employee.Employee) (*int, error), list []*employee.Employee) ([]*int, error) {
	if fFilter == nil || fMap == nil {
		return []*int{}, nil
	}
	var newList []*int
	for _, v := range list {
		r, err := fFilter(v)
		if err != nil {
			return nil, err
		}
		if r {
			r, err := fMap(v)
			if err != nil {
				return nil, err
			}
			newList = append(newList, r)
		}
	}
	return newList, nil
}

// FilterMapEmployeeIntErr filters given list, then apply function(2nd argument) on each item in the list and returns a new list, error
// Takes 3 inputs
//	1. Function: takes one input type - employee.Employee and returns (bool, error).
//	2. Function: takes employee.Employee as argument and returns (int, error)
// 	3. List of type employee.Employee
//
// Returns:
//	New List of type int, error
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapEmployeeIntErr(fFilter func(employee.Employee) (bool, error), fMap func(employee.Employee) (int, error), list []employee.Employee) ([]int, error) {
	if fFilter == nil || fMap == nil {
		return []int{}, nil
	}
	var newList []int
	for _, v := range list {
		r, err := fFilter(v)
		if err != nil {
			return nil, err
		}
		if r {
			r, err := fMap(v)
			if err != nil {
				return nil, err
			}
			newList = append(newList, r)
		}
	}
	return newList, nil
}

// MapIntEmployer takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list
func MapIntEmployer(f func(int) Employer, list []int) []Employer {
	if f == nil {
		return []Employer{}
	}
	newList := make([]Employer, len(list))
	for i, v := range list {
		newList[i] = f(v)
	}
	return newList
}

// MapIntEmployer takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list and error
func MapIntEmployerErr(f func(int) (Employer, error), list []int) ([]Employer, error) {
	if f == nil {
		return []Employer{}, nil
	}
	newList := make([]Employer, len(list))
	for i, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		newList[i] = r
	}
	return newList, nil
}

// MapIntEmployer takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list
func MapIntEmployerPtr(f func(*int) *Employer, list []*int) []*Employer {
	if f == nil {
		return []*Employer{}
	}
	newList := make([]*Employer, len(list))
	for i, v := range list {
		newList[i] = f(v)
	}
	return newList
}

// MapIntEmployerPtrErr takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list, error
func MapIntEmployerPtrErr(f func(*int) (*Employer, error), list []*int) ([]*Employer, error) {
	if f == nil {
		return []*Employer{}, nil
	}
	newList := make([]*Employer, len(list))
	for i, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		newList[i] = r
	}
	return newList, nil
}

// PMapIntEmployer applies the function(1st argument) on each item of the list and returns new list.
// Run in parallel. no_of_goroutines = no_of_items_in_list
//
// Takes 2 inputs
//	1. Function - takes 1 input type: int output type: Employer
//	2. List
//
// Returns
//	New List of type Employer
//	Empty list if all arguments are nil or either one is nil
func PMapIntEmployer(f func(int) Employer, list []int) []Employer {
	if f == nil {
		return []Employer{}
	}

	ch := make(chan map[int]Employer)
	var wg sync.WaitGroup

	for i, v := range list {
		wg.Add(1)

		go func(wg *sync.WaitGroup, ch chan map[int]Employer, i int, v int) {
			defer wg.Done()
			ch <- map[int]Employer{i: f(v)}
		}(&wg, ch, i, v)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	newList := make([]Employer, len(list))
	for m := range ch {
		for k, v := range m {
			newList[k] = v
		}
	}
	return newList
}

// PMapIntEmployerErr applies the function(1st argument) on each item of the list and returns new list and error.
// Run in parallel. no_of_goroutines = no_of_items_in_list
//
// Takes 2 inputs
//	1. Function - takes 1 input type: int output type: (Employer, error)
//	2. List
//
// Returns
//	New List of type (Employer, error)
//	Empty list if all arguments are nil or either one is nil
func PMapIntEmployerErr(f func(int) (Employer, error), list []int) ([]Employer, error) {
	if f == nil {
		return []Employer{}, nil
	}

	ch := make(chan map[int]Employer, len(list))
	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i, v := range list {
		wg.Add(1)

		go func(wg *sync.WaitGroup, ch chan map[int]Employer, i int, v int) {
			defer wg.Done()
			if len(errCh) >= 1 {
				return
			}
			r, err := f(v)
			if err != nil {
				errCh <- err
				return
			}
			ch <- map[int]Employer{i: r}
		}(&wg, ch, i, v)
	}

	wg.Wait()
	close(ch)
	close(errCh)
	
	for err := range errCh {
		if err != nil {
			return nil, err
		}
	}

	newList := make([]Employer, len(list))
	for m := range ch {
		for k, v := range m {
			newList[k] = v
		}
	}
	return newList, nil
}

// PMapIntEmployerPtr applies the function(1st argument) on each item of the list and returns new list.
// Run in parallel. no_of_goroutines = no_of_items_in_list
//
// Takes 2 inputs
//	1. Function - takes 1 input type: *int output type: *Employer
//	2. List
//
// Returns
//	New List of type *Employer
//	Empty list if all arguments are nil or either one is nil
func PMapIntEmployerPtr(f func(*int) *Employer, list []*int) []*Employer {
	if f == nil {
		return []*Employer{}
	}

	ch := make(chan map[int]*Employer)
	var wg sync.WaitGroup

	for i, v := range list {
		wg.Add(1)

		go func(wg *sync.WaitGroup, ch chan map[int]*Employer, i int, v *int) {
			defer wg.Done()
			ch <- map[int]*Employer{i: f(v)}
		}(&wg, ch, i, v)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	newList := make([]*Employer, len(list))
	for m := range ch {
		for k, v := range m {
			newList[k] = v
		}
	}
	return newList
}

// PMapIntEmployerPtrErr applies the function(1st argument) on each item of the list and returns new list and error.
// Run in parallel. no_of_goroutines = no_of_items_in_list
//
// Takes 2 inputs
//	1. Function - takes 1 input type: *int output type: (*Employer, error)
//	2. List
//
// Returns
//	New List of type (*Employer, error)
//	Empty list if all arguments are nil or either one is nil
func PMapIntEmployerPtrErr(f func(*int) (*Employer, error), list []*int) ([]*Employer, error) {
	if f == nil {
		return []*Employer{}, nil
	}

	ch := make(chan map[int]*Employer, len(list))
	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i, v := range list {
		wg.Add(1)

		go func(wg *sync.WaitGroup, ch chan map[int]*Employer, i int, v *int) {
			defer wg.Done()
			if len(errCh) >= 1 {
				return
			}
			r, err := f(v)
			if err != nil {
				errCh <- err
				return
			}
			ch <- map[int]*Employer{i: r}
		}(&wg, ch, i, v)
	}

	wg.Wait()
	close(ch)
	close(errCh)
	
	for err := range errCh {
		if err != nil {
			return nil, err
		}
	}

	newList := make([]*Employer, len(list))
	for m := range ch {
		for k, v := range m {
			newList[k] = v
		}
	}
	return newList, nil
}

// FilterMapIntEmployer filters given list, then apply function(2nd argument) on each item in the list and returns a new list
// Takes 3 inputs
//	1. Function: takes one input type - int and returns true/false.
//	2. Function: takes int as argument and returns Employer
// 	3. List of type int
//
// Returns:
//	New List of type Employer
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapIntEmployer(fFilter func(int) bool, fMap func(int) Employer, list []int) []Employer {
	if fFilter == nil || fMap == nil {
		return []Employer{}
	}
	var newList []Employer
	for _, v := range list {
		if fFilter(v) {
			newList = append(newList, fMap(v))
		}
	}
	return newList
}

// FilterMapIntEmployerPtrErr filters given list, then apply function(2nd argument) on each item in the list and returns a new list, error
// Takes 3 inputs
//	1. Function: takes one input type - *int and returns (bool, error).
//	2. Function: takes *int as argument and returns (*Employer, error)
// 	3. List of type *int
//
// Returns:
//	New List of type *Employer, error
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapIntEmployerPtrErr(fFilter func(*int) (bool, error), fMap func(*int) (*Employer, error), list []*int) ([]*Employer, error) {
	if fFilter == nil || fMap == nil {
		return []*Employer{}, nil
	}
	var newList []*Employer
	for _, v := range list {
		r, err := fFilter(v)
		if err != nil {
			return nil, err
		}
		if r {
			r, err := fMap(v)
			if err != nil {
				return nil, err
			}
			newList = append(newList, r)
		}
	}
	return newList, nil
}

// FilterMapIntEmployerErr filters given list, then apply function(2nd argument) on each item in the list and returns a new list, error
// Takes 3 inputs
//	1. Function: takes one input type - int and returns (bool, error).
//	2. Function: takes int as argument and returns (Employer, error)
// 	3. List of type int
//
// Returns:
//	New List of type Employer, error
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapIntEmployerErr(fFilter func(int) (bool, error), fMap func(int) (Employer, error), list []int) ([]Employer, error) {
	if fFilter == nil || fMap == nil {
		return []Employer{}, nil
	}
	var newList []Employer
	for _, v := range list {
		r, err := fFilter(v)
		if err != nil {
			return nil, err
		}
		if r {
			r, err := fMap(v)
			if err != nil {
				return nil, err
			}
			newList = append(newList, r)
		}
	}
	return newList, nil
}

// MapIntEmployee takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list
func MapIntEmployee(f func(int) employee.Employee, list []int) []employee.Employee {
	if f == nil {
		return []employee.Employee{}
	}
	newList := make([]employee.Employee, len(list))
	for i, v := range list {
		newList[i] = f(v)
	}
	return newList
}

// MapIntEmployee takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list and error
func MapIntEmployeeErr(f func(int) (employee.Employee, error), list []int) ([]employee.Employee, error) {
	if f == nil {
		return []employee.Employee{}, nil
	}
	newList := make([]employee.Employee, len(list))
	for i, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		newList[i] = r
	}
	return newList, nil
}

// MapIntEmployee takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list
func MapIntEmployeePtr(f func(*int) *employee.Employee, list []*int) []*employee.Employee {
	if f == nil {
		return []*employee.Employee{}
	}
	newList := make([]*employee.Employee, len(list))
	for i, v := range list {
		newList[i] = f(v)
	}
	return newList
}

// MapIntEmployeePtrErr takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list, error
func MapIntEmployeePtrErr(f func(*int) (*employee.Employee, error), list []*int) ([]*employee.Employee, error) {
	if f == nil {
		return []*employee.Employee{}, nil
	}
	newList := make([]*employee.Employee, len(list))
	for i, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		newList[i] = r
	}
	return newList, nil
}

// PMapIntEmployee applies the function(1st argument) on each item of the list and returns new list.
// Run in parallel. no_of_goroutines = no_of_items_in_list
//
// Takes 2 inputs
//	1. Function - takes 1 input type: int output type: employee.Employee
//	2. List
//
// Returns
//	New List of type employee.Employee
//	Empty list if all arguments are nil or either one is nil
func PMapIntEmployee(f func(int) employee.Employee, list []int) []employee.Employee {
	if f == nil {
		return []employee.Employee{}
	}

	ch := make(chan map[int]employee.Employee)
	var wg sync.WaitGroup

	for i, v := range list {
		wg.Add(1)

		go func(wg *sync.WaitGroup, ch chan map[int]employee.Employee, i int, v int) {
			defer wg.Done()
			ch <- map[int]employee.Employee{i: f(v)}
		}(&wg, ch, i, v)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	newList := make([]employee.Employee, len(list))
	for m := range ch {
		for k, v := range m {
			newList[k] = v
		}
	}
	return newList
}

// PMapIntEmployeeErr applies the function(1st argument) on each item of the list and returns new list and error.
// Run in parallel. no_of_goroutines = no_of_items_in_list
//
// Takes 2 inputs
//	1. Function - takes 1 input type: int output type: (employee.Employee, error)
//	2. List
//
// Returns
//	New List of type (employee.Employee, error)
//	Empty list if all arguments are nil or either one is nil
func PMapIntEmployeeErr(f func(int) (employee.Employee, error), list []int) ([]employee.Employee, error) {
	if f == nil {
		return []employee.Employee{}, nil
	}

	ch := make(chan map[int]employee.Employee, len(list))
	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i, v := range list {
		wg.Add(1)

		go func(wg *sync.WaitGroup, ch chan map[int]employee.Employee, i int, v int) {
			defer wg.Done()
			if len(errCh) >= 1 {
				return
			}
			r, err := f(v)
			if err != nil {
				errCh <- err
				return
			}
			ch <- map[int]employee.Employee{i: r}
		}(&wg, ch, i, v)
	}

	wg.Wait()
	close(ch)
	close(errCh)
	
	for err := range errCh {
		if err != nil {
			return nil, err
		}
	}

	newList := make([]employee.Employee, len(list))
	for m := range ch {
		for k, v := range m {
			newList[k] = v
		}
	}
	return newList, nil
}

// PMapIntEmployeePtr applies the function(1st argument) on each item of the list and returns new list.
// Run in parallel. no_of_goroutines = no_of_items_in_list
//
// Takes 2 inputs
//	1. Function - takes 1 input type: *int output type: *employee.Employee
//	2. List
//
// Returns
//	New List of type *employee.Employee
//	Empty list if all arguments are nil or either one is nil
func PMapIntEmployeePtr(f func(*int) *employee.Employee, list []*int) []*employee.Employee {
	if f == nil {
		return []*employee.Employee{}
	}

	ch := make(chan map[int]*employee.Employee)
	var wg sync.WaitGroup

	for i, v := range list {
		wg.Add(1)

		go func(wg *sync.WaitGroup, ch chan map[int]*employee.Employee, i int, v *int) {
			defer wg.Done()
			ch <- map[int]*employee.Employee{i: f(v)}
		}(&wg, ch, i, v)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	newList := make([]*employee.Employee, len(list))
	for m := range ch {
		for k, v := range m {
			newList[k] = v
		}
	}
	return newList
}

// PMapIntEmployeePtrErr applies the function(1st argument) on each item of the list and returns new list and error.
// Run in parallel. no_of_goroutines = no_of_items_in_list
//
// Takes 2 inputs
//	1. Function - takes 1 input type: *int output type: (*employee.Employee, error)
//	2. List
//
// Returns
//	New List of type (*employee.Employee, error)
//	Empty list if all arguments are nil or either one is nil
func PMapIntEmployeePtrErr(f func(*int) (*employee.Employee, error), list []*int) ([]*employee.Employee, error) {
	if f == nil {
		return []*employee.Employee{}, nil
	}

	ch := make(chan map[int]*employee.Employee, len(list))
	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i, v := range list {
		wg.Add(1)

		go func(wg *sync.WaitGroup, ch chan map[int]*employee.Employee, i int, v *int) {
			defer wg.Done()
			if len(errCh) >= 1 {
				return
			}
			r, err := f(v)
			if err != nil {
				errCh <- err
				return
			}
			ch <- map[int]*employee.Employee{i: r}
		}(&wg, ch, i, v)
	}

	wg.Wait()
	close(ch)
	close(errCh)
	
	for err := range errCh {
		if err != nil {
			return nil, err
		}
	}

	newList := make([]*employee.Employee, len(list))
	for m := range ch {
		for k, v := range m {
			newList[k] = v
		}
	}
	return newList, nil
}

// FilterMapIntEmployee filters given list, then apply function(2nd argument) on each item in the list and returns a new list
// Takes 3 inputs
//	1. Function: takes one input type - int and returns true/false.
//	2. Function: takes int as argument and returns employee.Employee
// 	3. List of type int
//
// Returns:
//	New List of type employee.Employee
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapIntEmployee(fFilter func(int) bool, fMap func(int) employee.Employee, list []int) []employee.Employee {
	if fFilter == nil || fMap == nil {
		return []employee.Employee{}
	}
	var newList []employee.Employee
	for _, v := range list {
		if fFilter(v) {
			newList = append(newList, fMap(v))
		}
	}
	return newList
}

// FilterMapIntEmployeePtrErr filters given list, then apply function(2nd argument) on each item in the list and returns a new list, error
// Takes 3 inputs
//	1. Function: takes one input type - *int and returns (bool, error).
//	2. Function: takes *int as argument and returns (*employee.Employee, error)
// 	3. List of type *int
//
// Returns:
//	New List of type *employee.Employee, error
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapIntEmployeePtrErr(fFilter func(*int) (bool, error), fMap func(*int) (*employee.Employee, error), list []*int) ([]*employee.Employee, error) {
	if fFilter == nil || fMap == nil {
		return []*employee.Employee{}, nil
	}
	var newList []*employee.Employee
	for _, v := range list {
		r, err := fFilter(v)
		if err != nil {
			return nil, err
		}
		if r {
			r, err := fMap(v)
			if err != nil {
				return nil, err
			}
			newList = append(newList, r)
		}
	}
	return newList, nil
}

// FilterMapIntEmployeeErr filters given list, then apply function(2nd argument) on each item in the list and returns a new list, error
// Takes 3 inputs
//	1. Function: takes one input type - int and returns (bool, error).
//	2. Function: takes int as argument and returns (employee.Employee, error)
// 	3. List of type int
//
// Returns:
//	New List of type employee.Employee, error
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapIntEmployeeErr(fFilter func(int) (bool, error), fMap func(int) (employee.Employee, error), list []int) ([]employee.Employee, error) {
	if fFilter == nil || fMap == nil {
		return []employee.Employee{}, nil
	}
	var newList []employee.Employee
	for _, v := range list {
		r, err := fFilter(v)
		if err != nil {
			return nil, err
		}
		if r {
			r, err := fMap(v)
			if err != nil {
				return nil, err
			}
			newList = append(newList, r)
		}
	}
	return newList, nil
}

