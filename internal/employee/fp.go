// Code generated by 'gofp'. DO NOT EDIT.
package employee
import "sort" 
import "sync" 

func Map(f func(Employee) Employee, list []Employee) []Employee {
	if f == nil {
		return []Employee{}
	}
	newList := make([]Employee, len(list))
	for i, v := range list {
		newList[i] = f(v)
	}
	return newList
}

func MapPtr(f func(*Employee) *Employee, list []*Employee) []*Employee {
	if f == nil {
		return []*Employee{}
	}
	newList := make([]*Employee, len(list))
	for i, v := range list {
		newList[i] = f(v)
	}
	return newList
}

// MapPtrErr takes 2 arguments:
//  1. A function input argument: *Employee and return types (*Employee, error)
//  2. A list of type []*Employee
//
// Returns:
// 	([]*Employee, error)
func MapPtrErr(f func(*Employee) (*Employee, error), list []*Employee) ([]*Employee, error) {
	if f == nil {
		return []*Employee{}, nil
	}
	newList := make([]*Employee, len(list))
	for i, v := range list {
		var err error
		newList[i], err = f(v)
		if err != nil {
			return nil, err
		}
	}
	return newList, nil
}

// MapErr takes 2 arguments:
//  1. A function input argument: Employee and return types (Employee, error)
//  2. A list of type []Employee
//
// Returns:
// 	([]Employee, error)
func MapErr(f func(Employee) (Employee, error), list []Employee) ([]Employee, error) {
	if f == nil {
		return []Employee{}, nil
	}
	newList := make([]Employee, len(list))
	for i, v := range list {
		var err error
		newList[i], err = f(v)
		if err != nil {
			return nil, err
		}
	}
	return newList, nil
}

func Filter(f func(Employee) bool, list []Employee) []Employee {
	if f == nil {
		return []Employee{}
	}
	var newList []Employee
	for _, v := range list {
		if f(v) {
			newList = append(newList, v)
		}
	}
	return newList
}

func FilterPtr(f func(*Employee) bool, list []*Employee) []*Employee {
	if f == nil {
		return []*Employee{}
	}
	var newList []*Employee
	for _, v := range list {
		if f(v) {
			newList = append(newList, v)
		}
	}
	return newList
}

// FilterPtrErr takes two arguments
//  1. Function: takes 1 argument of type Employee and returns (bool, error)
//  2. slice of type []*Employee
//
// Returns:
//  new filtered list and error
func FilterPtrErr(f func(*Employee) (bool, error), list []*Employee) ([]*Employee, error) {
	if f == nil {
		return []*Employee{}, nil
	}
	var newList []*Employee
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if r {
			newList = append(newList, v)
		}
	}
	return newList, nil
}

// FilterErr takes two arguments
//  1. Function: takes 1 argument of type Employee and returns (bool, error)
//  2. slice of type []Employee
//
// Returns:
//  new filtered list and error
func FilterErr(f func(Employee) (bool, error), list []Employee) ([]Employee, error) {
	if f == nil {
		return []Employee{}, nil
	}
	var newList []Employee
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if r {
			newList = append(newList, v)
		}
	}
	return newList, nil
}

func Remove(f func(Employee) bool, list []Employee) []Employee {
	if f == nil {
		return []Employee{}
	}
	var newList []Employee
	for _, v := range list {
		if !f(v) {
			newList = append(newList, v)
		}
	}
	return newList
}

func RemovePtr(f func(*Employee) bool, list []*Employee) []*Employee {
	if f == nil {
		return []*Employee{}
	}
	var newList []*Employee
	for _, v := range list {
		if !f(v) {
			newList = append(newList, v)
		}
	}
	return newList
}

// RemovePtrErr removes the items from the given list based on supplied function and returns new list
//
// Takes 2 inputs:
//	1. Function: input type *Employee and return types(bool, error)
//	2. List of type: []*Employee
//
// Returns:
//	New list and error: ([]*Employee, error)
//	Empty list if both of arguments are nil or either one is nil.
func RemovePtrErr(f func(*Employee) (bool, error), list []*Employee) ([]*Employee, error) {
	if f == nil {
		return []*Employee{}, nil
	}
	var newList []*Employee
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if !r {
			newList = append(newList, v)
		}
	}
	return newList, nil
}

// RemoveErr removes the items from the given list based on supplied function and returns new list
//
// Takes 2 inputs:
//	1. Function: input type Employee and return types(bool, error)
//	2. List of type: []Employee
//
// Returns:
//	New list and error: ([]Employee, error)
//	Empty list if both of arguments are nil or either one is nil.
func RemoveErr(f func(Employee) (bool, error), list []Employee) ([]Employee, error) {
	if f == nil {
		return []Employee{}, nil
	}
	var newList []Employee
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if !r {
			newList = append(newList, v)
		}
	}
	return newList, nil
}

func Some(f func(Employee) bool, list []Employee) bool {
	if f == nil {
		return false
	}
	for _, v := range list {
		if f(v) {
			return true
		}
	}
	return false
}

func SomePtr(f func(*Employee) bool, list []*Employee) bool {
	if f == nil {
		return false
	}
	for _, v := range list {
		if f(v) {
			return true
		}
	}
	return false
}

// SomePtrErr finds item in the list based on supplied function.
//
// Takes 2 input:
//	1. Function
//	2. List
//
// Returns:
//	(bool,err).
//	True if condition satisfies, else false
func SomePtrErr(f func(*Employee) (bool, error), list []*Employee) (bool, error) {
	if f == nil {
		return false, nil
	}
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return false, err
		}
		if r {
			return true, nil
		}
	}
	return false, nil
}

// SomeErr finds item in the list based on supplied function.
//
// Takes 2 input:
//	1. Function
//	2. List
//
// Returns:
//	(bool,err).
//	True if condition satisfies, else false
func SomeErr(f func(Employee) (bool, error), list []Employee) (bool, error) {
	if f == nil {
		return false, nil
	}
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return false, err
		}
		if r {
			return true, nil
		}
	}
	return false, nil
}

func Every(f func(Employee) bool, list []Employee) bool {
	if f == nil || len(list) == 0 {
		return false
	}
	for _, v := range list {
		if !f(v) {
			return false
		}
	}
	return true
}

func EveryPtr(f func(*Employee) bool, list []*Employee) bool {
	if f == nil || len(list) == 0 {
		return false
	}
	for _, v := range list {
		if !f(v) {
			return false
		}
	}
	return true
}

// EveryPtrErr returns true if supplied function returns logical true for every item in the list
func EveryPtrErr(f func(*Employee) (bool, error), list []*Employee) (bool, error) {
	if f == nil || len(list) == 0 {
		return false, nil
	}
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return false, err
		}
		if !r {
			return false, nil
		}
	}
	return true, nil
}

// EveryErr returns true if supplied function returns logical true for every item in the list
func EveryErr(f func(Employee) (bool, error), list []Employee) (bool, error) {
	if f == nil || len(list) == 0 {
		return false, nil
	}
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return false, err
		}
		if !r {
			return false, nil
		}
	}
	return true, nil
}

func DropWhile(f func(Employee) bool, list []Employee) []Employee {
	if f == nil {
		return []Employee{}
	}
	var newList []Employee
	for i, v := range list {
		if !f(v) {
			listLen := len(list)
			newList = make([]Employee, listLen-i)
			j := 0
			for i < listLen {
				newList[j] = list[i]
				i++
				j++
			}
			return newList
		}
	}
	return newList
}

func DropWhilePtr(f func(*Employee) bool, list []*Employee) []*Employee {
	if f == nil {
		return []*Employee{}
	}
	var newList []*Employee
	for i, v := range list {
		if !f(v) {
			listLen := len(list)
			newList = make([]*Employee, listLen-i)
			j := 0
			for i < listLen {
				newList[j] = list[i]
				i++
				j++
			}
			return newList
		}
	}
	return newList
}

// DropWhilePtrErr drops the items from the list as long as condition satisfies.
//
// Takes two inputs
//	1. Function: takes one input and returns (boolean, error)
//	2. list
//
// Returns:
// 	New List, error
//  Empty list if either one of arguments or both of them are nil
func DropWhilePtrErr(f func(*Employee) (bool, error), list []*Employee) ([]*Employee, error) {
	if f == nil {
		return []*Employee{}, nil
	}
	var newList []*Employee
	for i, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if !r {
			listLen := len(list)
			newList = make([]*Employee, listLen-i)
			j := 0
			for i < listLen {
				newList[j] = list[i]
				i++
				j++
			}
			return newList, nil
		}
	}
	return newList, nil
}

// DropWhileErr drops the items from the list as long as condition satisfies.
//
// Takes two inputs
//	1. Function: takes one input and returns (boolean, error)
//	2. list
//
// Returns:
// 	New List, error
//  Empty list if either one of arguments or both of them are nil
func DropWhileErr(f func(Employee) (bool, error), list []Employee) ([]Employee, error) {
	if f == nil {
		return []Employee{}, nil
	}
	var newList []Employee
	for i, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if !r {
			listLen := len(list)
			newList = make([]Employee, listLen-i)
			j := 0
			for i < listLen {
				newList[j] = list[i]
				i++
				j++
			}
			return newList, nil
		}
	}
	return newList, nil
}

func TakeWhile(f func(Employee) bool, list []Employee) []Employee {
	if f == nil {
		return []Employee{}
	}
	var newList []Employee
	for _, v := range list {
		if !f(v) {
			return newList
		}
		newList = append(newList, v)
	}
	return newList
}

func TakeWhilePtr(f func(*Employee) bool, list []*Employee) []*Employee {
	if f == nil {
		return []*Employee{}
	}
	var newList []*Employee
	for _, v := range list {
		if !f(v) {
			return newList
		}
		newList = append(newList, v)
	}
	return newList
}

// TakeWhilePtrErr returns new list based on condition in the supplied function. It returns new list once condition fails.
//
// Takes 2 inputs:
//	1. Function - 1 input of type *Employee and returns ([]*Employee, error)
//	2. List
//
// Returns:
//	New List, error.
//	Empty list if all the parameters are nil or either of one parameter is nil
func TakeWhilePtrErr(f func(*Employee) (bool, error), list []*Employee) ([]*Employee, error) {
	if f == nil {
		return []*Employee{}, nil
	}
	var newList []*Employee
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if !r {
			return newList, nil
		}
		newList = append(newList, v)
	}
	return newList, nil
}

// TakeWhileErr returns new list based on condition in the supplied function. It returns new list once condition fails.
//
// Takes 2 inputs:
//	1. Function - 1 input of type Employee and returns ([]Employee, error)
//	2. List
//
// Returns:
//	New List, error.
//	Empty list if all the parameters are nil or either of one parameter is nil
func TakeWhileErr(f func(Employee) (bool, error), list []Employee) ([]Employee, error) {
	if f == nil {
		return []Employee{}, nil
	}
	var newList []Employee
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if !r {
			return newList, nil
		}
		newList = append(newList, v)
	}
	return newList, nil
}

func PMap(f func(Employee) Employee, list []Employee) []Employee {
	if f == nil {
		return []Employee{}
	}

	ch := make(chan map[int]Employee)
	var wg sync.WaitGroup

	for i, v := range list {
		wg.Add(1)

		go func(wg *sync.WaitGroup, ch chan map[int]Employee, i int, v Employee) {
			defer wg.Done()
			ch <- map[int]Employee{i: f(v)}
		}(&wg, ch, i, v)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	newList := make([]Employee, len(list))
	for m := range ch {
		for k, v := range m {
			newList[k] = v
		}
	}
	return newList
}

// PMapPtr applies the function(1st argument) on each item of the list and returns new list.
// Run in parallel. no_of_goroutines = no_of_items_in_list
func PMapPtr(f func(*Employee) *Employee, list []*Employee) []*Employee {
	if f == nil {
		return []*Employee{}
	}

	ch := make(chan map[int]*Employee)
	var wg sync.WaitGroup

	for i, v := range list {
		wg.Add(1)

		go func(wg *sync.WaitGroup, ch chan map[int]*Employee, i int, v *Employee) {
			defer wg.Done()
			ch <- map[int]*Employee{i: f(v)}
		}(&wg, ch, i, v)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	newList := make([]*Employee, len(list))
	for m := range ch {
		for k, v := range m {
			newList[k] = v
		}
	}
	return newList
}

// PMapPtrErr applies the function(1st argument) on each item of the list and returns new list.
// Run in parallel. no_of_goroutines = no_of_items_in_list
func PMapPtrErr(f func(*Employee) (*Employee, error), list []*Employee) ([]*Employee, error) {
	if f == nil {
		return []*Employee{}, nil
	}

	ch := make(chan map[int]*Employee, len(list))
	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i, v := range list {
		wg.Add(1)

		go func(wg *sync.WaitGroup, ch chan map[int]*Employee, i int, v *Employee) {
			defer wg.Done()
			if len(errCh) >= 1 {
				return
			}
			r, err := f(v)
			if err != nil {
				errCh <- err
				return
			}
			ch <- map[int]*Employee{i: r}
		}(&wg, ch, i, v)
	}

	wg.Wait()
	close(ch)
	close(errCh)

	for err := range errCh {
		if err != nil {
			return nil, err
		}
	}

	newList := make([]*Employee, len(list))
	for m := range ch {
		for k, v := range m {
			newList[k] = v
		}
	}
	return newList, nil
}

// PMapErr applies the function(1st argument) on each item of the list and returns new list.
// Run in parallel. no_of_goroutines = no_of_items_in_list
func PMapErr(f func(Employee) (Employee, error), list []Employee) ([]Employee, error) {
	if f == nil {
		return []Employee{}, nil
	}

	ch := make(chan map[int]Employee, len(list))
	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i, v := range list {
		wg.Add(1)

		go func(wg *sync.WaitGroup, ch chan map[int]Employee, i int, v Employee) {
			defer wg.Done()
			if len(errCh) >= 1 {
				return
			}
			r, err := f(v)
			if err != nil {
				errCh <- err
				return
			}
			ch <- map[int]Employee{i: r}
		}(&wg, ch, i, v)
	}

	wg.Wait()
	close(ch)
	close(errCh)

	for err := range errCh {
		if err != nil {
			return nil, err
		}
	}

	newList := make([]Employee, len(list))
	for m := range ch {
		for k, v := range m {
			newList[k] = v
		}
	}
	return newList, nil
}

func FilterMap(fFilter func(Employee) bool, fMap func(Employee) Employee, list []Employee) []Employee {
	if fFilter == nil || fMap == nil {
		return []Employee{}
	}
	var newList []Employee
	for _, v := range list {
		if fFilter(v) {
			newList = append(newList, fMap(v))
		}
	}
	return newList
}

func FilterMapPtr(fFilter func(*Employee) bool, fMap func(*Employee) *Employee, list []*Employee) []*Employee {
	if fFilter == nil || fMap == nil {
		return []*Employee{}
	}
	var newList []*Employee
	for _, v := range list {
		if fFilter(v) {
			newList = append(newList, fMap(v))
		}
	}
	return newList
}

// FilterMapPtrErr filters given list, then apply function(2nd argument) on each item in the list and returns a new list
// Takes 3 inputs
//	1. Function: takes one input(*Employee) and returns (bool, error).
//	2. Function: takes *Employee as argument and returns (*Employee, error)
// 	3. Slice of type []*Employee
//
// Returns:
//	New List ([]*Employee, error).
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapPtrErr(fFilter func(*Employee) (bool, error), fMap func(*Employee) (*Employee, error), list []*Employee) ([]*Employee, error) {
	if fFilter == nil || fMap == nil {
		return []*Employee{}, nil
	}
	var newList []*Employee
	for _, v := range list {
		r, err := fFilter(v)
		if err != nil {
			return nil, err
		}
		if r {
			r, err := fMap(v)
			if err != nil {
				return nil, err
			}
			newList = append(newList, r)
		}
	}
	return newList, nil
}

// FilterMapErr filters given list, then apply function(2nd argument) on each item in the list and returns a new list
// Takes 3 inputs
//	1. Function: takes one input(Employee) and returns (bool, error).
//	2. Function: takes Employee as argument and returns (Employee, error)
// 	3. Slice of type []Employee
//
// Returns:
//	New List ([]Employee, error).
//  Empty list if all there parameters are nil or either of parameter is nil
//
func FilterMapErr(fFilter func(Employee) (bool, error), fMap func(Employee) (Employee, error), list []Employee) ([]Employee, error) {
	if fFilter == nil || fMap == nil {
		return []Employee{}, nil
	}
	var newList []Employee
	for _, v := range list {
		r, err := fFilter(v)
		if err != nil {
			return nil, err
		}
		if r {
			r, err := fMap(v)
			if err != nil {
				return nil, err
			}
			newList = append(newList, r)
		}
	}
	return newList, nil
}

func Rest(l []Employee) []Employee {
	if l == nil {
		return []Employee{}
	}

	len := len(l)
	if len == 0 || len == 1 {
		return []Employee{}
	}

	newList := make([]Employee, len-1)

	for i, v := range l[1:] {
		newList[i] = v
	}

	return newList
}


// Rest removes 1st item of the list and return new list having rest of the items
func RestPtr(l []*Employee) []*Employee {
	if l == nil {
		return []*Employee{}
	}

	len := len(l)
	if len == 0 || len == 1 {
		return []*Employee{}
	}

	newList := make([]*Employee, len-1)

	for i, v := range l[1:] {
		newList[i] = v
	}

	return newList
}

func Reduce(f func(Employee, Employee) Employee, list []Employee, initializer ...Employee) Employee {
	var init Employee 
	lenList := len(list)

	if initializer != nil {
		init = initializer[0]
	} else if lenList > 0 {
		init = list[0]
		if lenList == 1 {
			return list[0]
		}
		if lenList >= 2 {
			list = list[1:]
		}
	}
	
	if lenList == 0 {
		return init
	}
	r := f(init, list[0])
	return Reduce(f, list[1:], r)
}

func ReducePtr(f func(*Employee, *Employee) *Employee, list []*Employee, initializer ...Employee) *Employee {
	var initVal Employee
	var init *Employee = &initVal
	lenList := len(list)

	if initializer != nil {
		init = &initializer[0]
	} else if lenList > 0 {
		init = list[0]
		if lenList == 1 {
			return list[0]
		}
		if lenList >= 2 {
			list = list[1:]
		}
	}

	if lenList == 0 {
		return init
	}

	r := f(init, list[0])
	return ReducePtr(f, list[1:], *r)
}

// ReducePtrErr reduces a list to a single value by combining elements via a supplied function
//
// Takes three inputs
//	A. function - takes two arguments (*Employee, *Employee)
//	B. list of type []*Employee
// 	C. initializer (optional of type Employee)
//
// Returns:
//	single value, error: (*Employee, error)
func ReducePtrErr(f func(*Employee, *Employee) (*Employee, error), list []*Employee, initializer ...Employee) (*Employee, error) {
	var initVal Employee
	var init *Employee = &initVal
	lenList := len(list)

	if initializer != nil {
		init = &initializer[0]
	} else if lenList > 0 {
		init = list[0]
		if lenList == 1 {
			return list[0], nil
		}
		if lenList >= 2 {
			list = list[1:]
		}
	}

	if lenList == 0 {
		return init, nil
	}

	r, err := f(init, list[0])
	if err != nil {
		return nil, err
	}
	return ReducePtrErr(f, list[1:], *r)
}

// ReduceErr reduces a list to a single value by combining elements via a supplied function
//
// Takes three inputs
//	A. function - takes two arguments (Employee, Employee)
//	B. list of type []Employee
// 	C. initializer (optional of type Employee)
//
// Returns:
//	single value, error: (Employee, error)
func ReduceErr(f func(Employee, Employee) (Employee, error), list []Employee, initializer ...Employee) (Employee, error) {
	var initVal Employee
	var init Employee = initVal
	lenList := len(list)

	if initializer != nil {
		init = initializer[0]
	} else if lenList > 0 {
		init = list[0]
		if lenList == 1 {
			return list[0], nil
		}
		if lenList >= 2 {
			list = list[1:]
		}
	}

	if lenList == 0 {
		return init, nil
	}

	r, err := f(init, list[0])
	if err != nil {
		return r, err
	}
	return ReduceErr(f, list[1:], r)
}

// DropLast drops last item from the list and returns new list.
// Returns empty list if there is only one item in the list or list empty
func DropLast(list []Employee) []Employee {
	listLen := len(list)

	if list == nil || listLen == 0 || listLen == 1 {
		return []Employee{}
	}

	newList := make([]Employee, listLen-1)

	for i := 0; i < listLen-1; i++ {
		newList[i] = list[i]
	}
	return newList
}

// DropLastPtr drops last item from the list and returns new list.
// Returns empty list if there is only one item in the list or list empty
func DropLastPtr(list []*Employee) []*Employee {
	listLen := len(list)

	if list == nil || listLen == 0 || listLen == 1 {
		return []*Employee{}
	}

	newList := make([]*Employee, listLen-1)

	for i := 0; i < listLen-1; i++ {
		newList[i] = list[i]
	}
	return newList
}

// Reverses reverse the list
func Reverses(list []Employee) []Employee {
	newList := make([]Employee, len(list))
	for i := 0; i < len(list); i++ {
		newList[i] = list[len(list)-(i+1)]
	}
	return newList
}

// ReversesPtr reverse the list
func ReversesPtr(list []*Employee) []*Employee {
	newList := make([]*Employee, len(list))
	for i := 0; i < len(list); i++ {
		newList[i] = list[len(list)-(i+1)]
	}
	return newList
}

// Take returns n items in the list
func Take(n int, list []Employee) []Employee {
	if n < 0 {
		return []Employee{}
	}

	newListLen := len(list)

	if n < newListLen {
		newListLen = n
	}
	newList := make([]Employee, newListLen)
	for i := 0; i < newListLen; i++ {
		newList[i] = list[i]
	}
	return newList
}

// TakePtr returns n items in the list
func TakePtr(n int, list []*Employee) []*Employee {
	if n < 0 {
		return []*Employee{}
	}

	newListLen := len(list)

	if n < newListLen {
		newListLen = n
	}
	newList := make([]*Employee, newListLen)
	for i := 0; i < newListLen; i++ {
		newList[i] = list[i]
	}
	return newList
}

func MapTeacher(f func(Teacher) Teacher, list []Teacher) []Teacher {
	if f == nil {
		return []Teacher{}
	}
	newList := make([]Teacher, len(list))
	for i, v := range list {
		newList[i] = f(v)
	}
	return newList
}

func MapTeacherPtr(f func(*Teacher) *Teacher, list []*Teacher) []*Teacher {
	if f == nil {
		return []*Teacher{}
	}
	newList := make([]*Teacher, len(list))
	for i, v := range list {
		newList[i] = f(v)
	}
	return newList
}

// MapTeacherPtrErr takes 2 arguments:
//  1. A function input argument: *Teacher and return types (*Teacher, error)
//  2. A list of type []*Teacher
//
// Returns:
// 	([]*Teacher, error)
func MapTeacherPtrErr(f func(*Teacher) (*Teacher, error), list []*Teacher) ([]*Teacher, error) {
	if f == nil {
		return []*Teacher{}, nil
	}
	newList := make([]*Teacher, len(list))
	for i, v := range list {
		var err error
		newList[i], err = f(v)
		if err != nil {
			return nil, err
		}
	}
	return newList, nil
}

// MapTeacherErr takes 2 arguments:
//  1. A function input argument: Teacher and return types (Teacher, error)
//  2. A list of type []Teacher
//
// Returns:
// 	([]Teacher, error)
func MapTeacherErr(f func(Teacher) (Teacher, error), list []Teacher) ([]Teacher, error) {
	if f == nil {
		return []Teacher{}, nil
	}
	newList := make([]Teacher, len(list))
	for i, v := range list {
		var err error
		newList[i], err = f(v)
		if err != nil {
			return nil, err
		}
	}
	return newList, nil
}

func FilterTeacher(f func(Teacher) bool, list []Teacher) []Teacher {
	if f == nil {
		return []Teacher{}
	}
	var newList []Teacher
	for _, v := range list {
		if f(v) {
			newList = append(newList, v)
		}
	}
	return newList
}

func FilterTeacherPtr(f func(*Teacher) bool, list []*Teacher) []*Teacher {
	if f == nil {
		return []*Teacher{}
	}
	var newList []*Teacher
	for _, v := range list {
		if f(v) {
			newList = append(newList, v)
		}
	}
	return newList
}

// FilterTeacherPtrErr takes two arguments
//  1. Function: takes 1 argument of type Teacher and returns (bool, error)
//  2. slice of type []*Teacher
//
// Returns:
//  new filtered list and error
func FilterTeacherPtrErr(f func(*Teacher) (bool, error), list []*Teacher) ([]*Teacher, error) {
	if f == nil {
		return []*Teacher{}, nil
	}
	var newList []*Teacher
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if r {
			newList = append(newList, v)
		}
	}
	return newList, nil
}

// FilterTeacherErr takes two arguments
//  1. Function: takes 1 argument of type Teacher and returns (bool, error)
//  2. slice of type []Teacher
//
// Returns:
//  new filtered list and error
func FilterTeacherErr(f func(Teacher) (bool, error), list []Teacher) ([]Teacher, error) {
	if f == nil {
		return []Teacher{}, nil
	}
	var newList []Teacher
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if r {
			newList = append(newList, v)
		}
	}
	return newList, nil
}

func RemoveTeacher(f func(Teacher) bool, list []Teacher) []Teacher {
	if f == nil {
		return []Teacher{}
	}
	var newList []Teacher
	for _, v := range list {
		if !f(v) {
			newList = append(newList, v)
		}
	}
	return newList
}

func RemoveTeacherPtr(f func(*Teacher) bool, list []*Teacher) []*Teacher {
	if f == nil {
		return []*Teacher{}
	}
	var newList []*Teacher
	for _, v := range list {
		if !f(v) {
			newList = append(newList, v)
		}
	}
	return newList
}

// RemoveTeacherPtrErr removes the items from the given list based on supplied function and returns new list
//
// Takes 2 inputs:
//	1. Function: input type *Teacher and return types(bool, error)
//	2. List of type: []*Teacher
//
// Returns:
//	New list and error: ([]*Teacher, error)
//	Empty list if both of arguments are nil or either one is nil.
func RemoveTeacherPtrErr(f func(*Teacher) (bool, error), list []*Teacher) ([]*Teacher, error) {
	if f == nil {
		return []*Teacher{}, nil
	}
	var newList []*Teacher
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if !r {
			newList = append(newList, v)
		}
	}
	return newList, nil
}

// RemoveTeacherErr removes the items from the given list based on supplied function and returns new list
//
// Takes 2 inputs:
//	1. Function: input type Teacher and return types(bool, error)
//	2. List of type: []Teacher
//
// Returns:
//	New list and error: ([]Teacher, error)
//	Empty list if both of arguments are nil or either one is nil.
func RemoveTeacherErr(f func(Teacher) (bool, error), list []Teacher) ([]Teacher, error) {
	if f == nil {
		return []Teacher{}, nil
	}
	var newList []Teacher
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if !r {
			newList = append(newList, v)
		}
	}
	return newList, nil
}

func SomeTeacher(f func(Teacher) bool, list []Teacher) bool {
	if f == nil {
		return false
	}
	for _, v := range list {
		if f(v) {
			return true
		}
	}
	return false
}

func SomeTeacherPtr(f func(*Teacher) bool, list []*Teacher) bool {
	if f == nil {
		return false
	}
	for _, v := range list {
		if f(v) {
			return true
		}
	}
	return false
}

// SomeTeacherPtrErr finds item in the list based on supplied function.
//
// Takes 2 input:
//	1. Function
//	2. List
//
// Returns:
//	(bool,err).
//	True if condition satisfies, else false
func SomeTeacherPtrErr(f func(*Teacher) (bool, error), list []*Teacher) (bool, error) {
	if f == nil {
		return false, nil
	}
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return false, err
		}
		if r {
			return true, nil
		}
	}
	return false, nil
}

// SomeTeacherErr finds item in the list based on supplied function.
//
// Takes 2 input:
//	1. Function
//	2. List
//
// Returns:
//	(bool,err).
//	True if condition satisfies, else false
func SomeTeacherErr(f func(Teacher) (bool, error), list []Teacher) (bool, error) {
	if f == nil {
		return false, nil
	}
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return false, err
		}
		if r {
			return true, nil
		}
	}
	return false, nil
}

func EveryTeacher(f func(Teacher) bool, list []Teacher) bool {
	if f == nil || len(list) == 0 {
		return false
	}
	for _, v := range list {
		if !f(v) {
			return false
		}
	}
	return true
}

func EveryTeacherPtr(f func(*Teacher) bool, list []*Teacher) bool {
	if f == nil || len(list) == 0 {
		return false
	}
	for _, v := range list {
		if !f(v) {
			return false
		}
	}
	return true
}

// EveryTeacherPtrErr returns true if supplied function returns logical true for every item in the list
func EveryTeacherPtrErr(f func(*Teacher) (bool, error), list []*Teacher) (bool, error) {
	if f == nil || len(list) == 0 {
		return false, nil
	}
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return false, err
		}
		if !r {
			return false, nil
		}
	}
	return true, nil
}

// EveryTeacherErr returns true if supplied function returns logical true for every item in the list
func EveryTeacherErr(f func(Teacher) (bool, error), list []Teacher) (bool, error) {
	if f == nil || len(list) == 0 {
		return false, nil
	}
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return false, err
		}
		if !r {
			return false, nil
		}
	}
	return true, nil
}

func DropWhileTeacher(f func(Teacher) bool, list []Teacher) []Teacher {
	if f == nil {
		return []Teacher{}
	}
	var newList []Teacher
	for i, v := range list {
		if !f(v) {
			listLen := len(list)
			newList = make([]Teacher, listLen-i)
			j := 0
			for i < listLen {
				newList[j] = list[i]
				i++
				j++
			}
			return newList
		}
	}
	return newList
}

func DropWhileTeacherPtr(f func(*Teacher) bool, list []*Teacher) []*Teacher {
	if f == nil {
		return []*Teacher{}
	}
	var newList []*Teacher
	for i, v := range list {
		if !f(v) {
			listLen := len(list)
			newList = make([]*Teacher, listLen-i)
			j := 0
			for i < listLen {
				newList[j] = list[i]
				i++
				j++
			}
			return newList
		}
	}
	return newList
}

// DropWhileTeacherPtrErr drops the items from the list as long as condition satisfies.
//
// Takes two inputs
//	1. Function: takes one input and returns (boolean, error)
//	2. list
//
// Returns:
// 	New List, error
//  Empty list if either one of arguments or both of them are nil
func DropWhileTeacherPtrErr(f func(*Teacher) (bool, error), list []*Teacher) ([]*Teacher, error) {
	if f == nil {
		return []*Teacher{}, nil
	}
	var newList []*Teacher
	for i, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if !r {
			listLen := len(list)
			newList = make([]*Teacher, listLen-i)
			j := 0
			for i < listLen {
				newList[j] = list[i]
				i++
				j++
			}
			return newList, nil
		}
	}
	return newList, nil
}

// DropWhileTeacherErr drops the items from the list as long as condition satisfies.
//
// Takes two inputs
//	1. Function: takes one input and returns (boolean, error)
//	2. list
//
// Returns:
// 	New List, error
//  Empty list if either one of arguments or both of them are nil
func DropWhileTeacherErr(f func(Teacher) (bool, error), list []Teacher) ([]Teacher, error) {
	if f == nil {
		return []Teacher{}, nil
	}
	var newList []Teacher
	for i, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if !r {
			listLen := len(list)
			newList = make([]Teacher, listLen-i)
			j := 0
			for i < listLen {
				newList[j] = list[i]
				i++
				j++
			}
			return newList, nil
		}
	}
	return newList, nil
}

func TakeWhileTeacher(f func(Teacher) bool, list []Teacher) []Teacher {
	if f == nil {
		return []Teacher{}
	}
	var newList []Teacher
	for _, v := range list {
		if !f(v) {
			return newList
		}
		newList = append(newList, v)
	}
	return newList
}

func TakeWhileTeacherPtr(f func(*Teacher) bool, list []*Teacher) []*Teacher {
	if f == nil {
		return []*Teacher{}
	}
	var newList []*Teacher
	for _, v := range list {
		if !f(v) {
			return newList
		}
		newList = append(newList, v)
	}
	return newList
}

// TakeWhileTeacherPtrErr returns new list based on condition in the supplied function. It returns new list once condition fails.
//
// Takes 2 inputs:
//	1. Function - 1 input of type *Teacher and returns ([]*Teacher, error)
//	2. List
//
// Returns:
//	New List, error.
//	Empty list if all the parameters are nil or either of one parameter is nil
func TakeWhileTeacherPtrErr(f func(*Teacher) (bool, error), list []*Teacher) ([]*Teacher, error) {
	if f == nil {
		return []*Teacher{}, nil
	}
	var newList []*Teacher
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if !r {
			return newList, nil
		}
		newList = append(newList, v)
	}
	return newList, nil
}

// TakeWhileTeacherErr returns new list based on condition in the supplied function. It returns new list once condition fails.
//
// Takes 2 inputs:
//	1. Function - 1 input of type Teacher and returns ([]Teacher, error)
//	2. List
//
// Returns:
//	New List, error.
//	Empty list if all the parameters are nil or either of one parameter is nil
func TakeWhileTeacherErr(f func(Teacher) (bool, error), list []Teacher) ([]Teacher, error) {
	if f == nil {
		return []Teacher{}, nil
	}
	var newList []Teacher
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if !r {
			return newList, nil
		}
		newList = append(newList, v)
	}
	return newList, nil
}

func PMapTeacher(f func(Teacher) Teacher, list []Teacher) []Teacher {
	if f == nil {
		return []Teacher{}
	}

	ch := make(chan map[int]Teacher)
	var wg sync.WaitGroup

	for i, v := range list {
		wg.Add(1)

		go func(wg *sync.WaitGroup, ch chan map[int]Teacher, i int, v Teacher) {
			defer wg.Done()
			ch <- map[int]Teacher{i: f(v)}
		}(&wg, ch, i, v)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	newList := make([]Teacher, len(list))
	for m := range ch {
		for k, v := range m {
			newList[k] = v
		}
	}
	return newList
}

// PMapTeacherPtr applies the function(1st argument) on each item of the list and returns new list.
// Run in parallel. no_of_goroutines = no_of_items_in_list
func PMapTeacherPtr(f func(*Teacher) *Teacher, list []*Teacher) []*Teacher {
	if f == nil {
		return []*Teacher{}
	}

	ch := make(chan map[int]*Teacher)
	var wg sync.WaitGroup

	for i, v := range list {
		wg.Add(1)

		go func(wg *sync.WaitGroup, ch chan map[int]*Teacher, i int, v *Teacher) {
			defer wg.Done()
			ch <- map[int]*Teacher{i: f(v)}
		}(&wg, ch, i, v)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	newList := make([]*Teacher, len(list))
	for m := range ch {
		for k, v := range m {
			newList[k] = v
		}
	}
	return newList
}

// PMapTeacherPtrErr applies the function(1st argument) on each item of the list and returns new list.
// Run in parallel. no_of_goroutines = no_of_items_in_list
func PMapTeacherPtrErr(f func(*Teacher) (*Teacher, error), list []*Teacher) ([]*Teacher, error) {
	if f == nil {
		return []*Teacher{}, nil
	}

	ch := make(chan map[int]*Teacher, len(list))
	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i, v := range list {
		wg.Add(1)

		go func(wg *sync.WaitGroup, ch chan map[int]*Teacher, i int, v *Teacher) {
			defer wg.Done()
			if len(errCh) >= 1 {
				return
			}
			r, err := f(v)
			if err != nil {
				errCh <- err
				return
			}
			ch <- map[int]*Teacher{i: r}
		}(&wg, ch, i, v)
	}

	wg.Wait()
	close(ch)
	close(errCh)

	for err := range errCh {
		if err != nil {
			return nil, err
		}
	}

	newList := make([]*Teacher, len(list))
	for m := range ch {
		for k, v := range m {
			newList[k] = v
		}
	}
	return newList, nil
}

// PMapTeacherErr applies the function(1st argument) on each item of the list and returns new list.
// Run in parallel. no_of_goroutines = no_of_items_in_list
func PMapTeacherErr(f func(Teacher) (Teacher, error), list []Teacher) ([]Teacher, error) {
	if f == nil {
		return []Teacher{}, nil
	}

	ch := make(chan map[int]Teacher, len(list))
	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i, v := range list {
		wg.Add(1)

		go func(wg *sync.WaitGroup, ch chan map[int]Teacher, i int, v Teacher) {
			defer wg.Done()
			if len(errCh) >= 1 {
				return
			}
			r, err := f(v)
			if err != nil {
				errCh <- err
				return
			}
			ch <- map[int]Teacher{i: r}
		}(&wg, ch, i, v)
	}

	wg.Wait()
	close(ch)
	close(errCh)

	for err := range errCh {
		if err != nil {
			return nil, err
		}
	}

	newList := make([]Teacher, len(list))
	for m := range ch {
		for k, v := range m {
			newList[k] = v
		}
	}
	return newList, nil
}

func FilterMapTeacher(fFilter func(Teacher) bool, fMap func(Teacher) Teacher, list []Teacher) []Teacher {
	if fFilter == nil || fMap == nil {
		return []Teacher{}
	}
	var newList []Teacher
	for _, v := range list {
		if fFilter(v) {
			newList = append(newList, fMap(v))
		}
	}
	return newList
}

func FilterMapTeacherPtr(fFilter func(*Teacher) bool, fMap func(*Teacher) *Teacher, list []*Teacher) []*Teacher {
	if fFilter == nil || fMap == nil {
		return []*Teacher{}
	}
	var newList []*Teacher
	for _, v := range list {
		if fFilter(v) {
			newList = append(newList, fMap(v))
		}
	}
	return newList
}

// FilterMapTeacherPtrErr filters given list, then apply function(2nd argument) on each item in the list and returns a new list
// Takes 3 inputs
//	1. Function: takes one input(*Teacher) and returns (bool, error).
//	2. Function: takes *Teacher as argument and returns (*Teacher, error)
// 	3. Slice of type []*Teacher
//
// Returns:
//	New List ([]*Teacher, error).
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapTeacherPtrErr(fFilter func(*Teacher) (bool, error), fMap func(*Teacher) (*Teacher, error), list []*Teacher) ([]*Teacher, error) {
	if fFilter == nil || fMap == nil {
		return []*Teacher{}, nil
	}
	var newList []*Teacher
	for _, v := range list {
		r, err := fFilter(v)
		if err != nil {
			return nil, err
		}
		if r {
			r, err := fMap(v)
			if err != nil {
				return nil, err
			}
			newList = append(newList, r)
		}
	}
	return newList, nil
}

// FilterMapTeacherErr filters given list, then apply function(2nd argument) on each item in the list and returns a new list
// Takes 3 inputs
//	1. Function: takes one input(Teacher) and returns (bool, error).
//	2. Function: takes Teacher as argument and returns (Teacher, error)
// 	3. Slice of type []Teacher
//
// Returns:
//	New List ([]Teacher, error).
//  Empty list if all there parameters are nil or either of parameter is nil
//
func FilterMapTeacherErr(fFilter func(Teacher) (bool, error), fMap func(Teacher) (Teacher, error), list []Teacher) ([]Teacher, error) {
	if fFilter == nil || fMap == nil {
		return []Teacher{}, nil
	}
	var newList []Teacher
	for _, v := range list {
		r, err := fFilter(v)
		if err != nil {
			return nil, err
		}
		if r {
			r, err := fMap(v)
			if err != nil {
				return nil, err
			}
			newList = append(newList, r)
		}
	}
	return newList, nil
}

func RestTeacher(l []Teacher) []Teacher {
	if l == nil {
		return []Teacher{}
	}

	len := len(l)
	if len == 0 || len == 1 {
		return []Teacher{}
	}

	newList := make([]Teacher, len-1)

	for i, v := range l[1:] {
		newList[i] = v
	}

	return newList
}


// RestTeacher removes 1st item of the list and return new list having rest of the items
func RestTeacherPtr(l []*Teacher) []*Teacher {
	if l == nil {
		return []*Teacher{}
	}

	len := len(l)
	if len == 0 || len == 1 {
		return []*Teacher{}
	}

	newList := make([]*Teacher, len-1)

	for i, v := range l[1:] {
		newList[i] = v
	}

	return newList
}

func ReduceTeacher(f func(Teacher, Teacher) Teacher, list []Teacher, initializer ...Teacher) Teacher {
	var init Teacher 
	lenList := len(list)

	if initializer != nil {
		init = initializer[0]
	} else if lenList > 0 {
		init = list[0]
		if lenList == 1 {
			return list[0]
		}
		if lenList >= 2 {
			list = list[1:]
		}
	}
	
	if lenList == 0 {
		return init
	}
	r := f(init, list[0])
	return ReduceTeacher(f, list[1:], r)
}

func ReduceTeacherPtr(f func(*Teacher, *Teacher) *Teacher, list []*Teacher, initializer ...Teacher) *Teacher {
	var initVal Teacher
	var init *Teacher = &initVal
	lenList := len(list)

	if initializer != nil {
		init = &initializer[0]
	} else if lenList > 0 {
		init = list[0]
		if lenList == 1 {
			return list[0]
		}
		if lenList >= 2 {
			list = list[1:]
		}
	}

	if lenList == 0 {
		return init
	}

	r := f(init, list[0])
	return ReduceTeacherPtr(f, list[1:], *r)
}

// ReduceTeacherPtrErr reduces a list to a single value by combining elements via a supplied function
//
// Takes three inputs
//	A. function - takes two arguments (*Teacher, *Teacher)
//	B. list of type []*Teacher
// 	C. initializer (optional of type Teacher)
//
// Returns:
//	single value, error: (*Teacher, error)
func ReduceTeacherPtrErr(f func(*Teacher, *Teacher) (*Teacher, error), list []*Teacher, initializer ...Teacher) (*Teacher, error) {
	var initVal Teacher
	var init *Teacher = &initVal
	lenList := len(list)

	if initializer != nil {
		init = &initializer[0]
	} else if lenList > 0 {
		init = list[0]
		if lenList == 1 {
			return list[0], nil
		}
		if lenList >= 2 {
			list = list[1:]
		}
	}

	if lenList == 0 {
		return init, nil
	}

	r, err := f(init, list[0])
	if err != nil {
		return nil, err
	}
	return ReduceTeacherPtrErr(f, list[1:], *r)
}

// ReduceTeacherErr reduces a list to a single value by combining elements via a supplied function
//
// Takes three inputs
//	A. function - takes two arguments (Teacher, Teacher)
//	B. list of type []Teacher
// 	C. initializer (optional of type Teacher)
//
// Returns:
//	single value, error: (Teacher, error)
func ReduceTeacherErr(f func(Teacher, Teacher) (Teacher, error), list []Teacher, initializer ...Teacher) (Teacher, error) {
	var initVal Teacher
	var init Teacher = initVal
	lenList := len(list)

	if initializer != nil {
		init = initializer[0]
	} else if lenList > 0 {
		init = list[0]
		if lenList == 1 {
			return list[0], nil
		}
		if lenList >= 2 {
			list = list[1:]
		}
	}

	if lenList == 0 {
		return init, nil
	}

	r, err := f(init, list[0])
	if err != nil {
		return r, err
	}
	return ReduceTeacherErr(f, list[1:], r)
}

// DropLastTeacher drops last item from the list and returns new list.
// Returns empty list if there is only one item in the list or list empty
func DropLastTeacher(list []Teacher) []Teacher {
	listLen := len(list)

	if list == nil || listLen == 0 || listLen == 1 {
		return []Teacher{}
	}

	newList := make([]Teacher, listLen-1)

	for i := 0; i < listLen-1; i++ {
		newList[i] = list[i]
	}
	return newList
}

// DropLastTeacherPtr drops last item from the list and returns new list.
// Returns empty list if there is only one item in the list or list empty
func DropLastTeacherPtr(list []*Teacher) []*Teacher {
	listLen := len(list)

	if list == nil || listLen == 0 || listLen == 1 {
		return []*Teacher{}
	}

	newList := make([]*Teacher, listLen-1)

	for i := 0; i < listLen-1; i++ {
		newList[i] = list[i]
	}
	return newList
}

// ReverseTeachers reverse the list
func ReverseTeachers(list []Teacher) []Teacher {
	newList := make([]Teacher, len(list))
	for i := 0; i < len(list); i++ {
		newList[i] = list[len(list)-(i+1)]
	}
	return newList
}

// ReverseTeachersPtr reverse the list
func ReverseTeachersPtr(list []*Teacher) []*Teacher {
	newList := make([]*Teacher, len(list))
	for i := 0; i < len(list); i++ {
		newList[i] = list[len(list)-(i+1)]
	}
	return newList
}

// TakeTeacher returns n items in the list
func TakeTeacher(n int, list []Teacher) []Teacher {
	if n < 0 {
		return []Teacher{}
	}

	newListLen := len(list)

	if n < newListLen {
		newListLen = n
	}
	newList := make([]Teacher, newListLen)
	for i := 0; i < newListLen; i++ {
		newList[i] = list[i]
	}
	return newList
}

// TakeTeacherPtr returns n items in the list
func TakeTeacherPtr(n int, list []*Teacher) []*Teacher {
	if n < 0 {
		return []*Teacher{}
	}

	newListLen := len(list)

	if n < newListLen {
		newListLen = n
	}
	newList := make([]*Teacher, newListLen)
	for i := 0; i < newListLen; i++ {
		newList[i] = list[i]
	}
	return newList
}


// MapEmployeeTeacher takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list
func MapEmployeeTeacher(f func(Employee) Teacher, list []Employee) []Teacher {
	if f == nil {
		return []Teacher{}
	}
	newList := make([]Teacher, len(list))
	for i, v := range list {
		newList[i] = f(v)
	}
	return newList
}

// MapEmployeeTeacherErr takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list and error
func MapEmployeeTeacherErr(f func(Employee) (Teacher, error), list []Employee) ([]Teacher, error) {
	if f == nil {
		return []Teacher{}, nil
	}
	newList := make([]Teacher, len(list))
	for i, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		newList[i] = r
	}
	return newList, nil
}

// MapEmployeeTeacherPtr takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list
func MapEmployeeTeacherPtr(f func(*Employee) *Teacher, list []*Employee) []*Teacher {
	if f == nil {
		return []*Teacher{}
	}
	newList := make([]*Teacher, len(list))
	for i, v := range list {
		newList[i] = f(v)
	}
	return newList
}

// MapEmployeeTeacherPtrErr takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list, error
func MapEmployeeTeacherPtrErr(f func(*Employee) (*Teacher, error), list []*Employee) ([]*Teacher, error) {
	if f == nil {
		return []*Teacher{}, nil
	}
	newList := make([]*Teacher, len(list))
	for i, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		newList[i] = r
	}
	return newList, nil
}

// PMapEmployeeTeacher applies the function(1st argument) on each item of the list and returns new list.
// Run in parallel. no_of_goroutines = no_of_items_in_list
//
// Takes 2 inputs
//	1. Function - takes 1 input type: Employee output type: Teacher
//	2. List
//
// Returns
//	New List of type Teacher
//	Empty list if all arguments are nil or either one is nil
func PMapEmployeeTeacher(f func(Employee) Teacher, list []Employee) []Teacher {
	if f == nil {
		return []Teacher{}
	}

	ch := make(chan map[int]Teacher)
	var wg sync.WaitGroup

	for i, v := range list {
		wg.Add(1)

		go func(wg *sync.WaitGroup, ch chan map[int]Teacher, i int, v Employee) {
			defer wg.Done()
			ch <- map[int]Teacher{i: f(v)}
		}(&wg, ch, i, v)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	newList := make([]Teacher, len(list))
	for m := range ch {
		for k, v := range m {
			newList[k] = v
		}
	}
	return newList
}

// PMapEmployeeTeacherErr applies the function(1st argument) on each item of the list and returns new list and error.
// Run in parallel. no_of_goroutines = no_of_items_in_list
//
// Takes 2 inputs
//	1. Function - takes 1 input type: Employee output type: (Teacher, error)
//	2. List
//
// Returns
//	New List of type (Teacher, error)
//	Empty list if all arguments are nil or either one is nil
func PMapEmployeeTeacherErr(f func(Employee) (Teacher, error), list []Employee) ([]Teacher, error) {
	if f == nil {
		return []Teacher{}, nil
	}

	ch := make(chan map[int]Teacher, len(list))
	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i, v := range list {
		wg.Add(1)

		go func(wg *sync.WaitGroup, ch chan map[int]Teacher, i int, v Employee) {
			defer wg.Done()
			if len(errCh) >= 1 {
				return
			}
			r, err := f(v)
			if err != nil {
				errCh <- err
				return
			}
			ch <- map[int]Teacher{i: r}
		}(&wg, ch, i, v)
	}

	wg.Wait()
	close(ch)
	close(errCh)

	for err := range errCh {
		if err != nil {
			return nil, err
		}
	}

	newList := make([]Teacher, len(list))
	for m := range ch {
		for k, v := range m {
			newList[k] = v
		}
	}
	return newList, nil
}

// PMapEmployeeTeacherPtr applies the function(1st argument) on each item of the list and returns new list.
// Run in parallel. no_of_goroutines = no_of_items_in_list
//
// Takes 2 inputs
//	1. Function - takes 1 input type: *Employee output type: *Teacher
//	2. List
//
// Returns
//	New List of type *Teacher
//	Empty list if all arguments are nil or either one is nil
func PMapEmployeeTeacherPtr(f func(*Employee) *Teacher, list []*Employee) []*Teacher {
	if f == nil {
		return []*Teacher{}
	}

	ch := make(chan map[int]*Teacher)
	var wg sync.WaitGroup

	for i, v := range list {
		wg.Add(1)

		go func(wg *sync.WaitGroup, ch chan map[int]*Teacher, i int, v *Employee) {
			defer wg.Done()
			ch <- map[int]*Teacher{i: f(v)}
		}(&wg, ch, i, v)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	newList := make([]*Teacher, len(list))
	for m := range ch {
		for k, v := range m {
			newList[k] = v
		}
	}
	return newList
}

// PMapEmployeeTeacherPtrErr applies the function(1st argument) on each item of the list and returns new list and error.
// Run in parallel. no_of_goroutines = no_of_items_in_list
//
// Takes 2 inputs
//	1. Function - takes 1 input type: *Employee output type: (*Teacher, error)
//	2. List
//
// Returns
//	New List of type (*Teacher, error)
//	Empty list if all arguments are nil or either one is nil
func PMapEmployeeTeacherPtrErr(f func(*Employee) (*Teacher, error), list []*Employee) ([]*Teacher, error) {
	if f == nil {
		return []*Teacher{}, nil
	}

	ch := make(chan map[int]*Teacher, len(list))
	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i, v := range list {
		wg.Add(1)

		go func(wg *sync.WaitGroup, ch chan map[int]*Teacher, i int, v *Employee) {
			defer wg.Done()
			if len(errCh) >= 1 {
				return
			}
			r, err := f(v)
			if err != nil {
				errCh <- err
				return
			}
			ch <- map[int]*Teacher{i: r}
		}(&wg, ch, i, v)
	}

	wg.Wait()
	close(ch)
	close(errCh)
	
	for err := range errCh {
		if err != nil {
			return nil, err
		}
	}

	newList := make([]*Teacher, len(list))
	for m := range ch {
		for k, v := range m {
			newList[k] = v
		}
	}
	return newList, nil
}

// FilterMapEmployeeTeacher filters given list, then apply function(2nd argument) on each item in the list and returns a new list
// Takes 3 inputs
//	1. Function: takes one input type - Employee and returns true/false.
//	2. Function: takes Employee as argument and returns Teacher
// 	3. List of type Employee
//
// Returns:
//	New List of type Teacher
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapEmployeeTeacher(fFilter func(Employee) bool, fMap func(Employee) Teacher, list []Employee) []Teacher {
	if fFilter == nil || fMap == nil {
		return []Teacher{}
	}
	var newList []Teacher
	for _, v := range list {
		if fFilter(v) {
			newList = append(newList, fMap(v))
		}
	}
	return newList
}

// FilterMapEmployeeTeacherPtrErr filters given list, then apply function(2nd argument) on each item in the list and returns a new list, error
// Takes 3 inputs
//	1. Function: takes one input type - *Employee and returns (bool, error).
//	2. Function: takes *Employee as argument and returns (*Teacher, error)
// 	3. List of type *Employee
//
// Returns:
//	New List of type *Teacher, error
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapEmployeeTeacherPtrErr(fFilter func(*Employee) (bool, error), fMap func(*Employee) (*Teacher, error), list []*Employee) ([]*Teacher, error) {
	if fFilter == nil || fMap == nil {
		return []*Teacher{}, nil
	}
	var newList []*Teacher
	for _, v := range list {
		r, err := fFilter(v)
		if err != nil {
			return nil, err
		}
		if r {
			r, err := fMap(v)
			if err != nil {
				return nil, err
			}
			newList = append(newList, r)
		}
	}
	return newList, nil
}

// FilterMapEmployeeTeacherErr filters given list, then apply function(2nd argument) on each item in the list and returns a new list, error
// Takes 3 inputs
//	1. Function: takes one input type - Employee and returns (bool, error).
//	2. Function: takes Employee as argument and returns (Teacher, error)
// 	3. List of type Employee
//
// Returns:
//	New List of type Teacher, error
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapEmployeeTeacherErr(fFilter func(Employee) (bool, error), fMap func(Employee) (Teacher, error), list []Employee) ([]Teacher, error) {
	if fFilter == nil || fMap == nil {
		return []Teacher{}, nil
	}
	var newList []Teacher
	for _, v := range list {
		r, err := fFilter(v)
		if err != nil {
			return nil, err
		}
		if r {
			r, err := fMap(v)
			if err != nil {
				return nil, err
			}
			newList = append(newList, r)
		}
	}
	return newList, nil
}

// MapEmployeeInt takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list
func MapEmployeeInt(f func(Employee) int, list []Employee) []int {
	if f == nil {
		return []int{}
	}
	newList := make([]int, len(list))
	for i, v := range list {
		newList[i] = f(v)
	}
	return newList
}

// MapEmployeeIntErr takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list and error
func MapEmployeeIntErr(f func(Employee) (int, error), list []Employee) ([]int, error) {
	if f == nil {
		return []int{}, nil
	}
	newList := make([]int, len(list))
	for i, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		newList[i] = r
	}
	return newList, nil
}

// MapEmployeeIntPtr takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list
func MapEmployeeIntPtr(f func(*Employee) *int, list []*Employee) []*int {
	if f == nil {
		return []*int{}
	}
	newList := make([]*int, len(list))
	for i, v := range list {
		newList[i] = f(v)
	}
	return newList
}

// MapEmployeeIntPtrErr takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list, error
func MapEmployeeIntPtrErr(f func(*Employee) (*int, error), list []*Employee) ([]*int, error) {
	if f == nil {
		return []*int{}, nil
	}
	newList := make([]*int, len(list))
	for i, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		newList[i] = r
	}
	return newList, nil
}

// PMapEmployeeInt applies the function(1st argument) on each item of the list and returns new list.
// Run in parallel. no_of_goroutines = no_of_items_in_list
//
// Takes 2 inputs
//	1. Function - takes 1 input type: Employee output type: int
//	2. List
//
// Returns
//	New List of type int
//	Empty list if all arguments are nil or either one is nil
func PMapEmployeeInt(f func(Employee) int, list []Employee) []int {
	if f == nil {
		return []int{}
	}

	ch := make(chan map[int]int)
	var wg sync.WaitGroup

	for i, v := range list {
		wg.Add(1)

		go func(wg *sync.WaitGroup, ch chan map[int]int, i int, v Employee) {
			defer wg.Done()
			ch <- map[int]int{i: f(v)}
		}(&wg, ch, i, v)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	newList := make([]int, len(list))
	for m := range ch {
		for k, v := range m {
			newList[k] = v
		}
	}
	return newList
}

// PMapEmployeeIntErr applies the function(1st argument) on each item of the list and returns new list and error.
// Run in parallel. no_of_goroutines = no_of_items_in_list
//
// Takes 2 inputs
//	1. Function - takes 1 input type: Employee output type: (int, error)
//	2. List
//
// Returns
//	New List of type (int, error)
//	Empty list if all arguments are nil or either one is nil
func PMapEmployeeIntErr(f func(Employee) (int, error), list []Employee) ([]int, error) {
	if f == nil {
		return []int{}, nil
	}

	ch := make(chan map[int]int, len(list))
	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i, v := range list {
		wg.Add(1)

		go func(wg *sync.WaitGroup, ch chan map[int]int, i int, v Employee) {
			defer wg.Done()
			if len(errCh) >= 1 {
				return
			}
			r, err := f(v)
			if err != nil {
				errCh <- err
				return
			}
			ch <- map[int]int{i: r}
		}(&wg, ch, i, v)
	}

	wg.Wait()
	close(ch)
	close(errCh)

	for err := range errCh {
		if err != nil {
			return nil, err
		}
	}

	newList := make([]int, len(list))
	for m := range ch {
		for k, v := range m {
			newList[k] = v
		}
	}
	return newList, nil
}

// PMapEmployeeIntPtr applies the function(1st argument) on each item of the list and returns new list.
// Run in parallel. no_of_goroutines = no_of_items_in_list
//
// Takes 2 inputs
//	1. Function - takes 1 input type: *Employee output type: *int
//	2. List
//
// Returns
//	New List of type *int
//	Empty list if all arguments are nil or either one is nil
func PMapEmployeeIntPtr(f func(*Employee) *int, list []*Employee) []*int {
	if f == nil {
		return []*int{}
	}

	ch := make(chan map[int]*int)
	var wg sync.WaitGroup

	for i, v := range list {
		wg.Add(1)

		go func(wg *sync.WaitGroup, ch chan map[int]*int, i int, v *Employee) {
			defer wg.Done()
			ch <- map[int]*int{i: f(v)}
		}(&wg, ch, i, v)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	newList := make([]*int, len(list))
	for m := range ch {
		for k, v := range m {
			newList[k] = v
		}
	}
	return newList
}

// PMapEmployeeIntPtrErr applies the function(1st argument) on each item of the list and returns new list and error.
// Run in parallel. no_of_goroutines = no_of_items_in_list
//
// Takes 2 inputs
//	1. Function - takes 1 input type: *Employee output type: (*int, error)
//	2. List
//
// Returns
//	New List of type (*int, error)
//	Empty list if all arguments are nil or either one is nil
func PMapEmployeeIntPtrErr(f func(*Employee) (*int, error), list []*Employee) ([]*int, error) {
	if f == nil {
		return []*int{}, nil
	}

	ch := make(chan map[int]*int, len(list))
	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i, v := range list {
		wg.Add(1)

		go func(wg *sync.WaitGroup, ch chan map[int]*int, i int, v *Employee) {
			defer wg.Done()
			if len(errCh) >= 1 {
				return
			}
			r, err := f(v)
			if err != nil {
				errCh <- err
				return
			}
			ch <- map[int]*int{i: r}
		}(&wg, ch, i, v)
	}

	wg.Wait()
	close(ch)
	close(errCh)
	
	for err := range errCh {
		if err != nil {
			return nil, err
		}
	}

	newList := make([]*int, len(list))
	for m := range ch {
		for k, v := range m {
			newList[k] = v
		}
	}
	return newList, nil
}

// FilterMapEmployeeInt filters given list, then apply function(2nd argument) on each item in the list and returns a new list
// Takes 3 inputs
//	1. Function: takes one input type - Employee and returns true/false.
//	2. Function: takes Employee as argument and returns int
// 	3. List of type Employee
//
// Returns:
//	New List of type int
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapEmployeeInt(fFilter func(Employee) bool, fMap func(Employee) int, list []Employee) []int {
	if fFilter == nil || fMap == nil {
		return []int{}
	}
	var newList []int
	for _, v := range list {
		if fFilter(v) {
			newList = append(newList, fMap(v))
		}
	}
	return newList
}

// FilterMapEmployeeIntPtrErr filters given list, then apply function(2nd argument) on each item in the list and returns a new list, error
// Takes 3 inputs
//	1. Function: takes one input type - *Employee and returns (bool, error).
//	2. Function: takes *Employee as argument and returns (*int, error)
// 	3. List of type *Employee
//
// Returns:
//	New List of type *int, error
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapEmployeeIntPtrErr(fFilter func(*Employee) (bool, error), fMap func(*Employee) (*int, error), list []*Employee) ([]*int, error) {
	if fFilter == nil || fMap == nil {
		return []*int{}, nil
	}
	var newList []*int
	for _, v := range list {
		r, err := fFilter(v)
		if err != nil {
			return nil, err
		}
		if r {
			r, err := fMap(v)
			if err != nil {
				return nil, err
			}
			newList = append(newList, r)
		}
	}
	return newList, nil
}

// FilterMapEmployeeIntErr filters given list, then apply function(2nd argument) on each item in the list and returns a new list, error
// Takes 3 inputs
//	1. Function: takes one input type - Employee and returns (bool, error).
//	2. Function: takes Employee as argument and returns (int, error)
// 	3. List of type Employee
//
// Returns:
//	New List of type int, error
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapEmployeeIntErr(fFilter func(Employee) (bool, error), fMap func(Employee) (int, error), list []Employee) ([]int, error) {
	if fFilter == nil || fMap == nil {
		return []int{}, nil
	}
	var newList []int
	for _, v := range list {
		r, err := fFilter(v)
		if err != nil {
			return nil, err
		}
		if r {
			r, err := fMap(v)
			if err != nil {
				return nil, err
			}
			newList = append(newList, r)
		}
	}
	return newList, nil
}

// MapEmployeeStr takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list
func MapEmployeeStr(f func(Employee) string, list []Employee) []string {
	if f == nil {
		return []string{}
	}
	newList := make([]string, len(list))
	for i, v := range list {
		newList[i] = f(v)
	}
	return newList
}

// MapEmployeeStrErr takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list and error
func MapEmployeeStrErr(f func(Employee) (string, error), list []Employee) ([]string, error) {
	if f == nil {
		return []string{}, nil
	}
	newList := make([]string, len(list))
	for i, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		newList[i] = r
	}
	return newList, nil
}

// MapEmployeeStrPtr takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list
func MapEmployeeStrPtr(f func(*Employee) *string, list []*Employee) []*string {
	if f == nil {
		return []*string{}
	}
	newList := make([]*string, len(list))
	for i, v := range list {
		newList[i] = f(v)
	}
	return newList
}

// MapEmployeeStrPtrErr takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list, error
func MapEmployeeStrPtrErr(f func(*Employee) (*string, error), list []*Employee) ([]*string, error) {
	if f == nil {
		return []*string{}, nil
	}
	newList := make([]*string, len(list))
	for i, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		newList[i] = r
	}
	return newList, nil
}

// PMapEmployeeStr applies the function(1st argument) on each item of the list and returns new list.
// Run in parallel. no_of_goroutines = no_of_items_in_list
//
// Takes 2 inputs
//	1. Function - takes 1 input type: Employee output type: string
//	2. List
//
// Returns
//	New List of type string
//	Empty list if all arguments are nil or either one is nil
func PMapEmployeeStr(f func(Employee) string, list []Employee) []string {
	if f == nil {
		return []string{}
	}

	ch := make(chan map[int]string)
	var wg sync.WaitGroup

	for i, v := range list {
		wg.Add(1)

		go func(wg *sync.WaitGroup, ch chan map[int]string, i int, v Employee) {
			defer wg.Done()
			ch <- map[int]string{i: f(v)}
		}(&wg, ch, i, v)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	newList := make([]string, len(list))
	for m := range ch {
		for k, v := range m {
			newList[k] = v
		}
	}
	return newList
}

// PMapEmployeeStrErr applies the function(1st argument) on each item of the list and returns new list and error.
// Run in parallel. no_of_goroutines = no_of_items_in_list
//
// Takes 2 inputs
//	1. Function - takes 1 input type: Employee output type: (string, error)
//	2. List
//
// Returns
//	New List of type (string, error)
//	Empty list if all arguments are nil or either one is nil
func PMapEmployeeStrErr(f func(Employee) (string, error), list []Employee) ([]string, error) {
	if f == nil {
		return []string{}, nil
	}

	ch := make(chan map[int]string, len(list))
	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i, v := range list {
		wg.Add(1)

		go func(wg *sync.WaitGroup, ch chan map[int]string, i int, v Employee) {
			defer wg.Done()
			if len(errCh) >= 1 {
				return
			}
			r, err := f(v)
			if err != nil {
				errCh <- err
				return
			}
			ch <- map[int]string{i: r}
		}(&wg, ch, i, v)
	}

	wg.Wait()
	close(ch)
	close(errCh)

	for err := range errCh {
		if err != nil {
			return nil, err
		}
	}

	newList := make([]string, len(list))
	for m := range ch {
		for k, v := range m {
			newList[k] = v
		}
	}
	return newList, nil
}

// PMapEmployeeStrPtr applies the function(1st argument) on each item of the list and returns new list.
// Run in parallel. no_of_goroutines = no_of_items_in_list
//
// Takes 2 inputs
//	1. Function - takes 1 input type: *Employee output type: *string
//	2. List
//
// Returns
//	New List of type *string
//	Empty list if all arguments are nil or either one is nil
func PMapEmployeeStrPtr(f func(*Employee) *string, list []*Employee) []*string {
	if f == nil {
		return []*string{}
	}

	ch := make(chan map[int]*string)
	var wg sync.WaitGroup

	for i, v := range list {
		wg.Add(1)

		go func(wg *sync.WaitGroup, ch chan map[int]*string, i int, v *Employee) {
			defer wg.Done()
			ch <- map[int]*string{i: f(v)}
		}(&wg, ch, i, v)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	newList := make([]*string, len(list))
	for m := range ch {
		for k, v := range m {
			newList[k] = v
		}
	}
	return newList
}

// PMapEmployeeStrPtrErr applies the function(1st argument) on each item of the list and returns new list and error.
// Run in parallel. no_of_goroutines = no_of_items_in_list
//
// Takes 2 inputs
//	1. Function - takes 1 input type: *Employee output type: (*string, error)
//	2. List
//
// Returns
//	New List of type (*string, error)
//	Empty list if all arguments are nil or either one is nil
func PMapEmployeeStrPtrErr(f func(*Employee) (*string, error), list []*Employee) ([]*string, error) {
	if f == nil {
		return []*string{}, nil
	}

	ch := make(chan map[int]*string, len(list))
	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i, v := range list {
		wg.Add(1)

		go func(wg *sync.WaitGroup, ch chan map[int]*string, i int, v *Employee) {
			defer wg.Done()
			if len(errCh) >= 1 {
				return
			}
			r, err := f(v)
			if err != nil {
				errCh <- err
				return
			}
			ch <- map[int]*string{i: r}
		}(&wg, ch, i, v)
	}

	wg.Wait()
	close(ch)
	close(errCh)
	
	for err := range errCh {
		if err != nil {
			return nil, err
		}
	}

	newList := make([]*string, len(list))
	for m := range ch {
		for k, v := range m {
			newList[k] = v
		}
	}
	return newList, nil
}

// FilterMapEmployeeStr filters given list, then apply function(2nd argument) on each item in the list and returns a new list
// Takes 3 inputs
//	1. Function: takes one input type - Employee and returns true/false.
//	2. Function: takes Employee as argument and returns string
// 	3. List of type Employee
//
// Returns:
//	New List of type string
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapEmployeeStr(fFilter func(Employee) bool, fMap func(Employee) string, list []Employee) []string {
	if fFilter == nil || fMap == nil {
		return []string{}
	}
	var newList []string
	for _, v := range list {
		if fFilter(v) {
			newList = append(newList, fMap(v))
		}
	}
	return newList
}

// FilterMapEmployeeStrPtrErr filters given list, then apply function(2nd argument) on each item in the list and returns a new list, error
// Takes 3 inputs
//	1. Function: takes one input type - *Employee and returns (bool, error).
//	2. Function: takes *Employee as argument and returns (*string, error)
// 	3. List of type *Employee
//
// Returns:
//	New List of type *string, error
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapEmployeeStrPtrErr(fFilter func(*Employee) (bool, error), fMap func(*Employee) (*string, error), list []*Employee) ([]*string, error) {
	if fFilter == nil || fMap == nil {
		return []*string{}, nil
	}
	var newList []*string
	for _, v := range list {
		r, err := fFilter(v)
		if err != nil {
			return nil, err
		}
		if r {
			r, err := fMap(v)
			if err != nil {
				return nil, err
			}
			newList = append(newList, r)
		}
	}
	return newList, nil
}

// FilterMapEmployeeStrErr filters given list, then apply function(2nd argument) on each item in the list and returns a new list, error
// Takes 3 inputs
//	1. Function: takes one input type - Employee and returns (bool, error).
//	2. Function: takes Employee as argument and returns (string, error)
// 	3. List of type Employee
//
// Returns:
//	New List of type string, error
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapEmployeeStrErr(fFilter func(Employee) (bool, error), fMap func(Employee) (string, error), list []Employee) ([]string, error) {
	if fFilter == nil || fMap == nil {
		return []string{}, nil
	}
	var newList []string
	for _, v := range list {
		r, err := fFilter(v)
		if err != nil {
			return nil, err
		}
		if r {
			r, err := fMap(v)
			if err != nil {
				return nil, err
			}
			newList = append(newList, r)
		}
	}
	return newList, nil
}

// MapTeacherEmployee takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list
func MapTeacherEmployee(f func(Teacher) Employee, list []Teacher) []Employee {
	if f == nil {
		return []Employee{}
	}
	newList := make([]Employee, len(list))
	for i, v := range list {
		newList[i] = f(v)
	}
	return newList
}

// MapTeacherEmployeeErr takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list and error
func MapTeacherEmployeeErr(f func(Teacher) (Employee, error), list []Teacher) ([]Employee, error) {
	if f == nil {
		return []Employee{}, nil
	}
	newList := make([]Employee, len(list))
	for i, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		newList[i] = r
	}
	return newList, nil
}

// MapTeacherEmployeePtr takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list
func MapTeacherEmployeePtr(f func(*Teacher) *Employee, list []*Teacher) []*Employee {
	if f == nil {
		return []*Employee{}
	}
	newList := make([]*Employee, len(list))
	for i, v := range list {
		newList[i] = f(v)
	}
	return newList
}

// MapTeacherEmployeePtrErr takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list, error
func MapTeacherEmployeePtrErr(f func(*Teacher) (*Employee, error), list []*Teacher) ([]*Employee, error) {
	if f == nil {
		return []*Employee{}, nil
	}
	newList := make([]*Employee, len(list))
	for i, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		newList[i] = r
	}
	return newList, nil
}

// PMapTeacherEmployee applies the function(1st argument) on each item of the list and returns new list.
// Run in parallel. no_of_goroutines = no_of_items_in_list
//
// Takes 2 inputs
//	1. Function - takes 1 input type: Teacher output type: Employee
//	2. List
//
// Returns
//	New List of type Employee
//	Empty list if all arguments are nil or either one is nil
func PMapTeacherEmployee(f func(Teacher) Employee, list []Teacher) []Employee {
	if f == nil {
		return []Employee{}
	}

	ch := make(chan map[int]Employee)
	var wg sync.WaitGroup

	for i, v := range list {
		wg.Add(1)

		go func(wg *sync.WaitGroup, ch chan map[int]Employee, i int, v Teacher) {
			defer wg.Done()
			ch <- map[int]Employee{i: f(v)}
		}(&wg, ch, i, v)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	newList := make([]Employee, len(list))
	for m := range ch {
		for k, v := range m {
			newList[k] = v
		}
	}
	return newList
}

// PMapTeacherEmployeeErr applies the function(1st argument) on each item of the list and returns new list and error.
// Run in parallel. no_of_goroutines = no_of_items_in_list
//
// Takes 2 inputs
//	1. Function - takes 1 input type: Teacher output type: (Employee, error)
//	2. List
//
// Returns
//	New List of type (Employee, error)
//	Empty list if all arguments are nil or either one is nil
func PMapTeacherEmployeeErr(f func(Teacher) (Employee, error), list []Teacher) ([]Employee, error) {
	if f == nil {
		return []Employee{}, nil
	}

	ch := make(chan map[int]Employee, len(list))
	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i, v := range list {
		wg.Add(1)

		go func(wg *sync.WaitGroup, ch chan map[int]Employee, i int, v Teacher) {
			defer wg.Done()
			if len(errCh) >= 1 {
				return
			}
			r, err := f(v)
			if err != nil {
				errCh <- err
				return
			}
			ch <- map[int]Employee{i: r}
		}(&wg, ch, i, v)
	}

	wg.Wait()
	close(ch)
	close(errCh)

	for err := range errCh {
		if err != nil {
			return nil, err
		}
	}

	newList := make([]Employee, len(list))
	for m := range ch {
		for k, v := range m {
			newList[k] = v
		}
	}
	return newList, nil
}

// PMapTeacherEmployeePtr applies the function(1st argument) on each item of the list and returns new list.
// Run in parallel. no_of_goroutines = no_of_items_in_list
//
// Takes 2 inputs
//	1. Function - takes 1 input type: *Teacher output type: *Employee
//	2. List
//
// Returns
//	New List of type *Employee
//	Empty list if all arguments are nil or either one is nil
func PMapTeacherEmployeePtr(f func(*Teacher) *Employee, list []*Teacher) []*Employee {
	if f == nil {
		return []*Employee{}
	}

	ch := make(chan map[int]*Employee)
	var wg sync.WaitGroup

	for i, v := range list {
		wg.Add(1)

		go func(wg *sync.WaitGroup, ch chan map[int]*Employee, i int, v *Teacher) {
			defer wg.Done()
			ch <- map[int]*Employee{i: f(v)}
		}(&wg, ch, i, v)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	newList := make([]*Employee, len(list))
	for m := range ch {
		for k, v := range m {
			newList[k] = v
		}
	}
	return newList
}

// PMapTeacherEmployeePtrErr applies the function(1st argument) on each item of the list and returns new list and error.
// Run in parallel. no_of_goroutines = no_of_items_in_list
//
// Takes 2 inputs
//	1. Function - takes 1 input type: *Teacher output type: (*Employee, error)
//	2. List
//
// Returns
//	New List of type (*Employee, error)
//	Empty list if all arguments are nil or either one is nil
func PMapTeacherEmployeePtrErr(f func(*Teacher) (*Employee, error), list []*Teacher) ([]*Employee, error) {
	if f == nil {
		return []*Employee{}, nil
	}

	ch := make(chan map[int]*Employee, len(list))
	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i, v := range list {
		wg.Add(1)

		go func(wg *sync.WaitGroup, ch chan map[int]*Employee, i int, v *Teacher) {
			defer wg.Done()
			if len(errCh) >= 1 {
				return
			}
			r, err := f(v)
			if err != nil {
				errCh <- err
				return
			}
			ch <- map[int]*Employee{i: r}
		}(&wg, ch, i, v)
	}

	wg.Wait()
	close(ch)
	close(errCh)
	
	for err := range errCh {
		if err != nil {
			return nil, err
		}
	}

	newList := make([]*Employee, len(list))
	for m := range ch {
		for k, v := range m {
			newList[k] = v
		}
	}
	return newList, nil
}

// FilterMapTeacherEmployee filters given list, then apply function(2nd argument) on each item in the list and returns a new list
// Takes 3 inputs
//	1. Function: takes one input type - Teacher and returns true/false.
//	2. Function: takes Teacher as argument and returns Employee
// 	3. List of type Teacher
//
// Returns:
//	New List of type Employee
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapTeacherEmployee(fFilter func(Teacher) bool, fMap func(Teacher) Employee, list []Teacher) []Employee {
	if fFilter == nil || fMap == nil {
		return []Employee{}
	}
	var newList []Employee
	for _, v := range list {
		if fFilter(v) {
			newList = append(newList, fMap(v))
		}
	}
	return newList
}

// FilterMapTeacherEmployeePtrErr filters given list, then apply function(2nd argument) on each item in the list and returns a new list, error
// Takes 3 inputs
//	1. Function: takes one input type - *Teacher and returns (bool, error).
//	2. Function: takes *Teacher as argument and returns (*Employee, error)
// 	3. List of type *Teacher
//
// Returns:
//	New List of type *Employee, error
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapTeacherEmployeePtrErr(fFilter func(*Teacher) (bool, error), fMap func(*Teacher) (*Employee, error), list []*Teacher) ([]*Employee, error) {
	if fFilter == nil || fMap == nil {
		return []*Employee{}, nil
	}
	var newList []*Employee
	for _, v := range list {
		r, err := fFilter(v)
		if err != nil {
			return nil, err
		}
		if r {
			r, err := fMap(v)
			if err != nil {
				return nil, err
			}
			newList = append(newList, r)
		}
	}
	return newList, nil
}

// FilterMapTeacherEmployeeErr filters given list, then apply function(2nd argument) on each item in the list and returns a new list, error
// Takes 3 inputs
//	1. Function: takes one input type - Teacher and returns (bool, error).
//	2. Function: takes Teacher as argument and returns (Employee, error)
// 	3. List of type Teacher
//
// Returns:
//	New List of type Employee, error
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapTeacherEmployeeErr(fFilter func(Teacher) (bool, error), fMap func(Teacher) (Employee, error), list []Teacher) ([]Employee, error) {
	if fFilter == nil || fMap == nil {
		return []Employee{}, nil
	}
	var newList []Employee
	for _, v := range list {
		r, err := fFilter(v)
		if err != nil {
			return nil, err
		}
		if r {
			r, err := fMap(v)
			if err != nil {
				return nil, err
			}
			newList = append(newList, r)
		}
	}
	return newList, nil
}

// MapTeacherInt takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list
func MapTeacherInt(f func(Teacher) int, list []Teacher) []int {
	if f == nil {
		return []int{}
	}
	newList := make([]int, len(list))
	for i, v := range list {
		newList[i] = f(v)
	}
	return newList
}

// MapTeacherIntErr takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list and error
func MapTeacherIntErr(f func(Teacher) (int, error), list []Teacher) ([]int, error) {
	if f == nil {
		return []int{}, nil
	}
	newList := make([]int, len(list))
	for i, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		newList[i] = r
	}
	return newList, nil
}

// MapTeacherIntPtr takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list
func MapTeacherIntPtr(f func(*Teacher) *int, list []*Teacher) []*int {
	if f == nil {
		return []*int{}
	}
	newList := make([]*int, len(list))
	for i, v := range list {
		newList[i] = f(v)
	}
	return newList
}

// MapTeacherIntPtrErr takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list, error
func MapTeacherIntPtrErr(f func(*Teacher) (*int, error), list []*Teacher) ([]*int, error) {
	if f == nil {
		return []*int{}, nil
	}
	newList := make([]*int, len(list))
	for i, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		newList[i] = r
	}
	return newList, nil
}

// PMapTeacherInt applies the function(1st argument) on each item of the list and returns new list.
// Run in parallel. no_of_goroutines = no_of_items_in_list
//
// Takes 2 inputs
//	1. Function - takes 1 input type: Teacher output type: int
//	2. List
//
// Returns
//	New List of type int
//	Empty list if all arguments are nil or either one is nil
func PMapTeacherInt(f func(Teacher) int, list []Teacher) []int {
	if f == nil {
		return []int{}
	}

	ch := make(chan map[int]int)
	var wg sync.WaitGroup

	for i, v := range list {
		wg.Add(1)

		go func(wg *sync.WaitGroup, ch chan map[int]int, i int, v Teacher) {
			defer wg.Done()
			ch <- map[int]int{i: f(v)}
		}(&wg, ch, i, v)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	newList := make([]int, len(list))
	for m := range ch {
		for k, v := range m {
			newList[k] = v
		}
	}
	return newList
}

// PMapTeacherIntErr applies the function(1st argument) on each item of the list and returns new list and error.
// Run in parallel. no_of_goroutines = no_of_items_in_list
//
// Takes 2 inputs
//	1. Function - takes 1 input type: Teacher output type: (int, error)
//	2. List
//
// Returns
//	New List of type (int, error)
//	Empty list if all arguments are nil or either one is nil
func PMapTeacherIntErr(f func(Teacher) (int, error), list []Teacher) ([]int, error) {
	if f == nil {
		return []int{}, nil
	}

	ch := make(chan map[int]int, len(list))
	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i, v := range list {
		wg.Add(1)

		go func(wg *sync.WaitGroup, ch chan map[int]int, i int, v Teacher) {
			defer wg.Done()
			if len(errCh) >= 1 {
				return
			}
			r, err := f(v)
			if err != nil {
				errCh <- err
				return
			}
			ch <- map[int]int{i: r}
		}(&wg, ch, i, v)
	}

	wg.Wait()
	close(ch)
	close(errCh)

	for err := range errCh {
		if err != nil {
			return nil, err
		}
	}

	newList := make([]int, len(list))
	for m := range ch {
		for k, v := range m {
			newList[k] = v
		}
	}
	return newList, nil
}

// PMapTeacherIntPtr applies the function(1st argument) on each item of the list and returns new list.
// Run in parallel. no_of_goroutines = no_of_items_in_list
//
// Takes 2 inputs
//	1. Function - takes 1 input type: *Teacher output type: *int
//	2. List
//
// Returns
//	New List of type *int
//	Empty list if all arguments are nil or either one is nil
func PMapTeacherIntPtr(f func(*Teacher) *int, list []*Teacher) []*int {
	if f == nil {
		return []*int{}
	}

	ch := make(chan map[int]*int)
	var wg sync.WaitGroup

	for i, v := range list {
		wg.Add(1)

		go func(wg *sync.WaitGroup, ch chan map[int]*int, i int, v *Teacher) {
			defer wg.Done()
			ch <- map[int]*int{i: f(v)}
		}(&wg, ch, i, v)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	newList := make([]*int, len(list))
	for m := range ch {
		for k, v := range m {
			newList[k] = v
		}
	}
	return newList
}

// PMapTeacherIntPtrErr applies the function(1st argument) on each item of the list and returns new list and error.
// Run in parallel. no_of_goroutines = no_of_items_in_list
//
// Takes 2 inputs
//	1. Function - takes 1 input type: *Teacher output type: (*int, error)
//	2. List
//
// Returns
//	New List of type (*int, error)
//	Empty list if all arguments are nil or either one is nil
func PMapTeacherIntPtrErr(f func(*Teacher) (*int, error), list []*Teacher) ([]*int, error) {
	if f == nil {
		return []*int{}, nil
	}

	ch := make(chan map[int]*int, len(list))
	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i, v := range list {
		wg.Add(1)

		go func(wg *sync.WaitGroup, ch chan map[int]*int, i int, v *Teacher) {
			defer wg.Done()
			if len(errCh) >= 1 {
				return
			}
			r, err := f(v)
			if err != nil {
				errCh <- err
				return
			}
			ch <- map[int]*int{i: r}
		}(&wg, ch, i, v)
	}

	wg.Wait()
	close(ch)
	close(errCh)
	
	for err := range errCh {
		if err != nil {
			return nil, err
		}
	}

	newList := make([]*int, len(list))
	for m := range ch {
		for k, v := range m {
			newList[k] = v
		}
	}
	return newList, nil
}

// FilterMapTeacherInt filters given list, then apply function(2nd argument) on each item in the list and returns a new list
// Takes 3 inputs
//	1. Function: takes one input type - Teacher and returns true/false.
//	2. Function: takes Teacher as argument and returns int
// 	3. List of type Teacher
//
// Returns:
//	New List of type int
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapTeacherInt(fFilter func(Teacher) bool, fMap func(Teacher) int, list []Teacher) []int {
	if fFilter == nil || fMap == nil {
		return []int{}
	}
	var newList []int
	for _, v := range list {
		if fFilter(v) {
			newList = append(newList, fMap(v))
		}
	}
	return newList
}

// FilterMapTeacherIntPtrErr filters given list, then apply function(2nd argument) on each item in the list and returns a new list, error
// Takes 3 inputs
//	1. Function: takes one input type - *Teacher and returns (bool, error).
//	2. Function: takes *Teacher as argument and returns (*int, error)
// 	3. List of type *Teacher
//
// Returns:
//	New List of type *int, error
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapTeacherIntPtrErr(fFilter func(*Teacher) (bool, error), fMap func(*Teacher) (*int, error), list []*Teacher) ([]*int, error) {
	if fFilter == nil || fMap == nil {
		return []*int{}, nil
	}
	var newList []*int
	for _, v := range list {
		r, err := fFilter(v)
		if err != nil {
			return nil, err
		}
		if r {
			r, err := fMap(v)
			if err != nil {
				return nil, err
			}
			newList = append(newList, r)
		}
	}
	return newList, nil
}

// FilterMapTeacherIntErr filters given list, then apply function(2nd argument) on each item in the list and returns a new list, error
// Takes 3 inputs
//	1. Function: takes one input type - Teacher and returns (bool, error).
//	2. Function: takes Teacher as argument and returns (int, error)
// 	3. List of type Teacher
//
// Returns:
//	New List of type int, error
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapTeacherIntErr(fFilter func(Teacher) (bool, error), fMap func(Teacher) (int, error), list []Teacher) ([]int, error) {
	if fFilter == nil || fMap == nil {
		return []int{}, nil
	}
	var newList []int
	for _, v := range list {
		r, err := fFilter(v)
		if err != nil {
			return nil, err
		}
		if r {
			r, err := fMap(v)
			if err != nil {
				return nil, err
			}
			newList = append(newList, r)
		}
	}
	return newList, nil
}

// MapTeacherStr takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list
func MapTeacherStr(f func(Teacher) string, list []Teacher) []string {
	if f == nil {
		return []string{}
	}
	newList := make([]string, len(list))
	for i, v := range list {
		newList[i] = f(v)
	}
	return newList
}

// MapTeacherStrErr takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list and error
func MapTeacherStrErr(f func(Teacher) (string, error), list []Teacher) ([]string, error) {
	if f == nil {
		return []string{}, nil
	}
	newList := make([]string, len(list))
	for i, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		newList[i] = r
	}
	return newList, nil
}

// MapTeacherStrPtr takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list
func MapTeacherStrPtr(f func(*Teacher) *string, list []*Teacher) []*string {
	if f == nil {
		return []*string{}
	}
	newList := make([]*string, len(list))
	for i, v := range list {
		newList[i] = f(v)
	}
	return newList
}

// MapTeacherStrPtrErr takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list, error
func MapTeacherStrPtrErr(f func(*Teacher) (*string, error), list []*Teacher) ([]*string, error) {
	if f == nil {
		return []*string{}, nil
	}
	newList := make([]*string, len(list))
	for i, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		newList[i] = r
	}
	return newList, nil
}

// PMapTeacherStr applies the function(1st argument) on each item of the list and returns new list.
// Run in parallel. no_of_goroutines = no_of_items_in_list
//
// Takes 2 inputs
//	1. Function - takes 1 input type: Teacher output type: string
//	2. List
//
// Returns
//	New List of type string
//	Empty list if all arguments are nil or either one is nil
func PMapTeacherStr(f func(Teacher) string, list []Teacher) []string {
	if f == nil {
		return []string{}
	}

	ch := make(chan map[int]string)
	var wg sync.WaitGroup

	for i, v := range list {
		wg.Add(1)

		go func(wg *sync.WaitGroup, ch chan map[int]string, i int, v Teacher) {
			defer wg.Done()
			ch <- map[int]string{i: f(v)}
		}(&wg, ch, i, v)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	newList := make([]string, len(list))
	for m := range ch {
		for k, v := range m {
			newList[k] = v
		}
	}
	return newList
}

// PMapTeacherStrErr applies the function(1st argument) on each item of the list and returns new list and error.
// Run in parallel. no_of_goroutines = no_of_items_in_list
//
// Takes 2 inputs
//	1. Function - takes 1 input type: Teacher output type: (string, error)
//	2. List
//
// Returns
//	New List of type (string, error)
//	Empty list if all arguments are nil or either one is nil
func PMapTeacherStrErr(f func(Teacher) (string, error), list []Teacher) ([]string, error) {
	if f == nil {
		return []string{}, nil
	}

	ch := make(chan map[int]string, len(list))
	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i, v := range list {
		wg.Add(1)

		go func(wg *sync.WaitGroup, ch chan map[int]string, i int, v Teacher) {
			defer wg.Done()
			if len(errCh) >= 1 {
				return
			}
			r, err := f(v)
			if err != nil {
				errCh <- err
				return
			}
			ch <- map[int]string{i: r}
		}(&wg, ch, i, v)
	}

	wg.Wait()
	close(ch)
	close(errCh)

	for err := range errCh {
		if err != nil {
			return nil, err
		}
	}

	newList := make([]string, len(list))
	for m := range ch {
		for k, v := range m {
			newList[k] = v
		}
	}
	return newList, nil
}

// PMapTeacherStrPtr applies the function(1st argument) on each item of the list and returns new list.
// Run in parallel. no_of_goroutines = no_of_items_in_list
//
// Takes 2 inputs
//	1. Function - takes 1 input type: *Teacher output type: *string
//	2. List
//
// Returns
//	New List of type *string
//	Empty list if all arguments are nil or either one is nil
func PMapTeacherStrPtr(f func(*Teacher) *string, list []*Teacher) []*string {
	if f == nil {
		return []*string{}
	}

	ch := make(chan map[int]*string)
	var wg sync.WaitGroup

	for i, v := range list {
		wg.Add(1)

		go func(wg *sync.WaitGroup, ch chan map[int]*string, i int, v *Teacher) {
			defer wg.Done()
			ch <- map[int]*string{i: f(v)}
		}(&wg, ch, i, v)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	newList := make([]*string, len(list))
	for m := range ch {
		for k, v := range m {
			newList[k] = v
		}
	}
	return newList
}

// PMapTeacherStrPtrErr applies the function(1st argument) on each item of the list and returns new list and error.
// Run in parallel. no_of_goroutines = no_of_items_in_list
//
// Takes 2 inputs
//	1. Function - takes 1 input type: *Teacher output type: (*string, error)
//	2. List
//
// Returns
//	New List of type (*string, error)
//	Empty list if all arguments are nil or either one is nil
func PMapTeacherStrPtrErr(f func(*Teacher) (*string, error), list []*Teacher) ([]*string, error) {
	if f == nil {
		return []*string{}, nil
	}

	ch := make(chan map[int]*string, len(list))
	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i, v := range list {
		wg.Add(1)

		go func(wg *sync.WaitGroup, ch chan map[int]*string, i int, v *Teacher) {
			defer wg.Done()
			if len(errCh) >= 1 {
				return
			}
			r, err := f(v)
			if err != nil {
				errCh <- err
				return
			}
			ch <- map[int]*string{i: r}
		}(&wg, ch, i, v)
	}

	wg.Wait()
	close(ch)
	close(errCh)
	
	for err := range errCh {
		if err != nil {
			return nil, err
		}
	}

	newList := make([]*string, len(list))
	for m := range ch {
		for k, v := range m {
			newList[k] = v
		}
	}
	return newList, nil
}

// FilterMapTeacherStr filters given list, then apply function(2nd argument) on each item in the list and returns a new list
// Takes 3 inputs
//	1. Function: takes one input type - Teacher and returns true/false.
//	2. Function: takes Teacher as argument and returns string
// 	3. List of type Teacher
//
// Returns:
//	New List of type string
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapTeacherStr(fFilter func(Teacher) bool, fMap func(Teacher) string, list []Teacher) []string {
	if fFilter == nil || fMap == nil {
		return []string{}
	}
	var newList []string
	for _, v := range list {
		if fFilter(v) {
			newList = append(newList, fMap(v))
		}
	}
	return newList
}

// FilterMapTeacherStrPtrErr filters given list, then apply function(2nd argument) on each item in the list and returns a new list, error
// Takes 3 inputs
//	1. Function: takes one input type - *Teacher and returns (bool, error).
//	2. Function: takes *Teacher as argument and returns (*string, error)
// 	3. List of type *Teacher
//
// Returns:
//	New List of type *string, error
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapTeacherStrPtrErr(fFilter func(*Teacher) (bool, error), fMap func(*Teacher) (*string, error), list []*Teacher) ([]*string, error) {
	if fFilter == nil || fMap == nil {
		return []*string{}, nil
	}
	var newList []*string
	for _, v := range list {
		r, err := fFilter(v)
		if err != nil {
			return nil, err
		}
		if r {
			r, err := fMap(v)
			if err != nil {
				return nil, err
			}
			newList = append(newList, r)
		}
	}
	return newList, nil
}

// FilterMapTeacherStrErr filters given list, then apply function(2nd argument) on each item in the list and returns a new list, error
// Takes 3 inputs
//	1. Function: takes one input type - Teacher and returns (bool, error).
//	2. Function: takes Teacher as argument and returns (string, error)
// 	3. List of type Teacher
//
// Returns:
//	New List of type string, error
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapTeacherStrErr(fFilter func(Teacher) (bool, error), fMap func(Teacher) (string, error), list []Teacher) ([]string, error) {
	if fFilter == nil || fMap == nil {
		return []string{}, nil
	}
	var newList []string
	for _, v := range list {
		r, err := fFilter(v)
		if err != nil {
			return nil, err
		}
		if r {
			r, err := fMap(v)
			if err != nil {
				return nil, err
			}
			newList = append(newList, r)
		}
	}
	return newList, nil
}

// MapIntEmployee takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list
func MapIntEmployee(f func(int) Employee, list []int) []Employee {
	if f == nil {
		return []Employee{}
	}
	newList := make([]Employee, len(list))
	for i, v := range list {
		newList[i] = f(v)
	}
	return newList
}

// MapIntEmployeeErr takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list and error
func MapIntEmployeeErr(f func(int) (Employee, error), list []int) ([]Employee, error) {
	if f == nil {
		return []Employee{}, nil
	}
	newList := make([]Employee, len(list))
	for i, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		newList[i] = r
	}
	return newList, nil
}

// MapIntEmployeePtr takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list
func MapIntEmployeePtr(f func(*int) *Employee, list []*int) []*Employee {
	if f == nil {
		return []*Employee{}
	}
	newList := make([]*Employee, len(list))
	for i, v := range list {
		newList[i] = f(v)
	}
	return newList
}

// MapIntEmployeePtrErr takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list, error
func MapIntEmployeePtrErr(f func(*int) (*Employee, error), list []*int) ([]*Employee, error) {
	if f == nil {
		return []*Employee{}, nil
	}
	newList := make([]*Employee, len(list))
	for i, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		newList[i] = r
	}
	return newList, nil
}

// PMapIntEmployee applies the function(1st argument) on each item of the list and returns new list.
// Run in parallel. no_of_goroutines = no_of_items_in_list
//
// Takes 2 inputs
//	1. Function - takes 1 input type: int output type: Employee
//	2. List
//
// Returns
//	New List of type Employee
//	Empty list if all arguments are nil or either one is nil
func PMapIntEmployee(f func(int) Employee, list []int) []Employee {
	if f == nil {
		return []Employee{}
	}

	ch := make(chan map[int]Employee)
	var wg sync.WaitGroup

	for i, v := range list {
		wg.Add(1)

		go func(wg *sync.WaitGroup, ch chan map[int]Employee, i int, v int) {
			defer wg.Done()
			ch <- map[int]Employee{i: f(v)}
		}(&wg, ch, i, v)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	newList := make([]Employee, len(list))
	for m := range ch {
		for k, v := range m {
			newList[k] = v
		}
	}
	return newList
}

// PMapIntEmployeeErr applies the function(1st argument) on each item of the list and returns new list and error.
// Run in parallel. no_of_goroutines = no_of_items_in_list
//
// Takes 2 inputs
//	1. Function - takes 1 input type: int output type: (Employee, error)
//	2. List
//
// Returns
//	New List of type (Employee, error)
//	Empty list if all arguments are nil or either one is nil
func PMapIntEmployeeErr(f func(int) (Employee, error), list []int) ([]Employee, error) {
	if f == nil {
		return []Employee{}, nil
	}

	ch := make(chan map[int]Employee, len(list))
	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i, v := range list {
		wg.Add(1)

		go func(wg *sync.WaitGroup, ch chan map[int]Employee, i int, v int) {
			defer wg.Done()
			if len(errCh) >= 1 {
				return
			}
			r, err := f(v)
			if err != nil {
				errCh <- err
				return
			}
			ch <- map[int]Employee{i: r}
		}(&wg, ch, i, v)
	}

	wg.Wait()
	close(ch)
	close(errCh)

	for err := range errCh {
		if err != nil {
			return nil, err
		}
	}

	newList := make([]Employee, len(list))
	for m := range ch {
		for k, v := range m {
			newList[k] = v
		}
	}
	return newList, nil
}

// PMapIntEmployeePtr applies the function(1st argument) on each item of the list and returns new list.
// Run in parallel. no_of_goroutines = no_of_items_in_list
//
// Takes 2 inputs
//	1. Function - takes 1 input type: *int output type: *Employee
//	2. List
//
// Returns
//	New List of type *Employee
//	Empty list if all arguments are nil or either one is nil
func PMapIntEmployeePtr(f func(*int) *Employee, list []*int) []*Employee {
	if f == nil {
		return []*Employee{}
	}

	ch := make(chan map[int]*Employee)
	var wg sync.WaitGroup

	for i, v := range list {
		wg.Add(1)

		go func(wg *sync.WaitGroup, ch chan map[int]*Employee, i int, v *int) {
			defer wg.Done()
			ch <- map[int]*Employee{i: f(v)}
		}(&wg, ch, i, v)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	newList := make([]*Employee, len(list))
	for m := range ch {
		for k, v := range m {
			newList[k] = v
		}
	}
	return newList
}

// PMapIntEmployeePtrErr applies the function(1st argument) on each item of the list and returns new list and error.
// Run in parallel. no_of_goroutines = no_of_items_in_list
//
// Takes 2 inputs
//	1. Function - takes 1 input type: *int output type: (*Employee, error)
//	2. List
//
// Returns
//	New List of type (*Employee, error)
//	Empty list if all arguments are nil or either one is nil
func PMapIntEmployeePtrErr(f func(*int) (*Employee, error), list []*int) ([]*Employee, error) {
	if f == nil {
		return []*Employee{}, nil
	}

	ch := make(chan map[int]*Employee, len(list))
	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i, v := range list {
		wg.Add(1)

		go func(wg *sync.WaitGroup, ch chan map[int]*Employee, i int, v *int) {
			defer wg.Done()
			if len(errCh) >= 1 {
				return
			}
			r, err := f(v)
			if err != nil {
				errCh <- err
				return
			}
			ch <- map[int]*Employee{i: r}
		}(&wg, ch, i, v)
	}

	wg.Wait()
	close(ch)
	close(errCh)
	
	for err := range errCh {
		if err != nil {
			return nil, err
		}
	}

	newList := make([]*Employee, len(list))
	for m := range ch {
		for k, v := range m {
			newList[k] = v
		}
	}
	return newList, nil
}

// FilterMapIntEmployee filters given list, then apply function(2nd argument) on each item in the list and returns a new list
// Takes 3 inputs
//	1. Function: takes one input type - int and returns true/false.
//	2. Function: takes int as argument and returns Employee
// 	3. List of type int
//
// Returns:
//	New List of type Employee
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapIntEmployee(fFilter func(int) bool, fMap func(int) Employee, list []int) []Employee {
	if fFilter == nil || fMap == nil {
		return []Employee{}
	}
	var newList []Employee
	for _, v := range list {
		if fFilter(v) {
			newList = append(newList, fMap(v))
		}
	}
	return newList
}

// FilterMapIntEmployeePtrErr filters given list, then apply function(2nd argument) on each item in the list and returns a new list, error
// Takes 3 inputs
//	1. Function: takes one input type - *int and returns (bool, error).
//	2. Function: takes *int as argument and returns (*Employee, error)
// 	3. List of type *int
//
// Returns:
//	New List of type *Employee, error
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapIntEmployeePtrErr(fFilter func(*int) (bool, error), fMap func(*int) (*Employee, error), list []*int) ([]*Employee, error) {
	if fFilter == nil || fMap == nil {
		return []*Employee{}, nil
	}
	var newList []*Employee
	for _, v := range list {
		r, err := fFilter(v)
		if err != nil {
			return nil, err
		}
		if r {
			r, err := fMap(v)
			if err != nil {
				return nil, err
			}
			newList = append(newList, r)
		}
	}
	return newList, nil
}

// FilterMapIntEmployeeErr filters given list, then apply function(2nd argument) on each item in the list and returns a new list, error
// Takes 3 inputs
//	1. Function: takes one input type - int and returns (bool, error).
//	2. Function: takes int as argument and returns (Employee, error)
// 	3. List of type int
//
// Returns:
//	New List of type Employee, error
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapIntEmployeeErr(fFilter func(int) (bool, error), fMap func(int) (Employee, error), list []int) ([]Employee, error) {
	if fFilter == nil || fMap == nil {
		return []Employee{}, nil
	}
	var newList []Employee
	for _, v := range list {
		r, err := fFilter(v)
		if err != nil {
			return nil, err
		}
		if r {
			r, err := fMap(v)
			if err != nil {
				return nil, err
			}
			newList = append(newList, r)
		}
	}
	return newList, nil
}

// MapIntTeacher takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list
func MapIntTeacher(f func(int) Teacher, list []int) []Teacher {
	if f == nil {
		return []Teacher{}
	}
	newList := make([]Teacher, len(list))
	for i, v := range list {
		newList[i] = f(v)
	}
	return newList
}

// MapIntTeacherErr takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list and error
func MapIntTeacherErr(f func(int) (Teacher, error), list []int) ([]Teacher, error) {
	if f == nil {
		return []Teacher{}, nil
	}
	newList := make([]Teacher, len(list))
	for i, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		newList[i] = r
	}
	return newList, nil
}

// MapIntTeacherPtr takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list
func MapIntTeacherPtr(f func(*int) *Teacher, list []*int) []*Teacher {
	if f == nil {
		return []*Teacher{}
	}
	newList := make([]*Teacher, len(list))
	for i, v := range list {
		newList[i] = f(v)
	}
	return newList
}

// MapIntTeacherPtrErr takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list, error
func MapIntTeacherPtrErr(f func(*int) (*Teacher, error), list []*int) ([]*Teacher, error) {
	if f == nil {
		return []*Teacher{}, nil
	}
	newList := make([]*Teacher, len(list))
	for i, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		newList[i] = r
	}
	return newList, nil
}

// PMapIntTeacher applies the function(1st argument) on each item of the list and returns new list.
// Run in parallel. no_of_goroutines = no_of_items_in_list
//
// Takes 2 inputs
//	1. Function - takes 1 input type: int output type: Teacher
//	2. List
//
// Returns
//	New List of type Teacher
//	Empty list if all arguments are nil or either one is nil
func PMapIntTeacher(f func(int) Teacher, list []int) []Teacher {
	if f == nil {
		return []Teacher{}
	}

	ch := make(chan map[int]Teacher)
	var wg sync.WaitGroup

	for i, v := range list {
		wg.Add(1)

		go func(wg *sync.WaitGroup, ch chan map[int]Teacher, i int, v int) {
			defer wg.Done()
			ch <- map[int]Teacher{i: f(v)}
		}(&wg, ch, i, v)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	newList := make([]Teacher, len(list))
	for m := range ch {
		for k, v := range m {
			newList[k] = v
		}
	}
	return newList
}

// PMapIntTeacherErr applies the function(1st argument) on each item of the list and returns new list and error.
// Run in parallel. no_of_goroutines = no_of_items_in_list
//
// Takes 2 inputs
//	1. Function - takes 1 input type: int output type: (Teacher, error)
//	2. List
//
// Returns
//	New List of type (Teacher, error)
//	Empty list if all arguments are nil or either one is nil
func PMapIntTeacherErr(f func(int) (Teacher, error), list []int) ([]Teacher, error) {
	if f == nil {
		return []Teacher{}, nil
	}

	ch := make(chan map[int]Teacher, len(list))
	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i, v := range list {
		wg.Add(1)

		go func(wg *sync.WaitGroup, ch chan map[int]Teacher, i int, v int) {
			defer wg.Done()
			if len(errCh) >= 1 {
				return
			}
			r, err := f(v)
			if err != nil {
				errCh <- err
				return
			}
			ch <- map[int]Teacher{i: r}
		}(&wg, ch, i, v)
	}

	wg.Wait()
	close(ch)
	close(errCh)

	for err := range errCh {
		if err != nil {
			return nil, err
		}
	}

	newList := make([]Teacher, len(list))
	for m := range ch {
		for k, v := range m {
			newList[k] = v
		}
	}
	return newList, nil
}

// PMapIntTeacherPtr applies the function(1st argument) on each item of the list and returns new list.
// Run in parallel. no_of_goroutines = no_of_items_in_list
//
// Takes 2 inputs
//	1. Function - takes 1 input type: *int output type: *Teacher
//	2. List
//
// Returns
//	New List of type *Teacher
//	Empty list if all arguments are nil or either one is nil
func PMapIntTeacherPtr(f func(*int) *Teacher, list []*int) []*Teacher {
	if f == nil {
		return []*Teacher{}
	}

	ch := make(chan map[int]*Teacher)
	var wg sync.WaitGroup

	for i, v := range list {
		wg.Add(1)

		go func(wg *sync.WaitGroup, ch chan map[int]*Teacher, i int, v *int) {
			defer wg.Done()
			ch <- map[int]*Teacher{i: f(v)}
		}(&wg, ch, i, v)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	newList := make([]*Teacher, len(list))
	for m := range ch {
		for k, v := range m {
			newList[k] = v
		}
	}
	return newList
}

// PMapIntTeacherPtrErr applies the function(1st argument) on each item of the list and returns new list and error.
// Run in parallel. no_of_goroutines = no_of_items_in_list
//
// Takes 2 inputs
//	1. Function - takes 1 input type: *int output type: (*Teacher, error)
//	2. List
//
// Returns
//	New List of type (*Teacher, error)
//	Empty list if all arguments are nil or either one is nil
func PMapIntTeacherPtrErr(f func(*int) (*Teacher, error), list []*int) ([]*Teacher, error) {
	if f == nil {
		return []*Teacher{}, nil
	}

	ch := make(chan map[int]*Teacher, len(list))
	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i, v := range list {
		wg.Add(1)

		go func(wg *sync.WaitGroup, ch chan map[int]*Teacher, i int, v *int) {
			defer wg.Done()
			if len(errCh) >= 1 {
				return
			}
			r, err := f(v)
			if err != nil {
				errCh <- err
				return
			}
			ch <- map[int]*Teacher{i: r}
		}(&wg, ch, i, v)
	}

	wg.Wait()
	close(ch)
	close(errCh)
	
	for err := range errCh {
		if err != nil {
			return nil, err
		}
	}

	newList := make([]*Teacher, len(list))
	for m := range ch {
		for k, v := range m {
			newList[k] = v
		}
	}
	return newList, nil
}

// FilterMapIntTeacher filters given list, then apply function(2nd argument) on each item in the list and returns a new list
// Takes 3 inputs
//	1. Function: takes one input type - int and returns true/false.
//	2. Function: takes int as argument and returns Teacher
// 	3. List of type int
//
// Returns:
//	New List of type Teacher
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapIntTeacher(fFilter func(int) bool, fMap func(int) Teacher, list []int) []Teacher {
	if fFilter == nil || fMap == nil {
		return []Teacher{}
	}
	var newList []Teacher
	for _, v := range list {
		if fFilter(v) {
			newList = append(newList, fMap(v))
		}
	}
	return newList
}

// FilterMapIntTeacherPtrErr filters given list, then apply function(2nd argument) on each item in the list and returns a new list, error
// Takes 3 inputs
//	1. Function: takes one input type - *int and returns (bool, error).
//	2. Function: takes *int as argument and returns (*Teacher, error)
// 	3. List of type *int
//
// Returns:
//	New List of type *Teacher, error
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapIntTeacherPtrErr(fFilter func(*int) (bool, error), fMap func(*int) (*Teacher, error), list []*int) ([]*Teacher, error) {
	if fFilter == nil || fMap == nil {
		return []*Teacher{}, nil
	}
	var newList []*Teacher
	for _, v := range list {
		r, err := fFilter(v)
		if err != nil {
			return nil, err
		}
		if r {
			r, err := fMap(v)
			if err != nil {
				return nil, err
			}
			newList = append(newList, r)
		}
	}
	return newList, nil
}

// FilterMapIntTeacherErr filters given list, then apply function(2nd argument) on each item in the list and returns a new list, error
// Takes 3 inputs
//	1. Function: takes one input type - int and returns (bool, error).
//	2. Function: takes int as argument and returns (Teacher, error)
// 	3. List of type int
//
// Returns:
//	New List of type Teacher, error
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapIntTeacherErr(fFilter func(int) (bool, error), fMap func(int) (Teacher, error), list []int) ([]Teacher, error) {
	if fFilter == nil || fMap == nil {
		return []Teacher{}, nil
	}
	var newList []Teacher
	for _, v := range list {
		r, err := fFilter(v)
		if err != nil {
			return nil, err
		}
		if r {
			r, err := fMap(v)
			if err != nil {
				return nil, err
			}
			newList = append(newList, r)
		}
	}
	return newList, nil
}

// MapStrEmployee takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list
func MapStrEmployee(f func(string) Employee, list []string) []Employee {
	if f == nil {
		return []Employee{}
	}
	newList := make([]Employee, len(list))
	for i, v := range list {
		newList[i] = f(v)
	}
	return newList
}

// MapStrEmployeeErr takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list and error
func MapStrEmployeeErr(f func(string) (Employee, error), list []string) ([]Employee, error) {
	if f == nil {
		return []Employee{}, nil
	}
	newList := make([]Employee, len(list))
	for i, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		newList[i] = r
	}
	return newList, nil
}

// MapStrEmployeePtr takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list
func MapStrEmployeePtr(f func(*string) *Employee, list []*string) []*Employee {
	if f == nil {
		return []*Employee{}
	}
	newList := make([]*Employee, len(list))
	for i, v := range list {
		newList[i] = f(v)
	}
	return newList
}

// MapStrEmployeePtrErr takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list, error
func MapStrEmployeePtrErr(f func(*string) (*Employee, error), list []*string) ([]*Employee, error) {
	if f == nil {
		return []*Employee{}, nil
	}
	newList := make([]*Employee, len(list))
	for i, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		newList[i] = r
	}
	return newList, nil
}

// PMapStrEmployee applies the function(1st argument) on each item of the list and returns new list.
// Run in parallel. no_of_goroutines = no_of_items_in_list
//
// Takes 2 inputs
//	1. Function - takes 1 input type: string output type: Employee
//	2. List
//
// Returns
//	New List of type Employee
//	Empty list if all arguments are nil or either one is nil
func PMapStrEmployee(f func(string) Employee, list []string) []Employee {
	if f == nil {
		return []Employee{}
	}

	ch := make(chan map[int]Employee)
	var wg sync.WaitGroup

	for i, v := range list {
		wg.Add(1)

		go func(wg *sync.WaitGroup, ch chan map[int]Employee, i int, v string) {
			defer wg.Done()
			ch <- map[int]Employee{i: f(v)}
		}(&wg, ch, i, v)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	newList := make([]Employee, len(list))
	for m := range ch {
		for k, v := range m {
			newList[k] = v
		}
	}
	return newList
}

// PMapStrEmployeeErr applies the function(1st argument) on each item of the list and returns new list and error.
// Run in parallel. no_of_goroutines = no_of_items_in_list
//
// Takes 2 inputs
//	1. Function - takes 1 input type: string output type: (Employee, error)
//	2. List
//
// Returns
//	New List of type (Employee, error)
//	Empty list if all arguments are nil or either one is nil
func PMapStrEmployeeErr(f func(string) (Employee, error), list []string) ([]Employee, error) {
	if f == nil {
		return []Employee{}, nil
	}

	ch := make(chan map[int]Employee, len(list))
	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i, v := range list {
		wg.Add(1)

		go func(wg *sync.WaitGroup, ch chan map[int]Employee, i int, v string) {
			defer wg.Done()
			if len(errCh) >= 1 {
				return
			}
			r, err := f(v)
			if err != nil {
				errCh <- err
				return
			}
			ch <- map[int]Employee{i: r}
		}(&wg, ch, i, v)
	}

	wg.Wait()
	close(ch)
	close(errCh)

	for err := range errCh {
		if err != nil {
			return nil, err
		}
	}

	newList := make([]Employee, len(list))
	for m := range ch {
		for k, v := range m {
			newList[k] = v
		}
	}
	return newList, nil
}

// PMapStrEmployeePtr applies the function(1st argument) on each item of the list and returns new list.
// Run in parallel. no_of_goroutines = no_of_items_in_list
//
// Takes 2 inputs
//	1. Function - takes 1 input type: *string output type: *Employee
//	2. List
//
// Returns
//	New List of type *Employee
//	Empty list if all arguments are nil or either one is nil
func PMapStrEmployeePtr(f func(*string) *Employee, list []*string) []*Employee {
	if f == nil {
		return []*Employee{}
	}

	ch := make(chan map[int]*Employee)
	var wg sync.WaitGroup

	for i, v := range list {
		wg.Add(1)

		go func(wg *sync.WaitGroup, ch chan map[int]*Employee, i int, v *string) {
			defer wg.Done()
			ch <- map[int]*Employee{i: f(v)}
		}(&wg, ch, i, v)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	newList := make([]*Employee, len(list))
	for m := range ch {
		for k, v := range m {
			newList[k] = v
		}
	}
	return newList
}

// PMapStrEmployeePtrErr applies the function(1st argument) on each item of the list and returns new list and error.
// Run in parallel. no_of_goroutines = no_of_items_in_list
//
// Takes 2 inputs
//	1. Function - takes 1 input type: *string output type: (*Employee, error)
//	2. List
//
// Returns
//	New List of type (*Employee, error)
//	Empty list if all arguments are nil or either one is nil
func PMapStrEmployeePtrErr(f func(*string) (*Employee, error), list []*string) ([]*Employee, error) {
	if f == nil {
		return []*Employee{}, nil
	}

	ch := make(chan map[int]*Employee, len(list))
	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i, v := range list {
		wg.Add(1)

		go func(wg *sync.WaitGroup, ch chan map[int]*Employee, i int, v *string) {
			defer wg.Done()
			if len(errCh) >= 1 {
				return
			}
			r, err := f(v)
			if err != nil {
				errCh <- err
				return
			}
			ch <- map[int]*Employee{i: r}
		}(&wg, ch, i, v)
	}

	wg.Wait()
	close(ch)
	close(errCh)
	
	for err := range errCh {
		if err != nil {
			return nil, err
		}
	}

	newList := make([]*Employee, len(list))
	for m := range ch {
		for k, v := range m {
			newList[k] = v
		}
	}
	return newList, nil
}

// FilterMapStrEmployee filters given list, then apply function(2nd argument) on each item in the list and returns a new list
// Takes 3 inputs
//	1. Function: takes one input type - string and returns true/false.
//	2. Function: takes string as argument and returns Employee
// 	3. List of type string
//
// Returns:
//	New List of type Employee
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapStrEmployee(fFilter func(string) bool, fMap func(string) Employee, list []string) []Employee {
	if fFilter == nil || fMap == nil {
		return []Employee{}
	}
	var newList []Employee
	for _, v := range list {
		if fFilter(v) {
			newList = append(newList, fMap(v))
		}
	}
	return newList
}

// FilterMapStrEmployeePtrErr filters given list, then apply function(2nd argument) on each item in the list and returns a new list, error
// Takes 3 inputs
//	1. Function: takes one input type - *string and returns (bool, error).
//	2. Function: takes *string as argument and returns (*Employee, error)
// 	3. List of type *string
//
// Returns:
//	New List of type *Employee, error
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapStrEmployeePtrErr(fFilter func(*string) (bool, error), fMap func(*string) (*Employee, error), list []*string) ([]*Employee, error) {
	if fFilter == nil || fMap == nil {
		return []*Employee{}, nil
	}
	var newList []*Employee
	for _, v := range list {
		r, err := fFilter(v)
		if err != nil {
			return nil, err
		}
		if r {
			r, err := fMap(v)
			if err != nil {
				return nil, err
			}
			newList = append(newList, r)
		}
	}
	return newList, nil
}

// FilterMapStrEmployeeErr filters given list, then apply function(2nd argument) on each item in the list and returns a new list, error
// Takes 3 inputs
//	1. Function: takes one input type - string and returns (bool, error).
//	2. Function: takes string as argument and returns (Employee, error)
// 	3. List of type string
//
// Returns:
//	New List of type Employee, error
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapStrEmployeeErr(fFilter func(string) (bool, error), fMap func(string) (Employee, error), list []string) ([]Employee, error) {
	if fFilter == nil || fMap == nil {
		return []Employee{}, nil
	}
	var newList []Employee
	for _, v := range list {
		r, err := fFilter(v)
		if err != nil {
			return nil, err
		}
		if r {
			r, err := fMap(v)
			if err != nil {
				return nil, err
			}
			newList = append(newList, r)
		}
	}
	return newList, nil
}

// MapStrTeacher takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list
func MapStrTeacher(f func(string) Teacher, list []string) []Teacher {
	if f == nil {
		return []Teacher{}
	}
	newList := make([]Teacher, len(list))
	for i, v := range list {
		newList[i] = f(v)
	}
	return newList
}

// MapStrTeacherErr takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list and error
func MapStrTeacherErr(f func(string) (Teacher, error), list []string) ([]Teacher, error) {
	if f == nil {
		return []Teacher{}, nil
	}
	newList := make([]Teacher, len(list))
	for i, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		newList[i] = r
	}
	return newList, nil
}

// MapStrTeacherPtr takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list
func MapStrTeacherPtr(f func(*string) *Teacher, list []*string) []*Teacher {
	if f == nil {
		return []*Teacher{}
	}
	newList := make([]*Teacher, len(list))
	for i, v := range list {
		newList[i] = f(v)
	}
	return newList
}

// MapStrTeacherPtrErr takes two inputs -
// 1. Function 2. List. Then It returns a new list after applying the function on each item of the list, error
func MapStrTeacherPtrErr(f func(*string) (*Teacher, error), list []*string) ([]*Teacher, error) {
	if f == nil {
		return []*Teacher{}, nil
	}
	newList := make([]*Teacher, len(list))
	for i, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		newList[i] = r
	}
	return newList, nil
}

// PMapStrTeacher applies the function(1st argument) on each item of the list and returns new list.
// Run in parallel. no_of_goroutines = no_of_items_in_list
//
// Takes 2 inputs
//	1. Function - takes 1 input type: string output type: Teacher
//	2. List
//
// Returns
//	New List of type Teacher
//	Empty list if all arguments are nil or either one is nil
func PMapStrTeacher(f func(string) Teacher, list []string) []Teacher {
	if f == nil {
		return []Teacher{}
	}

	ch := make(chan map[int]Teacher)
	var wg sync.WaitGroup

	for i, v := range list {
		wg.Add(1)

		go func(wg *sync.WaitGroup, ch chan map[int]Teacher, i int, v string) {
			defer wg.Done()
			ch <- map[int]Teacher{i: f(v)}
		}(&wg, ch, i, v)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	newList := make([]Teacher, len(list))
	for m := range ch {
		for k, v := range m {
			newList[k] = v
		}
	}
	return newList
}

// PMapStrTeacherErr applies the function(1st argument) on each item of the list and returns new list and error.
// Run in parallel. no_of_goroutines = no_of_items_in_list
//
// Takes 2 inputs
//	1. Function - takes 1 input type: string output type: (Teacher, error)
//	2. List
//
// Returns
//	New List of type (Teacher, error)
//	Empty list if all arguments are nil or either one is nil
func PMapStrTeacherErr(f func(string) (Teacher, error), list []string) ([]Teacher, error) {
	if f == nil {
		return []Teacher{}, nil
	}

	ch := make(chan map[int]Teacher, len(list))
	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i, v := range list {
		wg.Add(1)

		go func(wg *sync.WaitGroup, ch chan map[int]Teacher, i int, v string) {
			defer wg.Done()
			if len(errCh) >= 1 {
				return
			}
			r, err := f(v)
			if err != nil {
				errCh <- err
				return
			}
			ch <- map[int]Teacher{i: r}
		}(&wg, ch, i, v)
	}

	wg.Wait()
	close(ch)
	close(errCh)

	for err := range errCh {
		if err != nil {
			return nil, err
		}
	}

	newList := make([]Teacher, len(list))
	for m := range ch {
		for k, v := range m {
			newList[k] = v
		}
	}
	return newList, nil
}

// PMapStrTeacherPtr applies the function(1st argument) on each item of the list and returns new list.
// Run in parallel. no_of_goroutines = no_of_items_in_list
//
// Takes 2 inputs
//	1. Function - takes 1 input type: *string output type: *Teacher
//	2. List
//
// Returns
//	New List of type *Teacher
//	Empty list if all arguments are nil or either one is nil
func PMapStrTeacherPtr(f func(*string) *Teacher, list []*string) []*Teacher {
	if f == nil {
		return []*Teacher{}
	}

	ch := make(chan map[int]*Teacher)
	var wg sync.WaitGroup

	for i, v := range list {
		wg.Add(1)

		go func(wg *sync.WaitGroup, ch chan map[int]*Teacher, i int, v *string) {
			defer wg.Done()
			ch <- map[int]*Teacher{i: f(v)}
		}(&wg, ch, i, v)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	newList := make([]*Teacher, len(list))
	for m := range ch {
		for k, v := range m {
			newList[k] = v
		}
	}
	return newList
}

// PMapStrTeacherPtrErr applies the function(1st argument) on each item of the list and returns new list and error.
// Run in parallel. no_of_goroutines = no_of_items_in_list
//
// Takes 2 inputs
//	1. Function - takes 1 input type: *string output type: (*Teacher, error)
//	2. List
//
// Returns
//	New List of type (*Teacher, error)
//	Empty list if all arguments are nil or either one is nil
func PMapStrTeacherPtrErr(f func(*string) (*Teacher, error), list []*string) ([]*Teacher, error) {
	if f == nil {
		return []*Teacher{}, nil
	}

	ch := make(chan map[int]*Teacher, len(list))
	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i, v := range list {
		wg.Add(1)

		go func(wg *sync.WaitGroup, ch chan map[int]*Teacher, i int, v *string) {
			defer wg.Done()
			if len(errCh) >= 1 {
				return
			}
			r, err := f(v)
			if err != nil {
				errCh <- err
				return
			}
			ch <- map[int]*Teacher{i: r}
		}(&wg, ch, i, v)
	}

	wg.Wait()
	close(ch)
	close(errCh)
	
	for err := range errCh {
		if err != nil {
			return nil, err
		}
	}

	newList := make([]*Teacher, len(list))
	for m := range ch {
		for k, v := range m {
			newList[k] = v
		}
	}
	return newList, nil
}

// FilterMapStrTeacher filters given list, then apply function(2nd argument) on each item in the list and returns a new list
// Takes 3 inputs
//	1. Function: takes one input type - string and returns true/false.
//	2. Function: takes string as argument and returns Teacher
// 	3. List of type string
//
// Returns:
//	New List of type Teacher
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapStrTeacher(fFilter func(string) bool, fMap func(string) Teacher, list []string) []Teacher {
	if fFilter == nil || fMap == nil {
		return []Teacher{}
	}
	var newList []Teacher
	for _, v := range list {
		if fFilter(v) {
			newList = append(newList, fMap(v))
		}
	}
	return newList
}

// FilterMapStrTeacherPtrErr filters given list, then apply function(2nd argument) on each item in the list and returns a new list, error
// Takes 3 inputs
//	1. Function: takes one input type - *string and returns (bool, error).
//	2. Function: takes *string as argument and returns (*Teacher, error)
// 	3. List of type *string
//
// Returns:
//	New List of type *Teacher, error
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapStrTeacherPtrErr(fFilter func(*string) (bool, error), fMap func(*string) (*Teacher, error), list []*string) ([]*Teacher, error) {
	if fFilter == nil || fMap == nil {
		return []*Teacher{}, nil
	}
	var newList []*Teacher
	for _, v := range list {
		r, err := fFilter(v)
		if err != nil {
			return nil, err
		}
		if r {
			r, err := fMap(v)
			if err != nil {
				return nil, err
			}
			newList = append(newList, r)
		}
	}
	return newList, nil
}

// FilterMapStrTeacherErr filters given list, then apply function(2nd argument) on each item in the list and returns a new list, error
// Takes 3 inputs
//	1. Function: takes one input type - string and returns (bool, error).
//	2. Function: takes string as argument and returns (Teacher, error)
// 	3. List of type string
//
// Returns:
//	New List of type Teacher, error
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapStrTeacherErr(fFilter func(string) (bool, error), fMap func(string) (Teacher, error), list []string) ([]Teacher, error) {
	if fFilter == nil || fMap == nil {
		return []Teacher{}, nil
	}
	var newList []Teacher
	for _, v := range list {
		r, err := fFilter(v)
		if err != nil {
			return nil, err
		}
		if r {
			r, err := fMap(v)
			if err != nil {
				return nil, err
			}
			newList = append(newList, r)
		}
	}
	return newList, nil
}


type byNameEmployee []Employee

func (a byNameEmployee) Len() int           { return len(a) }
func (a byNameEmployee) Less(i, j int) bool { return a[i].Name < a[j].Name }
func (a byNameEmployee) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortEmployeeByName sort structs
func SortEmployeeByName(list []Employee) []Employee {
	if len(list) == 0 {
		return []Employee{}
	}
	newList := make([]Employee, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byNameEmployee(newList))
	return newList
}

// SortEmployeeByNamePtr sorts structs
func SortEmployeeByNamePtr(list []*Employee) []*Employee {
	if len(list) == 0 {
		return []*Employee{}
	}
	newList := make([]Employee, len(list))
	newListPtr := make([]*Employee, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byNameEmployee(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}

type byNameEmployeeDesc []Employee

func (a byNameEmployeeDesc) Len() int           { return len(a) }
func (a byNameEmployeeDesc) Less(i, j int) bool { return a[i].Name > a[j].Name }
func (a byNameEmployeeDesc) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortEmployeeByNameDesc sorts structs
func SortEmployeeByNameDesc(list []Employee) []Employee {
	if len(list) == 0 {
		return []Employee{}
	}
	newList := make([]Employee, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byNameEmployeeDesc(newList))
	return newList
}

// SortEmployeeByNameDescPtr sorts structs
func SortEmployeeByNameDescPtr(list []*Employee) []*Employee {
	if len(list) == 0 {
		return []*Employee{}
	}
	newList := make([]Employee, len(list))
	newListPtr := make([]*Employee, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byNameEmployeeDesc(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}
type bySalaryEmployee []Employee

func (a bySalaryEmployee) Len() int           { return len(a) }
func (a bySalaryEmployee) Less(i, j int) bool { return a[i].Salary < a[j].Salary }
func (a bySalaryEmployee) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortEmployeeBySalary sort structs
func SortEmployeeBySalary(list []Employee) []Employee {
	if len(list) == 0 {
		return []Employee{}
	}
	newList := make([]Employee, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(bySalaryEmployee(newList))
	return newList
}

// SortEmployeeBySalaryPtr sorts structs
func SortEmployeeBySalaryPtr(list []*Employee) []*Employee {
	if len(list) == 0 {
		return []*Employee{}
	}
	newList := make([]Employee, len(list))
	newListPtr := make([]*Employee, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(bySalaryEmployee(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}

type bySalaryEmployeeDesc []Employee

func (a bySalaryEmployeeDesc) Len() int           { return len(a) }
func (a bySalaryEmployeeDesc) Less(i, j int) bool { return a[i].Salary > a[j].Salary }
func (a bySalaryEmployeeDesc) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortEmployeeBySalaryDesc sorts structs
func SortEmployeeBySalaryDesc(list []Employee) []Employee {
	if len(list) == 0 {
		return []Employee{}
	}
	newList := make([]Employee, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(bySalaryEmployeeDesc(newList))
	return newList
}

// SortEmployeeBySalaryDescPtr sorts structs
func SortEmployeeBySalaryDescPtr(list []*Employee) []*Employee {
	if len(list) == 0 {
		return []*Employee{}
	}
	newList := make([]Employee, len(list))
	newListPtr := make([]*Employee, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(bySalaryEmployeeDesc(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}
// UnionEmployeeByName return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionEmployeeByName(arrList ...[]Employee) []Employee {
	resultMap := make(map[string]bool)
	var resultArr []Employee
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.Name]
			if !ok {
				resultMap[v.Name] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// Union<FTYPE>Ptr return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionEmployeeByNamePtr(arrList ...[]*Employee) []*Employee {
	resultMap := make(map[string]bool)
	var resultArr []*Employee
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.Name]
			if !ok {
				resultMap[v.Name] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// IntersectionEmployeeByName return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionEmployeeByName(arrList ...[]Employee) []Employee {
	if arrList == nil {
		return []Employee{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []Employee
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Name]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Name] = true
			}
		}
		return newList
	}

	var newList []Employee
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Name == v.Name {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].Name]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Name] = true
			}
		}
	}
	return newList
}

// IntersectionEmployeeByNamePtr return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionEmployeeByNamePtr(arrList ...[]*Employee) []*Employee {
	if arrList == nil {
		return []*Employee{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []*Employee
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Name]
			if !ok {
				resultMap[arrList[0][i].Name] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Employee
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Name == v.Name {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].Name]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Name] = true
			}
		}
	}
	return newList
}

// DifferenceEmployeeByName returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceEmployeeByName(arrList ...[]Employee) []Employee {
	if arrList == nil {
		return []Employee{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []Employee
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Name]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Name] = true
			}
		}
		return newList
	}

	var newList []Employee
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Name == v.Name {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].Name]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Name] = true
			}
		}
	}
	return newList
}

// DifferenceEmployeeByNamePtr returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceEmployeeByNamePtr(arrList ...[]*Employee) []*Employee {
	if arrList == nil {
		return []*Employee{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []*Employee
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Name]
			if !ok {
				resultMap[arrList[0][i].Name] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Employee
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Name == v.Name {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].Name]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Name] = true
			}
		}
	}
	return newList
}

// SubsetEmployeeByName returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetEmployeeByName(list1, list2 []Employee) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].Name]
		if !ok {
			found := false
			resultMap[list1[i].Name] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].Name == list2[j].Name {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SubsetEmployeeByNamePtr returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetEmployeeByNamePtr(list1, list2 []*Employee) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].Name]
		if !ok {
			found := false
			resultMap[list1[i].Name] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].Name == list2[j].Name {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetEmployeeByName returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetEmployeeByName(list1, list2 []Employee) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].Name]
		if !ok {
			found := false
			resultMap[list2[i].Name] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].Name == list1[j].Name {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetEmployeeByNamePtr returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetEmployeeByNamePtr(list1, list2 []*Employee) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].Name]
		if !ok {
			found := false
			resultMap[list2[i].Name] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].Name == list1[j].Name {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SetEmployeeByName returns a set of the distinct elements of coll.
func SetEmployeeByName(list []Employee) []Employee {
	if list == nil || len(list) == 0 {
		return []Employee{}
	}

	resultMap := make(map[string]bool)
	newList := []Employee{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].Name]
		if !ok {
			resultMap[list[i].Name] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}

// SetEmployeeByNamePtr returns a set of the distinct elements of coll.
func SetEmployeeByNamePtr(list []*Employee) []*Employee {
	if list == nil || len(list) == 0 {
		return []*Employee{}
	}

	resultMap := make(map[string]bool)
	newList := []*Employee{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].Name]
		if !ok {
			resultMap[list[i].Name] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}
// UnionEmployeeBySalary return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionEmployeeBySalary(arrList ...[]Employee) []Employee {
	resultMap := make(map[float64]bool)
	var resultArr []Employee
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.Salary]
			if !ok {
				resultMap[v.Salary] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// Union<FTYPE>Ptr return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionEmployeeBySalaryPtr(arrList ...[]*Employee) []*Employee {
	resultMap := make(map[float64]bool)
	var resultArr []*Employee
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.Salary]
			if !ok {
				resultMap[v.Salary] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// IntersectionEmployeeBySalary return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionEmployeeBySalary(arrList ...[]Employee) []Employee {
	if arrList == nil {
		return []Employee{}
	}

	resultMap := make(map[float64]bool)
	if len(arrList) == 1 {
		var newList []Employee
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Salary]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Salary] = true
			}
		}
		return newList
	}

	var newList []Employee
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Salary == v.Salary {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].Salary]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Salary] = true
			}
		}
	}
	return newList
}

// IntersectionEmployeeBySalaryPtr return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionEmployeeBySalaryPtr(arrList ...[]*Employee) []*Employee {
	if arrList == nil {
		return []*Employee{}
	}

	resultMap := make(map[float64]bool)
	if len(arrList) == 1 {
		var newList []*Employee
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Salary]
			if !ok {
				resultMap[arrList[0][i].Salary] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Employee
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Salary == v.Salary {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].Salary]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Salary] = true
			}
		}
	}
	return newList
}

// DifferenceEmployeeBySalary returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceEmployeeBySalary(arrList ...[]Employee) []Employee {
	if arrList == nil {
		return []Employee{}
	}

	resultMap := make(map[float64]bool)
	if len(arrList) == 1 {
		var newList []Employee
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Salary]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Salary] = true
			}
		}
		return newList
	}

	var newList []Employee
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Salary == v.Salary {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].Salary]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Salary] = true
			}
		}
	}
	return newList
}

// DifferenceEmployeeBySalaryPtr returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceEmployeeBySalaryPtr(arrList ...[]*Employee) []*Employee {
	if arrList == nil {
		return []*Employee{}
	}

	resultMap := make(map[float64]bool)
	if len(arrList) == 1 {
		var newList []*Employee
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Salary]
			if !ok {
				resultMap[arrList[0][i].Salary] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Employee
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Salary == v.Salary {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].Salary]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Salary] = true
			}
		}
	}
	return newList
}

// SubsetEmployeeBySalary returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetEmployeeBySalary(list1, list2 []Employee) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[float64]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].Salary]
		if !ok {
			found := false
			resultMap[list1[i].Salary] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].Salary == list2[j].Salary {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SubsetEmployeeBySalaryPtr returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetEmployeeBySalaryPtr(list1, list2 []*Employee) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[float64]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].Salary]
		if !ok {
			found := false
			resultMap[list1[i].Salary] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].Salary == list2[j].Salary {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetEmployeeBySalary returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetEmployeeBySalary(list1, list2 []Employee) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[float64]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].Salary]
		if !ok {
			found := false
			resultMap[list2[i].Salary] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].Salary == list1[j].Salary {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetEmployeeBySalaryPtr returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetEmployeeBySalaryPtr(list1, list2 []*Employee) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[float64]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].Salary]
		if !ok {
			found := false
			resultMap[list2[i].Salary] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].Salary == list1[j].Salary {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SetEmployeeBySalary returns a set of the distinct elements of coll.
func SetEmployeeBySalary(list []Employee) []Employee {
	if list == nil || len(list) == 0 {
		return []Employee{}
	}

	resultMap := make(map[float64]bool)
	newList := []Employee{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].Salary]
		if !ok {
			resultMap[list[i].Salary] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}

// SetEmployeeBySalaryPtr returns a set of the distinct elements of coll.
func SetEmployeeBySalaryPtr(list []*Employee) []*Employee {
	if list == nil || len(list) == 0 {
		return []*Employee{}
	}

	resultMap := make(map[float64]bool)
	newList := []*Employee{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].Salary]
		if !ok {
			resultMap[list[i].Salary] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}