// Code generated by 'gofp'. DO NOT EDIT.
package employee
import "reflect" 
import "sort" 
import "sync" 
import "time"
import "github.com/logic-building/functional-go/fp" 

func MapTeacher(f func(Teacher) Teacher, list []Teacher) []Teacher {
	if f == nil {
		return []Teacher{}
	}
	newList := make([]Teacher, len(list))
	for i, v := range list {
		newList[i] = f(v)
	}
	return newList
}

func MapTeacherPtr(f func(*Teacher) *Teacher, list []*Teacher) []*Teacher {
	if f == nil {
		return []*Teacher{}
	}
	newList := make([]*Teacher, len(list))
	for i, v := range list {
		newList[i] = f(v)
	}
	return newList
}

// MapTeacherPtrErr takes 2 arguments:
//  1. A function input argument: *Teacher and return types (*Teacher, error)
//  2. A list of type []*Teacher
//
// Returns:
// 	([]*Teacher, error)
func MapTeacherPtrErr(f func(*Teacher) (*Teacher, error), list []*Teacher) ([]*Teacher, error) {
	if f == nil {
		return []*Teacher{}, nil
	}
	newList := make([]*Teacher, len(list))
	for i, v := range list {
		var err error
		newList[i], err = f(v)
		if err != nil {
			return nil, err
		}
	}
	return newList, nil
}

// MapTeacherErr takes 2 arguments:
//  1. A function input argument: Teacher and return types (Teacher, error)
//  2. A list of type []Teacher
//
// Returns:
// 	([]Teacher, error)
func MapTeacherErr(f func(Teacher) (Teacher, error), list []Teacher) ([]Teacher, error) {
	if f == nil {
		return []Teacher{}, nil
	}
	newList := make([]Teacher, len(list))
	for i, v := range list {
		var err error
		newList[i], err = f(v)
		if err != nil {
			return nil, err
		}
	}
	return newList, nil
}

func FilterTeacher(f func(Teacher) bool, list []Teacher) []Teacher {
	if f == nil {
		return []Teacher{}
	}
	var newList []Teacher
	for _, v := range list {
		if f(v) {
			newList = append(newList, v)
		}
	}
	return newList
}

func FilterTeacherPtr(f func(*Teacher) bool, list []*Teacher) []*Teacher {
	if f == nil {
		return []*Teacher{}
	}
	var newList []*Teacher
	for _, v := range list {
		if f(v) {
			newList = append(newList, v)
		}
	}
	return newList
}

// FilterTeacherPtrErr takes two arguments
//  1. Function: takes 1 argument of type Teacher and returns (bool, error)
//  2. slice of type []*Teacher
//
// Returns:
//  new filtered list and error
func FilterTeacherPtrErr(f func(*Teacher) (bool, error), list []*Teacher) ([]*Teacher, error) {
	if f == nil {
		return []*Teacher{}, nil
	}
	var newList []*Teacher
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if r {
			newList = append(newList, v)
		}
	}
	return newList, nil
}

// FilterTeacherErr takes two arguments
//  1. Function: takes 1 argument of type Teacher and returns (bool, error)
//  2. slice of type []Teacher
//
// Returns:
//  new filtered list and error
func FilterTeacherErr(f func(Teacher) (bool, error), list []Teacher) ([]Teacher, error) {
	if f == nil {
		return []Teacher{}, nil
	}
	var newList []Teacher
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if r {
			newList = append(newList, v)
		}
	}
	return newList, nil
}

func RemoveTeacher(f func(Teacher) bool, list []Teacher) []Teacher {
	if f == nil {
		return []Teacher{}
	}
	var newList []Teacher
	for _, v := range list {
		if !f(v) {
			newList = append(newList, v)
		}
	}
	return newList
}

func RemoveTeacherPtr(f func(*Teacher) bool, list []*Teacher) []*Teacher {
	if f == nil {
		return []*Teacher{}
	}
	var newList []*Teacher
	for _, v := range list {
		if !f(v) {
			newList = append(newList, v)
		}
	}
	return newList
}

// RemoveTeacherPtrErr removes the items from the given list based on supplied function and returns new list
//
// Takes 2 inputs:
//	1. Function: input type *Teacher and return types(bool, error)
//	2. List of type: []*Teacher
//
// Returns:
//	New list and error: ([]*Teacher, error)
//	Empty list if both of arguments are nil or either one is nil.
func RemoveTeacherPtrErr(f func(*Teacher) (bool, error), list []*Teacher) ([]*Teacher, error) {
	if f == nil {
		return []*Teacher{}, nil
	}
	var newList []*Teacher
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if !r {
			newList = append(newList, v)
		}
	}
	return newList, nil
}

// RemoveTeacherErr removes the items from the given list based on supplied function and returns new list
//
// Takes 2 inputs:
//	1. Function: input type Teacher and return types(bool, error)
//	2. List of type: []Teacher
//
// Returns:
//	New list and error: ([]Teacher, error)
//	Empty list if both of arguments are nil or either one is nil.
func RemoveTeacherErr(f func(Teacher) (bool, error), list []Teacher) ([]Teacher, error) {
	if f == nil {
		return []Teacher{}, nil
	}
	var newList []Teacher
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if !r {
			newList = append(newList, v)
		}
	}
	return newList, nil
}

func SomeTeacher(f func(Teacher) bool, list []Teacher) bool {
	if f == nil {
		return false
	}
	for _, v := range list {
		if f(v) {
			return true
		}
	}
	return false
}

func SomeTeacherPtr(f func(*Teacher) bool, list []*Teacher) bool {
	if f == nil {
		return false
	}
	for _, v := range list {
		if f(v) {
			return true
		}
	}
	return false
}

// SomeTeacherPtrErr finds item in the list based on supplied function.
//
// Takes 2 input:
//	1. Function
//	2. List
//
// Returns:
//	(bool,err).
//	True if condition satisfies, else false
func SomeTeacherPtrErr(f func(*Teacher) (bool, error), list []*Teacher) (bool, error) {
	if f == nil {
		return false, nil
	}
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return false, err
		}
		if r {
			return true, nil
		}
	}
	return false, nil
}

// SomeTeacherErr finds item in the list based on supplied function.
//
// Takes 2 input:
//	1. Function
//	2. List
//
// Returns:
//	(bool,err).
//	True if condition satisfies, else false
func SomeTeacherErr(f func(Teacher) (bool, error), list []Teacher) (bool, error) {
	if f == nil {
		return false, nil
	}
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return false, err
		}
		if r {
			return true, nil
		}
	}
	return false, nil
}

func EveryTeacher(f func(Teacher) bool, list []Teacher) bool {
	if f == nil || len(list) == 0 {
		return false
	}
	for _, v := range list {
		if !f(v) {
			return false
		}
	}
	return true
}

func EveryTeacherPtr(f func(*Teacher) bool, list []*Teacher) bool {
	if f == nil || len(list) == 0 {
		return false
	}
	for _, v := range list {
		if !f(v) {
			return false
		}
	}
	return true
}

// EveryTeacherPtrErr returns true if supplied function returns logical true for every item in the list
func EveryTeacherPtrErr(f func(*Teacher) (bool, error), list []*Teacher) (bool, error) {
	if f == nil || len(list) == 0 {
		return false, nil
	}
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return false, err
		}
		if !r {
			return false, nil
		}
	}
	return true, nil
}

// EveryTeacherErr returns true if supplied function returns logical true for every item in the list
func EveryTeacherErr(f func(Teacher) (bool, error), list []Teacher) (bool, error) {
	if f == nil || len(list) == 0 {
		return false, nil
	}
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return false, err
		}
		if !r {
			return false, nil
		}
	}
	return true, nil
}

func DropWhileTeacher(f func(Teacher) bool, list []Teacher) []Teacher {
	if f == nil {
		return []Teacher{}
	}
	var newList []Teacher
	for i, v := range list {
		if !f(v) {
			listLen := len(list)
			newList = make([]Teacher, listLen-i)
			j := 0
			for i < listLen {
				newList[j] = list[i]
				i++
				j++
			}
			return newList
		}
	}
	return newList
}

func DropWhileTeacherPtr(f func(*Teacher) bool, list []*Teacher) []*Teacher {
	if f == nil {
		return []*Teacher{}
	}
	var newList []*Teacher
	for i, v := range list {
		if !f(v) {
			listLen := len(list)
			newList = make([]*Teacher, listLen-i)
			j := 0
			for i < listLen {
				newList[j] = list[i]
				i++
				j++
			}
			return newList
		}
	}
	return newList
}

// DropWhileTeacherPtrErr drops the items from the list as long as condition satisfies.
//
// Takes two inputs
//	1. Function: takes one input and returns (boolean, error)
//	2. list
//
// Returns:
// 	New List, error
//  Empty list if either one of arguments or both of them are nil
func DropWhileTeacherPtrErr(f func(*Teacher) (bool, error), list []*Teacher) ([]*Teacher, error) {
	if f == nil {
		return []*Teacher{}, nil
	}
	var newList []*Teacher
	for i, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if !r {
			listLen := len(list)
			newList = make([]*Teacher, listLen-i)
			j := 0
			for i < listLen {
				newList[j] = list[i]
				i++
				j++
			}
			return newList, nil
		}
	}
	return newList, nil
}

// DropWhileTeacherErr drops the items from the list as long as condition satisfies.
//
// Takes two inputs
//	1. Function: takes one input and returns (boolean, error)
//	2. list
//
// Returns:
// 	New List, error
//  Empty list if either one of arguments or both of them are nil
func DropWhileTeacherErr(f func(Teacher) (bool, error), list []Teacher) ([]Teacher, error) {
	if f == nil {
		return []Teacher{}, nil
	}
	var newList []Teacher
	for i, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if !r {
			listLen := len(list)
			newList = make([]Teacher, listLen-i)
			j := 0
			for i < listLen {
				newList[j] = list[i]
				i++
				j++
			}
			return newList, nil
		}
	}
	return newList, nil
}

func TakeWhileTeacher(f func(Teacher) bool, list []Teacher) []Teacher {
	if f == nil {
		return []Teacher{}
	}
	var newList []Teacher
	for _, v := range list {
		if !f(v) {
			return newList
		}
		newList = append(newList, v)
	}
	return newList
}

func TakeWhileTeacherPtr(f func(*Teacher) bool, list []*Teacher) []*Teacher {
	if f == nil {
		return []*Teacher{}
	}
	var newList []*Teacher
	for _, v := range list {
		if !f(v) {
			return newList
		}
		newList = append(newList, v)
	}
	return newList
}

// TakeWhileTeacherPtrErr returns new list based on condition in the supplied function. It returns new list once condition fails.
//
// Takes 2 inputs:
//	1. Function - 1 input of type *Teacher and returns ([]*Teacher, error)
//	2. List
//
// Returns:
//	New List, error.
//	Empty list if all the parameters are nil or either of one parameter is nil
func TakeWhileTeacherPtrErr(f func(*Teacher) (bool, error), list []*Teacher) ([]*Teacher, error) {
	if f == nil {
		return []*Teacher{}, nil
	}
	var newList []*Teacher
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if !r {
			return newList, nil
		}
		newList = append(newList, v)
	}
	return newList, nil
}

// TakeWhileTeacherErr returns new list based on condition in the supplied function. It returns new list once condition fails.
//
// Takes 2 inputs:
//	1. Function - 1 input of type Teacher and returns ([]Teacher, error)
//	2. List
//
// Returns:
//	New List, error.
//	Empty list if all the parameters are nil or either of one parameter is nil
func TakeWhileTeacherErr(f func(Teacher) (bool, error), list []Teacher) ([]Teacher, error) {
	if f == nil {
		return []Teacher{}, nil
	}
	var newList []Teacher
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if !r {
			return newList, nil
		}
		newList = append(newList, v)
	}
	return newList, nil
}

// PMapTeacher applies the function(1st argument) on each item in the list and returns a new list.
//  Order of new list is guaranteed. This feature can be disabled by passing: Optional{RandomOrder: true} to gain performance
//  Run in parallel. no_of_goroutines = no_of_items_in_list or 3rd argument can be passed to fix the number of goroutines.
//
// Takes 3 inputs. 3rd argument is optional
//  1. Function - takes 1 input
//  2. List
//  3. optional argument - fp.Optional{FixedPool: <some_number>}
func PMapTeacher(f func(Teacher) Teacher, list []Teacher, optional ...fp.Optional) []Teacher {
	if f == nil {
		return []Teacher{}
	}

	var worker = len(list)
	if optional != nil && len(optional) > 0 {
		if optional[0].FixedPool > 0 && optional[0].FixedPool < worker {
			worker = optional[0].FixedPool
		}

		if optional[0].RandomOrder == true {
			return pMapTeacherNoOrder(f, list, worker)
		}
	}

	return pMapTeacherPreserveOrder(f, list, worker)
}

func pMapTeacherPreserveOrder(f func(Teacher) Teacher, list []Teacher, worker int) []Teacher {
	chJobs := make(chan map[int]Teacher, len(list))
	go func() {
		for i, v := range list {
			chJobs <- map[int]Teacher{i: v}
		}
		close(chJobs)
	}()

	chResult := make(chan map[int]Teacher, worker/3)

	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan map[int]Teacher, chJobs chan map[int]Teacher) {
			defer wg.Done()

			for m := range chJobs {
				for k, v := range m {
					chResult <- map[int]Teacher{k: f(v)}
				}
			}
		}(chResult, chJobs)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newListMap := make(map[int]Teacher, len(list))
	newList := make([]Teacher, len(list))

	for m := range chResult {
		for k, v := range m {
			newListMap[k] = v
		}
	}

	for i := 0; i < len(list); i++ {
		newList[i] = newListMap[i]
	}

	return newList
}

func pMapTeacherNoOrder(f func(Teacher) Teacher, list []Teacher, worker int) []Teacher {
	chJobs := make(chan Teacher, len(list))
	go func() {
		for _, v := range list {
			chJobs <- v
		}
		close(chJobs)
	}()

	chResult := make(chan Teacher, worker/3)

	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan Teacher, chJobs chan Teacher) {
			defer wg.Done()

			for v := range chJobs {
				chResult <- f(v)
			}
		}(chResult, chJobs)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newList := make([]Teacher, len(list))
	i := 0

	for v := range chResult {
		newList[i] = v
		i++
	}

	return newList
}

// PMapTeacherPtr applies the function(1st argument) on each item in the list and returns a new list.
//  Order of new list is guaranteed. This feature can be disabled by passing: Optional{RandomOrder: true} to gain performance
//  Run in parallel. no_of_goroutines = no_of_items_in_list or 3rd argument can be passed to fix the number of goroutines.
//
// Takes 3 inputs. 3rd argument is optional
//  1. Function - takes 1 input
//  2. List
//  3. optional argument - fp.Optional{FixedPool: <some_number>}
func PMapTeacherPtr(f func(*Teacher) *Teacher, list []*Teacher, optional ...fp.Optional) []*Teacher {
	if f == nil {
		return []*Teacher{}
	}

	var worker = len(list)
	if optional != nil && len(optional) > 0 {
		if optional[0].FixedPool > 0 && optional[0].FixedPool < worker {
			worker = optional[0].FixedPool
		}

		if optional[0].RandomOrder == true {
			return pMapTeacherPtrNoOrder(f, list, worker)
		}
	}

	return pMapTeacherPtrPreserveOrder(f, list, worker)
}

func pMapTeacherPtrPreserveOrder(f func(*Teacher) *Teacher, list []*Teacher, worker int) []*Teacher {
	chJobs := make(chan map[int]*Teacher, len(list))
	go func() {
		for i, v := range list {
			chJobs <- map[int]*Teacher{i: v}
		}
		close(chJobs)
	}()

	chResult := make(chan map[int]*Teacher, worker/3)

	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan map[int]*Teacher, chJobs chan map[int]*Teacher) {
			defer wg.Done()

			for m := range chJobs {
				for k, v := range m {
					chResult <- map[int]*Teacher{k: f(v)}
				}
			}
		}(chResult, chJobs)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newListMap := make(map[int]*Teacher, len(list))
	newList := make([]*Teacher, len(list))

	for m := range chResult {
		for k, v := range m {
			newListMap[k] = v
		}
	}

	for i := 0; i < len(list); i++ {
		newList[i] = newListMap[i]
	}

	return newList
}

func pMapTeacherPtrNoOrder(f func(*Teacher) *Teacher, list []*Teacher, worker int) []*Teacher {
	chJobs := make(chan *Teacher, len(list))
	go func() {
		for _, v := range list {
			chJobs <- v
		}
		close(chJobs)
	}()

	chResult := make(chan *Teacher, worker/3)

	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan *Teacher, chJobs chan *Teacher) {
			defer wg.Done()

			for v := range chJobs {
				chResult <- f(v)
			}
		}(chResult, chJobs)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newList := make([]*Teacher, len(list))
	i := 0

	for v := range chResult {
		newList[i] = v
		i++
	}

	return newList
}

// PMapTeacherPtrErr applies the function(1st argument) on each item in the list and returns a new list and error.
//  Order of new list is guaranteed. This feature can be disabled by passing: Optional{RandomOrder: true} to gain performance
//  Run in parallel. no_of_goroutines = no_of_items_in_list or 3rd argument can be passed to fix the number of goroutines.
//
// Takes 3 inputs. 3rd argument is optional
//  1. Function - takes 1 input
//  2. List
//  3. optional argument - fp.Optional{FixedPool: <some_number>}
func PMapTeacherPtrErr(f func(*Teacher) (*Teacher, error), list []*Teacher, optional ...fp.Optional) ([]*Teacher, error) {
	if f == nil {
		return []*Teacher{}, nil
	}

	var worker = len(list)
	if optional != nil && len(optional) > 0 {
		if optional[0].FixedPool > 0 && optional[0].FixedPool < worker {
			worker = optional[0].FixedPool
		}

		if optional[0].RandomOrder == true {
			return pMapTeacherPtrErrNoOrder(f, list, worker)
		}
	}

	return pMapTeacherPtrErrPreserveOrder(f, list, worker)
}

func pMapTeacherPtrErrPreserveOrder(f func(*Teacher) (*Teacher, error), list []*Teacher, worker int) ([]*Teacher, error) {
	chJobs := make(chan map[int]*Teacher, len(list))
	go func() {
		for i, v := range list {
			chJobs <- map[int]*Teacher{i: v}
		}
		close(chJobs)
	}()

	chResult := make(chan map[int]*Teacher, worker/3)

	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan map[int]*Teacher, chJobs chan map[int]*Teacher, errCh chan error) {
			defer wg.Done()
			if len(errCh) > 0 {
				return
			}
			for m := range chJobs {
				for k, v := range m {
					r, err := f(v)
					if err != nil {
						errCh <- err
						return
					}
					chResult <- map[int]*Teacher{k: r}
				}
			}
		}(chResult, chJobs, errCh)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newListMap := make(map[int]*Teacher, len(list))
	newList := make([]*Teacher, len(list))

	for m := range chResult {
		select {
		case err := <-errCh:
			return []*Teacher{}, err
		default:
		}
		for k, v := range m {
			newListMap[k] = v
		}
	}

	if len(errCh) > 0 {
		return []*Teacher{}, <-errCh
	}

	for i := 0; i < len(list); i++ {
		newList[i] = newListMap[i]
	}

	return newList, nil
}

func pMapTeacherPtrErrNoOrder(f func(*Teacher) (*Teacher, error), list []*Teacher, worker int) ([]*Teacher, error) {
	chJobs := make(chan *Teacher, len(list))
	go func() {
		for _, v := range list {
			chJobs <- v
		}
		close(chJobs)
	}()

	chResult := make(chan *Teacher, worker/3)

	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan *Teacher, chJobs chan *Teacher, errCh chan error) {
			defer wg.Done()
			if len(errCh) > 0 {
				return
			}
			for v := range chJobs {
				r, err := f(v)
				if err != nil {
					errCh <- err
					return
				}
				chResult <- r
			}
		}(chResult, chJobs, errCh)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newList := make([]*Teacher, len(list))
	i := 0

	for v := range chResult {
		select {
		case err := <-errCh:
			return []*Teacher{}, err
		default:
		}
		newList[i] = v
		i++
	}

	if len(errCh) > 0 {
		return []*Teacher{}, <-errCh
	}

	return newList, nil
}

// PMapTeacherErr applies the function(1st argument) on each item in the list and returns a new list and error.
//  Order of new list is guaranteed. This feature can be disabled by passing: Optional{RandomOrder: true} to gain performance
//  Run in parallel. no_of_goroutines = no_of_items_in_list or 3rd argument can be passed to fix the number of goroutines.
//
// Takes 3 inputs. 3rd argument is optional
//  1. Function - takes 1 input
//  2. List
//  3. optional argument - fp.Optional{FixedPool: <some_number>}
func PMapTeacherErr(f func(Teacher) (Teacher, error), list []Teacher, optional ...fp.Optional) ([]Teacher, error) {
	if f == nil {
		return []Teacher{}, nil
	}

	var worker = len(list)
	if optional != nil && len(optional) > 0 {
		if optional[0].FixedPool > 0 && optional[0].FixedPool < worker {
			worker = optional[0].FixedPool
		}

		if optional[0].RandomOrder == true {
			return pMapTeacherErrNoOrder(f, list, worker)
		}
	}

	return pMapTeacherErrPreserveOrder(f, list, worker)
}

func pMapTeacherErrPreserveOrder(f func(Teacher) (Teacher, error), list []Teacher, worker int) ([]Teacher, error) {
	chJobs := make(chan map[int]Teacher, len(list))
	go func() {
		for i, v := range list {
			chJobs <- map[int]Teacher{i: v}
		}
		close(chJobs)
	}()

	chResult := make(chan map[int]Teacher, worker/3)

	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan map[int]Teacher, chJobs chan map[int]Teacher, errCh chan error) {
			defer wg.Done()
			if len(errCh) > 0 {
				return
			}
			for m := range chJobs {
				for k, v := range m {
					r, err := f(v)
					if err != nil {
						errCh <- err
						return
					}
					chResult <- map[int]Teacher{k: r}
				}
			}
		}(chResult, chJobs, errCh)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newListMap := make(map[int]Teacher, len(list))
	newList := make([]Teacher, len(list))

	for m := range chResult {
		select {
		case err := <-errCh:
			return []Teacher{}, err
		default:
		}
		for k, v := range m {
			newListMap[k] = v
		}
	}

	if len(errCh) > 0 {
		return []Teacher{}, <-errCh
	}

	for i := 0; i < len(list); i++ {
		newList[i] = newListMap[i]
	}

	return newList, nil
}

func pMapTeacherErrNoOrder(f func(Teacher) (Teacher, error), list []Teacher, worker int) ([]Teacher, error) {
	chJobs := make(chan Teacher, len(list))
	go func() {
		for _, v := range list {
			chJobs <- v
		}
		close(chJobs)
	}()

	chResult := make(chan Teacher, worker/3)

	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan Teacher, chJobs chan Teacher, errCh chan error) {
			defer wg.Done()
			if len(errCh) > 0 {
				return
			}
			for v := range chJobs {
				r, err := f(v)
				if err != nil {
					errCh <- err
					return
				}
				chResult <- r
			}
		}(chResult, chJobs, errCh)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newList := make([]Teacher, len(list))
	i := 0

	for v := range chResult {
		select {
		case err := <-errCh:
			return []Teacher{}, err
		default:
		}
		newList[i] = v
		i++
	}

	if len(errCh) > 0 {
		return []Teacher{}, <-errCh
	}

	return newList, nil
}

func FilterMapTeacher(fFilter func(Teacher) bool, fMap func(Teacher) Teacher, list []Teacher) []Teacher {
	if fFilter == nil || fMap == nil {
		return []Teacher{}
	}
	var newList []Teacher
	for _, v := range list {
		if fFilter(v) {
			newList = append(newList, fMap(v))
		}
	}
	return newList
}

func FilterMapTeacherPtr(fFilter func(*Teacher) bool, fMap func(*Teacher) *Teacher, list []*Teacher) []*Teacher {
	if fFilter == nil || fMap == nil {
		return []*Teacher{}
	}
	var newList []*Teacher
	for _, v := range list {
		if fFilter(v) {
			newList = append(newList, fMap(v))
		}
	}
	return newList
}

// FilterMapTeacherPtrErr filters given list, then apply function(2nd argument) on each item in the list and returns a new list
// Takes 3 inputs
//	1. Function: takes one input(*Teacher) and returns (bool, error).
//	2. Function: takes *Teacher as argument and returns (*Teacher, error)
// 	3. Slice of type []*Teacher
//
// Returns:
//	New List ([]*Teacher, error).
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapTeacherPtrErr(fFilter func(*Teacher) (bool, error), fMap func(*Teacher) (*Teacher, error), list []*Teacher) ([]*Teacher, error) {
	if fFilter == nil || fMap == nil {
		return []*Teacher{}, nil
	}
	var newList []*Teacher
	for _, v := range list {
		r, err := fFilter(v)
		if err != nil {
			return nil, err
		}
		if r {
			r, err := fMap(v)
			if err != nil {
				return nil, err
			}
			newList = append(newList, r)
		}
	}
	return newList, nil
}

// FilterMapTeacherErr filters given list, then apply function(2nd argument) on each item in the list and returns a new list
// Takes 3 inputs
//	1. Function: takes one input(Teacher) and returns (bool, error).
//	2. Function: takes Teacher as argument and returns (Teacher, error)
// 	3. Slice of type []Teacher
//
// Returns:
//	New List ([]Teacher, error).
//  Empty list if all there parameters are nil or either of parameter is nil
//
func FilterMapTeacherErr(fFilter func(Teacher) (bool, error), fMap func(Teacher) (Teacher, error), list []Teacher) ([]Teacher, error) {
	if fFilter == nil || fMap == nil {
		return []Teacher{}, nil
	}
	var newList []Teacher
	for _, v := range list {
		r, err := fFilter(v)
		if err != nil {
			return nil, err
		}
		if r {
			r, err := fMap(v)
			if err != nil {
				return nil, err
			}
			newList = append(newList, r)
		}
	}
	return newList, nil
}

func RestTeacher(l []Teacher) []Teacher {
	if l == nil {
		return []Teacher{}
	}

	len := len(l)
	if len == 0 || len == 1 {
		return []Teacher{}
	}

	newList := make([]Teacher, len-1)

	for i, v := range l[1:] {
		newList[i] = v
	}

	return newList
}


// RestTeacher removes 1st item of the list and return new list having rest of the items
func RestTeacherPtr(l []*Teacher) []*Teacher {
	if l == nil {
		return []*Teacher{}
	}

	len := len(l)
	if len == 0 || len == 1 {
		return []*Teacher{}
	}

	newList := make([]*Teacher, len-1)

	for i, v := range l[1:] {
		newList[i] = v
	}

	return newList
}

func ReduceTeacher(f func(Teacher, Teacher) Teacher, list []Teacher, initializer ...Teacher) Teacher {
	var init Teacher 
	lenList := len(list)

	if initializer != nil {
		init = initializer[0]
	} else if lenList > 0 {
		init = list[0]
		if lenList == 1 {
			return list[0]
		}
		if lenList >= 2 {
			list = list[1:]
		}
	}
	
	if lenList == 0 {
		return init
	}
	r := f(init, list[0])
	return ReduceTeacher(f, list[1:], r)
}

func ReduceTeacherPtr(f func(*Teacher, *Teacher) *Teacher, list []*Teacher, initializer ...Teacher) *Teacher {
	var initVal Teacher
	var init *Teacher = &initVal
	lenList := len(list)

	if initializer != nil {
		init = &initializer[0]
	} else if lenList > 0 {
		init = list[0]
		if lenList == 1 {
			return list[0]
		}
		if lenList >= 2 {
			list = list[1:]
		}
	}

	if lenList == 0 {
		return init
	}

	r := f(init, list[0])
	return ReduceTeacherPtr(f, list[1:], *r)
}

// ReduceTeacherPtrErr reduces a list to a single value by combining elements via a supplied function
//
// Takes three inputs
//	A. function - takes two arguments (*Teacher, *Teacher)
//	B. list of type []*Teacher
// 	C. initializer (optional of type Teacher)
//
// Returns:
//	single value, error: (*Teacher, error)
func ReduceTeacherPtrErr(f func(*Teacher, *Teacher) (*Teacher, error), list []*Teacher, initializer ...Teacher) (*Teacher, error) {
	var initVal Teacher
	var init *Teacher = &initVal
	lenList := len(list)

	if initializer != nil {
		init = &initializer[0]
	} else if lenList > 0 {
		init = list[0]
		if lenList == 1 {
			return list[0], nil
		}
		if lenList >= 2 {
			list = list[1:]
		}
	}

	if lenList == 0 {
		return init, nil
	}

	r, err := f(init, list[0])
	if err != nil {
		return nil, err
	}
	return ReduceTeacherPtrErr(f, list[1:], *r)
}

// ReduceTeacherErr reduces a list to a single value by combining elements via a supplied function
//
// Takes three inputs
//	A. function - takes two arguments (Teacher, Teacher)
//	B. list of type []Teacher
// 	C. initializer (optional of type Teacher)
//
// Returns:
//	single value, error: (Teacher, error)
func ReduceTeacherErr(f func(Teacher, Teacher) (Teacher, error), list []Teacher, initializer ...Teacher) (Teacher, error) {
	var initVal Teacher
	var init Teacher = initVal
	lenList := len(list)

	if initializer != nil {
		init = initializer[0]
	} else if lenList > 0 {
		init = list[0]
		if lenList == 1 {
			return list[0], nil
		}
		if lenList >= 2 {
			list = list[1:]
		}
	}

	if lenList == 0 {
		return init, nil
	}

	r, err := f(init, list[0])
	if err != nil {
		return r, err
	}
	return ReduceTeacherErr(f, list[1:], r)
}

// DropLastTeacher drops last item from the list and returns new list.
// Returns empty list if there is only one item in the list or list empty
func DropLastTeacher(list []Teacher) []Teacher {
	listLen := len(list)

	if list == nil || listLen == 0 || listLen == 1 {
		return []Teacher{}
	}

	newList := make([]Teacher, listLen-1)

	for i := 0; i < listLen-1; i++ {
		newList[i] = list[i]
	}
	return newList
}

// DropLastTeacherPtr drops last item from the list and returns new list.
// Returns empty list if there is only one item in the list or list empty
func DropLastTeacherPtr(list []*Teacher) []*Teacher {
	listLen := len(list)

	if list == nil || listLen == 0 || listLen == 1 {
		return []*Teacher{}
	}

	newList := make([]*Teacher, listLen-1)

	for i := 0; i < listLen-1; i++ {
		newList[i] = list[i]
	}
	return newList
}

// ReverseTeachers reverse the list
func ReverseTeachers(list []Teacher) []Teacher {
	newList := make([]Teacher, len(list))
	for i := 0; i < len(list); i++ {
		newList[i] = list[len(list)-(i+1)]
	}
	return newList
}

// ReverseTeachersPtr reverse the list
func ReverseTeachersPtr(list []*Teacher) []*Teacher {
	newList := make([]*Teacher, len(list))
	for i := 0; i < len(list); i++ {
		newList[i] = list[len(list)-(i+1)]
	}
	return newList
}

// TakeTeacher returns n items in the list
func TakeTeacher(n int, list []Teacher) []Teacher {
	if n < 0 {
		return []Teacher{}
	}

	newListLen := len(list)

	if n < newListLen {
		newListLen = n
	}
	newList := make([]Teacher, newListLen)
	for i := 0; i < newListLen; i++ {
		newList[i] = list[i]
	}
	return newList
}

// TakeTeacherPtr returns n items in the list
func TakeTeacherPtr(n int, list []*Teacher) []*Teacher {
	if n < 0 {
		return []*Teacher{}
	}

	newListLen := len(list)

	if n < newListLen {
		newListLen = n
	}
	newList := make([]*Teacher, newListLen)
	for i := 0; i < newListLen; i++ {
		newList[i] = list[i]
	}
	return newList
}

type teacherSlice []Teacher
type teacherFunctor func(Teacher) Teacher

// MakeTeacherSlice - creates slice for the functional method such as map, filter
func MakeTeacherSlice(values ...Teacher) teacherSlice {
	newSlice := teacherSlice(values)
	return newSlice
}

func mapCoreteacher(f teacherFunctor, slice teacherSlice) teacherSlice {
	newSlice := make(teacherSlice, len(slice))
	for i, v := range slice {
		newSlice[i] = f(v)
	}
	return newSlice
}

// Map - applies the function(1st argument) on each item of the list and returns new list
func (slice teacherSlice) Map(functors ...teacherFunctor) teacherSlice {

	tmpSlice := slice
	
	for _, f := range functors {
		tmpSlice = mapCoreteacher(f, tmpSlice)
	}

	return tmpSlice
}

// DistinctTeacherP returns true if no two of the arguments are =
func DistinctTeacherP(list []Teacher) bool {
	if len(list) == 0 {
		return false
	}

	for i := 0; i < len(list); i++ {
		for j := i + 1; j < len(list); j++ {
			if reflect.DeepEqual(list[i], list[j]) {
				return false
			}
		}
	}
	return true
}

// DistinctTeacherPPtr returns true if no two of the arguments are =
func DistinctTeacherPPtr(list []*Teacher) bool {
	if len(list) == 0 {
		return false
	}

	for i := 0; i < len(list); i++ {
		for j := i + 1; j < len(list); j++ {
			if reflect.DeepEqual(*list[i], *list[j]) {
				return false
			}
		}
	}
	return true
}

// DistinctTeacher removes duplicates.
func DistinctTeacher(list []Teacher) []Teacher {
	if len(list) == 0 {
		return []Teacher{}
	}

	newList := []Teacher{list[0]}

	for i := 1; i < len(list); i++ {
		found := false
		for j := 0; j < len(newList); j++ {
			if reflect.DeepEqual(list[i], newList[j]) {
				found = true
				break
			}
		}
		if !found {
			newList = append(newList, list[i])
		}
	}
	return newList
}

func DistinctTeacherPtr(list []*Teacher) []*Teacher {
	if len(list) == 0 {
		return []*Teacher{}
	}

	newList := []*Teacher{list[0]}

	for i := 1; i < len(list); i++ {
		found := false
		for j := 0; j < len(newList); j++ {
			if reflect.DeepEqual(*list[i], *newList[j]) {
				found = true
				break
			}
		}
		if !found {
			newList = append(newList, list[i])
		}
	}
	return newList
}

// UnionTeacher return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionTeacher(arrList ...[]Teacher) []Teacher {
	var newList []Teacher

	for _, arr := range arrList {
		for _, v := range arr {
			found := false
			for i := 0; i < len(newList); i++ {
				if reflect.DeepEqual(newList[i], v) {
					found = true
					break
				}
			}
			if !found {
				newList = append(newList, v)
			}
		}
	}
	return newList
}

// UnionTeacherPtr return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionTeacherPtr(arrList ...[]*Teacher) []*Teacher {
	var newList []*Teacher

	for _, arr := range arrList {
		for _, v := range arr {
			found := false
			for i := 0; i < len(newList); i++ {
				if reflect.DeepEqual(*newList[i], *v) {
					found = true
					break
				}
			}
			if !found {
				newList = append(newList, v)
			}
		}
	}
	return newList
}

// IntersectionTeacher return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionTeacher(arrList ...[]Teacher) []Teacher {
	if arrList == nil {
		return []Teacher{}
	}

	var newList []Teacher

	if len(arrList) == 1 {
		for i := 0; i < len(arrList[0]); i++ {
			found := false
			for j := 0; j < len(newList); j++ {
				if reflect.DeepEqual(newList[j], arrList[0][i]) {
					found = true
					break
				}
			}
			if !found {
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if reflect.DeepEqual(arrList[0][i], v) {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			found := false
			for j := 0; j < len(newList); j++ {
				if reflect.DeepEqual(newList[j], arrList[0][i]) {
					found = true
					break
				}
			}
			if !found {
				newList = append(newList, arrList[0][i])
			}
		}
	}
	return newList
}

// IntersectionTeacherPtr return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionTeacherPtr(arrList ...[]*Teacher) []*Teacher {
	if arrList == nil {
		return []*Teacher{}
	}

	var newList []*Teacher

	if len(arrList) == 1 {
		for i := 0; i < len(arrList[0]); i++ {
			found := false
			for j := 0; j < len(newList); j++ {
				if reflect.DeepEqual(*newList[j], *arrList[0][i]) {
					found = true
					break
				}
			}
			if !found {
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if reflect.DeepEqual(*arrList[0][i], *v) {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			found := false
			for j := 0; j < len(newList); j++ {
				if reflect.DeepEqual(*newList[j], *arrList[0][i]) {
					found = true
					break
				}
			}
			if !found {
				newList = append(newList, arrList[0][i])
			}
		}
	}
	return newList
}

// DifferenceTeacher returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceTeacher(arrList ...[]Teacher) []Teacher {
	if arrList == nil {
		return []Teacher{}
	}

	var newList []Teacher

	if len(arrList) == 1 {
		for i := 0; i < len(arrList[0]); i++ {
			found := false
			for j := 0; j < len(newList); j++ {
				if reflect.DeepEqual(newList[j], arrList[0][i]) {
					found = true
					break
				}
			}
			if !found {
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if reflect.DeepEqual(arrList[0][i], v) {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			found := false
			for j := 0; j < len(newList); j++ {
				if reflect.DeepEqual(newList[j], arrList[0][i]) {
					found = true
					break
				}
			}
			if !found {
				newList = append(newList, arrList[0][i])
			}
		}
	}
	return newList
}

// DifferenceTeacherPtr returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceTeacherPtr(arrList ...[]*Teacher) []*Teacher {
	if arrList == nil {
		return []*Teacher{}
	}

	var newList []*Teacher

	if len(arrList) == 1 {
		for i := 0; i < len(arrList[0]); i++ {
			found := false
			for j := 0; j < len(newList); j++ {
				if reflect.DeepEqual(*newList[j], *arrList[0][i]) {
					found = true
					break
				}
			}
			if !found {
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if reflect.DeepEqual(*arrList[0][i], *v) {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			found := false
			for j := 0; j < len(newList); j++ {
				if reflect.DeepEqual(*newList[j], *arrList[0][i]) {
					found = true
					break
				}
			}
			if !found {
				newList = append(newList, arrList[0][i])
			}
		}
	}
	return newList
}

// SubsetTeacher returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored, order does not matter
func SubsetTeacher(list1, list2 []Teacher) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	for i := 0; i < len(list1); i++ {
		found := false
		for j := 0; j < len(list2); j++ {
			if reflect.DeepEqual(list1[i], list2[j]) {
				found = true
			}
		}
		if !found {
			return false
		}
	}
	return true
}

// SubsetTeacherPtr returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored, order does not matter
func SubsetTeacherPtr(list1, list2 []*Teacher) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	for i := 0; i < len(list1); i++ {
		found := false
		for j := 0; j < len(list2); j++ {
			if reflect.DeepEqual(*list1[i], *list2[j]) {
				found = true
			}
		}
		if !found {
			return false
		}
	}
	return true
}

// SupersetTeacher returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored, order does not matter
func SupersetTeacher(list1, list2 []Teacher) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	for i := 0; i < len(list2); i++ {
		found := false
		for j := 0; j < len(list1); j++ {
			if reflect.DeepEqual(list2[i], list1[j]) {
				found = true
			}
		}
		if !found {
			return false
		}
	}
	return true
}

// SupersetTeacherPtr returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored, order does not matter
func SupersetTeacherPtr(list1, list2 []*Teacher) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	for i := 0; i < len(list2); i++ {
		found := false
		for j := 0; j < len(list1); j++ {
			if reflect.DeepEqual(*list2[i], *list1[j]) {
				found = true
			}
		}
		if !found {
			return false
		}
	}
	return true
}

// SetTeacher returns a set of the distinct elements of coll.
func SetTeacher(list []Teacher) []Teacher {
	if len(list) == 0 {
		return []Teacher{}
	}

	newList := []Teacher{list[0]}

	for i := 1; i < len(list); i++ {
		found := false
		for j := 0; j < len(newList); j++ {
			if reflect.DeepEqual(list[i], newList[j]) {
				found = true
				break
			}
		}
		if !found {
			newList = append(newList, list[i])
		}
	}
	return newList
}

// SetTeacherPtr returns a set of the distinct elements of coll.
func SetTeacherPtr(list []*Teacher) []*Teacher {
	if len(list) == 0 {
		return []*Teacher{}
	}

	newList := []*Teacher{list[0]}

	for i := 1; i < len(list); i++ {
		found := false
		for j := 0; j < len(newList); j++ {
			if reflect.DeepEqual(*list[i], *newList[j]) {
				found = true
				break
			}
		}
		if !found {
			newList = append(newList, list[i])
		}
	}
	return newList
}



type byIdTeacher []Teacher

func (a byIdTeacher) Len() int           { return len(a) }
func (a byIdTeacher) Less(i, j int) bool { return a[i].Id < a[j].Id }
func (a byIdTeacher) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortTeacherById sort structs
func SortTeacherById(list []Teacher) []Teacher {
	if len(list) == 0 {
		return []Teacher{}
	}
	newList := make([]Teacher, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byIdTeacher(newList))
	return newList
}

// SortTeacherByIdPtr sorts structs
func SortTeacherByIdPtr(list []*Teacher) []*Teacher {
	if len(list) == 0 {
		return []*Teacher{}
	}
	newList := make([]Teacher, len(list))
	newListPtr := make([]*Teacher, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byIdTeacher(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}

type byIdTeacherDesc []Teacher

func (a byIdTeacherDesc) Len() int           { return len(a) }
func (a byIdTeacherDesc) Less(i, j int) bool { return a[i].Id > a[j].Id }
func (a byIdTeacherDesc) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortTeacherByIdDesc sorts structs
func SortTeacherByIdDesc(list []Teacher) []Teacher {
	if len(list) == 0 {
		return []Teacher{}
	}
	newList := make([]Teacher, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byIdTeacherDesc(newList))
	return newList
}

// SortTeacherByIdDescPtr sorts structs
func SortTeacherByIdDescPtr(list []*Teacher) []*Teacher {
	if len(list) == 0 {
		return []*Teacher{}
	}
	newList := make([]Teacher, len(list))
	newListPtr := make([]*Teacher, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byIdTeacherDesc(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}
type byNameTeacher []Teacher

func (a byNameTeacher) Len() int           { return len(a) }
func (a byNameTeacher) Less(i, j int) bool { return a[i].Name < a[j].Name }
func (a byNameTeacher) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortTeacherByName sort structs
func SortTeacherByName(list []Teacher) []Teacher {
	if len(list) == 0 {
		return []Teacher{}
	}
	newList := make([]Teacher, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byNameTeacher(newList))
	return newList
}

// SortTeacherByNamePtr sorts structs
func SortTeacherByNamePtr(list []*Teacher) []*Teacher {
	if len(list) == 0 {
		return []*Teacher{}
	}
	newList := make([]Teacher, len(list))
	newListPtr := make([]*Teacher, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byNameTeacher(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}

type byNameTeacherDesc []Teacher

func (a byNameTeacherDesc) Len() int           { return len(a) }
func (a byNameTeacherDesc) Less(i, j int) bool { return a[i].Name > a[j].Name }
func (a byNameTeacherDesc) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortTeacherByNameDesc sorts structs
func SortTeacherByNameDesc(list []Teacher) []Teacher {
	if len(list) == 0 {
		return []Teacher{}
	}
	newList := make([]Teacher, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byNameTeacherDesc(newList))
	return newList
}

// SortTeacherByNameDescPtr sorts structs
func SortTeacherByNameDescPtr(list []*Teacher) []*Teacher {
	if len(list) == 0 {
		return []*Teacher{}
	}
	newList := make([]Teacher, len(list))
	newListPtr := make([]*Teacher, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byNameTeacherDesc(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}
type bySalaryTeacher []Teacher

func (a bySalaryTeacher) Len() int           { return len(a) }
func (a bySalaryTeacher) Less(i, j int) bool { return a[i].Salary < a[j].Salary }
func (a bySalaryTeacher) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortTeacherBySalary sort structs
func SortTeacherBySalary(list []Teacher) []Teacher {
	if len(list) == 0 {
		return []Teacher{}
	}
	newList := make([]Teacher, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(bySalaryTeacher(newList))
	return newList
}

// SortTeacherBySalaryPtr sorts structs
func SortTeacherBySalaryPtr(list []*Teacher) []*Teacher {
	if len(list) == 0 {
		return []*Teacher{}
	}
	newList := make([]Teacher, len(list))
	newListPtr := make([]*Teacher, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(bySalaryTeacher(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}

type bySalaryTeacherDesc []Teacher

func (a bySalaryTeacherDesc) Len() int           { return len(a) }
func (a bySalaryTeacherDesc) Less(i, j int) bool { return a[i].Salary > a[j].Salary }
func (a bySalaryTeacherDesc) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortTeacherBySalaryDesc sorts structs
func SortTeacherBySalaryDesc(list []Teacher) []Teacher {
	if len(list) == 0 {
		return []Teacher{}
	}
	newList := make([]Teacher, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(bySalaryTeacherDesc(newList))
	return newList
}

// SortTeacherBySalaryDescPtr sorts structs
func SortTeacherBySalaryDescPtr(list []*Teacher) []*Teacher {
	if len(list) == 0 {
		return []*Teacher{}
	}
	newList := make([]Teacher, len(list))
	newListPtr := make([]*Teacher, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(bySalaryTeacherDesc(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}
type byCreationDateTeacher []Teacher

func (a byCreationDateTeacher) Len() int           { return len(a) }
func (a byCreationDateTeacher) Less(i, j int) bool {
	v1Ptr := a[i].CreationDate
	v2Ptr := a[j].CreationDate

	v1 := *v1Ptr
	v2 := *v2Ptr

	return v1.Before(v2)
}
func (a byCreationDateTeacher) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortTeacherByCreationDate sort structs
func SortTeacherByCreationDate(list []Teacher) []Teacher {
	if len(list) == 0 {
		return []Teacher{}
	}
	newList := make([]Teacher, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byCreationDateTeacher(newList))
	return newList
}

// SortTeacherByCreationDatePtr sorts structs
func SortTeacherByCreationDatePtr(list []*Teacher) []*Teacher {
	if len(list) == 0 {
		return []*Teacher{}
	}
	newList := make([]Teacher, len(list))
	newListPtr := make([]*Teacher, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byCreationDateTeacher(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}

type byCreationDateTeacherDesc []Teacher

func (a byCreationDateTeacherDesc) Len() int           { return len(a) }
func (a byCreationDateTeacherDesc) Less(i, j int) bool {
	v1Ptr := a[i].CreationDate
	v2Ptr := a[j].CreationDate

	v1 := *v1Ptr
	v2 := *v2Ptr

	return v1.After(v2) 
}
func (a byCreationDateTeacherDesc) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortTeacherByCreationDateDesc sorts structs
func SortTeacherByCreationDateDesc(list []Teacher) []Teacher {
	if len(list) == 0 {
		return []Teacher{}
	}
	newList := make([]Teacher, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byCreationDateTeacherDesc(newList))
	return newList
}

// SortTeacherByCreationDateDescPtr sorts structs
func SortTeacherByCreationDateDescPtr(list []*Teacher) []*Teacher {
	if len(list) == 0 {
		return []*Teacher{}
	}
	newList := make([]Teacher, len(list))
	newListPtr := make([]*Teacher, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byCreationDateTeacherDesc(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}
type byAddressTeacher []Teacher

func (a byAddressTeacher) Len() int           { return len(a) }
func (a byAddressTeacher) Less(i, j int) bool {
	v1 := a[i].Address
	v2 := a[j].Address
	return *v1 < *v2
}
func (a byAddressTeacher) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortTeacherByAddress sort structs
func SortTeacherByAddress(list []Teacher) []Teacher {
	if len(list) == 0 {
		return []Teacher{}
	}
	newList := make([]Teacher, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byAddressTeacher(newList))
	return newList
}

// SortTeacherByAddressPtr sorts structs
func SortTeacherByAddressPtr(list []*Teacher) []*Teacher {
	if len(list) == 0 {
		return []*Teacher{}
	}
	newList := make([]Teacher, len(list))
	newListPtr := make([]*Teacher, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byAddressTeacher(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}

type byAddressTeacherDesc []Teacher

func (a byAddressTeacherDesc) Len() int           { return len(a) }
func (a byAddressTeacherDesc) Less(i, j int) bool {
	v1 := a[i].Address
	v2 := a[j].Address

	return *v1 > *v2
}
func (a byAddressTeacherDesc) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortTeacherByAddressDesc sorts structs
func SortTeacherByAddressDesc(list []Teacher) []Teacher {
	if len(list) == 0 {
		return []Teacher{}
	}
	newList := make([]Teacher, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byAddressTeacherDesc(newList))
	return newList
}

// SortTeacherByAddressDescPtr sorts structs
func SortTeacherByAddressDescPtr(list []*Teacher) []*Teacher {
	if len(list) == 0 {
		return []*Teacher{}
	}
	newList := make([]Teacher, len(list))
	newListPtr := make([]*Teacher, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byAddressTeacherDesc(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}
// UnionTeacherById return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionTeacherById(arrList ...[]Teacher) []Teacher {
	resultMap := make(map[int]bool)
	var resultArr []Teacher
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.Id]
			if !ok {
				resultMap[v.Id] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// Union<FTYPE>Ptr return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionTeacherByIdPtr(arrList ...[]*Teacher) []*Teacher {
	resultMap := make(map[int]bool)
	var resultArr []*Teacher
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.Id]
			if !ok {
				resultMap[v.Id] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// IntersectionTeacherById return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionTeacherById(arrList ...[]Teacher) []Teacher {
	if arrList == nil {
		return []Teacher{}
	}

	resultMap := make(map[int]bool)
	if len(arrList) == 1 {
		var newList []Teacher
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Id]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Id] = true
			}
		}
		return newList
	}

	var newList []Teacher
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Id == v.Id {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].Id]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Id] = true
			}
		}
	}
	return newList
}

// IntersectionTeacherByIdPtr return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionTeacherByIdPtr(arrList ...[]*Teacher) []*Teacher {
	if arrList == nil {
		return []*Teacher{}
	}

	resultMap := make(map[int]bool)
	if len(arrList) == 1 {
		var newList []*Teacher
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Id]
			if !ok {
				resultMap[arrList[0][i].Id] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Teacher
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Id == v.Id {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].Id]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Id] = true
			}
		}
	}
	return newList
}

// DifferenceTeacherById returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceTeacherById(arrList ...[]Teacher) []Teacher {
	if arrList == nil {
		return []Teacher{}
	}

	resultMap := make(map[int]bool)
	if len(arrList) == 1 {
		var newList []Teacher
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Id]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Id] = true
			}
		}
		return newList
	}

	var newList []Teacher
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Id == v.Id {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].Id]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Id] = true
			}
		}
	}
	return newList
}

// DifferenceTeacherByIdPtr returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceTeacherByIdPtr(arrList ...[]*Teacher) []*Teacher {
	if arrList == nil {
		return []*Teacher{}
	}

	resultMap := make(map[int]bool)
	if len(arrList) == 1 {
		var newList []*Teacher
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Id]
			if !ok {
				resultMap[arrList[0][i].Id] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Teacher
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Id == v.Id {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].Id]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Id] = true
			}
		}
	}
	return newList
}

// SubsetTeacherById returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetTeacherById(list1, list2 []Teacher) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[int]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].Id]
		if !ok {
			found := false
			resultMap[list1[i].Id] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].Id == list2[j].Id {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SubsetTeacherByIdPtr returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetTeacherByIdPtr(list1, list2 []*Teacher) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[int]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].Id]
		if !ok {
			found := false
			resultMap[list1[i].Id] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].Id == list2[j].Id {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetTeacherById returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetTeacherById(list1, list2 []Teacher) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[int]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].Id]
		if !ok {
			found := false
			resultMap[list2[i].Id] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].Id == list1[j].Id {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetTeacherByIdPtr returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetTeacherByIdPtr(list1, list2 []*Teacher) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[int]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].Id]
		if !ok {
			found := false
			resultMap[list2[i].Id] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].Id == list1[j].Id {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SetTeacherById returns a set of the distinct elements of coll.
func SetTeacherById(list []Teacher) []Teacher {
	if list == nil || len(list) == 0 {
		return []Teacher{}
	}

	resultMap := make(map[int]bool)
	newList := []Teacher{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].Id]
		if !ok {
			resultMap[list[i].Id] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}

// SetTeacherByIdPtr returns a set of the distinct elements of coll.
func SetTeacherByIdPtr(list []*Teacher) []*Teacher {
	if list == nil || len(list) == 0 {
		return []*Teacher{}
	}

	resultMap := make(map[int]bool)
	newList := []*Teacher{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].Id]
		if !ok {
			resultMap[list[i].Id] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}
// UnionTeacherByName return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionTeacherByName(arrList ...[]Teacher) []Teacher {
	resultMap := make(map[string]bool)
	var resultArr []Teacher
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.Name]
			if !ok {
				resultMap[v.Name] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// Union<FTYPE>Ptr return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionTeacherByNamePtr(arrList ...[]*Teacher) []*Teacher {
	resultMap := make(map[string]bool)
	var resultArr []*Teacher
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.Name]
			if !ok {
				resultMap[v.Name] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// IntersectionTeacherByName return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionTeacherByName(arrList ...[]Teacher) []Teacher {
	if arrList == nil {
		return []Teacher{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []Teacher
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Name]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Name] = true
			}
		}
		return newList
	}

	var newList []Teacher
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Name == v.Name {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].Name]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Name] = true
			}
		}
	}
	return newList
}

// IntersectionTeacherByNamePtr return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionTeacherByNamePtr(arrList ...[]*Teacher) []*Teacher {
	if arrList == nil {
		return []*Teacher{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []*Teacher
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Name]
			if !ok {
				resultMap[arrList[0][i].Name] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Teacher
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Name == v.Name {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].Name]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Name] = true
			}
		}
	}
	return newList
}

// DifferenceTeacherByName returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceTeacherByName(arrList ...[]Teacher) []Teacher {
	if arrList == nil {
		return []Teacher{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []Teacher
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Name]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Name] = true
			}
		}
		return newList
	}

	var newList []Teacher
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Name == v.Name {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].Name]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Name] = true
			}
		}
	}
	return newList
}

// DifferenceTeacherByNamePtr returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceTeacherByNamePtr(arrList ...[]*Teacher) []*Teacher {
	if arrList == nil {
		return []*Teacher{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []*Teacher
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Name]
			if !ok {
				resultMap[arrList[0][i].Name] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Teacher
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Name == v.Name {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].Name]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Name] = true
			}
		}
	}
	return newList
}

// SubsetTeacherByName returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetTeacherByName(list1, list2 []Teacher) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].Name]
		if !ok {
			found := false
			resultMap[list1[i].Name] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].Name == list2[j].Name {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SubsetTeacherByNamePtr returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetTeacherByNamePtr(list1, list2 []*Teacher) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].Name]
		if !ok {
			found := false
			resultMap[list1[i].Name] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].Name == list2[j].Name {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetTeacherByName returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetTeacherByName(list1, list2 []Teacher) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].Name]
		if !ok {
			found := false
			resultMap[list2[i].Name] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].Name == list1[j].Name {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetTeacherByNamePtr returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetTeacherByNamePtr(list1, list2 []*Teacher) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].Name]
		if !ok {
			found := false
			resultMap[list2[i].Name] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].Name == list1[j].Name {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SetTeacherByName returns a set of the distinct elements of coll.
func SetTeacherByName(list []Teacher) []Teacher {
	if list == nil || len(list) == 0 {
		return []Teacher{}
	}

	resultMap := make(map[string]bool)
	newList := []Teacher{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].Name]
		if !ok {
			resultMap[list[i].Name] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}

// SetTeacherByNamePtr returns a set of the distinct elements of coll.
func SetTeacherByNamePtr(list []*Teacher) []*Teacher {
	if list == nil || len(list) == 0 {
		return []*Teacher{}
	}

	resultMap := make(map[string]bool)
	newList := []*Teacher{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].Name]
		if !ok {
			resultMap[list[i].Name] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}
// UnionTeacherBySalary return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionTeacherBySalary(arrList ...[]Teacher) []Teacher {
	resultMap := make(map[float64]bool)
	var resultArr []Teacher
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.Salary]
			if !ok {
				resultMap[v.Salary] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// Union<FTYPE>Ptr return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionTeacherBySalaryPtr(arrList ...[]*Teacher) []*Teacher {
	resultMap := make(map[float64]bool)
	var resultArr []*Teacher
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.Salary]
			if !ok {
				resultMap[v.Salary] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// IntersectionTeacherBySalary return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionTeacherBySalary(arrList ...[]Teacher) []Teacher {
	if arrList == nil {
		return []Teacher{}
	}

	resultMap := make(map[float64]bool)
	if len(arrList) == 1 {
		var newList []Teacher
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Salary]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Salary] = true
			}
		}
		return newList
	}

	var newList []Teacher
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Salary == v.Salary {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].Salary]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Salary] = true
			}
		}
	}
	return newList
}

// IntersectionTeacherBySalaryPtr return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionTeacherBySalaryPtr(arrList ...[]*Teacher) []*Teacher {
	if arrList == nil {
		return []*Teacher{}
	}

	resultMap := make(map[float64]bool)
	if len(arrList) == 1 {
		var newList []*Teacher
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Salary]
			if !ok {
				resultMap[arrList[0][i].Salary] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Teacher
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Salary == v.Salary {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].Salary]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Salary] = true
			}
		}
	}
	return newList
}

// DifferenceTeacherBySalary returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceTeacherBySalary(arrList ...[]Teacher) []Teacher {
	if arrList == nil {
		return []Teacher{}
	}

	resultMap := make(map[float64]bool)
	if len(arrList) == 1 {
		var newList []Teacher
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Salary]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Salary] = true
			}
		}
		return newList
	}

	var newList []Teacher
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Salary == v.Salary {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].Salary]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Salary] = true
			}
		}
	}
	return newList
}

// DifferenceTeacherBySalaryPtr returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceTeacherBySalaryPtr(arrList ...[]*Teacher) []*Teacher {
	if arrList == nil {
		return []*Teacher{}
	}

	resultMap := make(map[float64]bool)
	if len(arrList) == 1 {
		var newList []*Teacher
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Salary]
			if !ok {
				resultMap[arrList[0][i].Salary] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Teacher
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Salary == v.Salary {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].Salary]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Salary] = true
			}
		}
	}
	return newList
}

// SubsetTeacherBySalary returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetTeacherBySalary(list1, list2 []Teacher) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[float64]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].Salary]
		if !ok {
			found := false
			resultMap[list1[i].Salary] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].Salary == list2[j].Salary {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SubsetTeacherBySalaryPtr returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetTeacherBySalaryPtr(list1, list2 []*Teacher) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[float64]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].Salary]
		if !ok {
			found := false
			resultMap[list1[i].Salary] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].Salary == list2[j].Salary {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetTeacherBySalary returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetTeacherBySalary(list1, list2 []Teacher) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[float64]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].Salary]
		if !ok {
			found := false
			resultMap[list2[i].Salary] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].Salary == list1[j].Salary {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetTeacherBySalaryPtr returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetTeacherBySalaryPtr(list1, list2 []*Teacher) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[float64]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].Salary]
		if !ok {
			found := false
			resultMap[list2[i].Salary] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].Salary == list1[j].Salary {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SetTeacherBySalary returns a set of the distinct elements of coll.
func SetTeacherBySalary(list []Teacher) []Teacher {
	if list == nil || len(list) == 0 {
		return []Teacher{}
	}

	resultMap := make(map[float64]bool)
	newList := []Teacher{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].Salary]
		if !ok {
			resultMap[list[i].Salary] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}

// SetTeacherBySalaryPtr returns a set of the distinct elements of coll.
func SetTeacherBySalaryPtr(list []*Teacher) []*Teacher {
	if list == nil || len(list) == 0 {
		return []*Teacher{}
	}

	resultMap := make(map[float64]bool)
	newList := []*Teacher{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].Salary]
		if !ok {
			resultMap[list[i].Salary] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}
// UnionTeacherByCreationDate return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionTeacherByCreationDate(arrList ...[]Teacher) []Teacher {
	resultMap := make(map[*time.Time]bool)
	var resultArr []Teacher
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.CreationDate]
			if !ok {
				resultMap[v.CreationDate] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// Union<FTYPE>Ptr return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionTeacherByCreationDatePtr(arrList ...[]*Teacher) []*Teacher {
	resultMap := make(map[*time.Time]bool)
	var resultArr []*Teacher
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.CreationDate]
			if !ok {
				resultMap[v.CreationDate] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// IntersectionTeacherByCreationDate return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionTeacherByCreationDate(arrList ...[]Teacher) []Teacher {
	if arrList == nil {
		return []Teacher{}
	}

	resultMap := make(map[*time.Time]bool)
	if len(arrList) == 1 {
		var newList []Teacher
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].CreationDate]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].CreationDate] = true
			}
		}
		return newList
	}

	var newList []Teacher
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].CreationDate == v.CreationDate {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].CreationDate]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].CreationDate] = true
			}
		}
	}
	return newList
}

// IntersectionTeacherByCreationDatePtr return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionTeacherByCreationDatePtr(arrList ...[]*Teacher) []*Teacher {
	if arrList == nil {
		return []*Teacher{}
	}

	resultMap := make(map[*time.Time]bool)
	if len(arrList) == 1 {
		var newList []*Teacher
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].CreationDate]
			if !ok {
				resultMap[arrList[0][i].CreationDate] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Teacher
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].CreationDate == v.CreationDate {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].CreationDate]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].CreationDate] = true
			}
		}
	}
	return newList
}

// DifferenceTeacherByCreationDate returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceTeacherByCreationDate(arrList ...[]Teacher) []Teacher {
	if arrList == nil {
		return []Teacher{}
	}

	resultMap := make(map[*time.Time]bool)
	if len(arrList) == 1 {
		var newList []Teacher
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].CreationDate]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].CreationDate] = true
			}
		}
		return newList
	}

	var newList []Teacher
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].CreationDate == v.CreationDate {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].CreationDate]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].CreationDate] = true
			}
		}
	}
	return newList
}

// DifferenceTeacherByCreationDatePtr returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceTeacherByCreationDatePtr(arrList ...[]*Teacher) []*Teacher {
	if arrList == nil {
		return []*Teacher{}
	}

	resultMap := make(map[*time.Time]bool)
	if len(arrList) == 1 {
		var newList []*Teacher
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].CreationDate]
			if !ok {
				resultMap[arrList[0][i].CreationDate] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Teacher
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].CreationDate == v.CreationDate {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].CreationDate]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].CreationDate] = true
			}
		}
	}
	return newList
}

// SubsetTeacherByCreationDate returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetTeacherByCreationDate(list1, list2 []Teacher) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[*time.Time]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].CreationDate]
		if !ok {
			found := false
			resultMap[list1[i].CreationDate] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].CreationDate == list2[j].CreationDate {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SubsetTeacherByCreationDatePtr returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetTeacherByCreationDatePtr(list1, list2 []*Teacher) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[*time.Time]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].CreationDate]
		if !ok {
			found := false
			resultMap[list1[i].CreationDate] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].CreationDate == list2[j].CreationDate {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetTeacherByCreationDate returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetTeacherByCreationDate(list1, list2 []Teacher) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[*time.Time]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].CreationDate]
		if !ok {
			found := false
			resultMap[list2[i].CreationDate] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].CreationDate == list1[j].CreationDate {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetTeacherByCreationDatePtr returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetTeacherByCreationDatePtr(list1, list2 []*Teacher) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[*time.Time]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].CreationDate]
		if !ok {
			found := false
			resultMap[list2[i].CreationDate] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].CreationDate == list1[j].CreationDate {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SetTeacherByCreationDate returns a set of the distinct elements of coll.
func SetTeacherByCreationDate(list []Teacher) []Teacher {
	if list == nil || len(list) == 0 {
		return []Teacher{}
	}

	resultMap := make(map[*time.Time]bool)
	newList := []Teacher{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].CreationDate]
		if !ok {
			resultMap[list[i].CreationDate] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}

// SetTeacherByCreationDatePtr returns a set of the distinct elements of coll.
func SetTeacherByCreationDatePtr(list []*Teacher) []*Teacher {
	if list == nil || len(list) == 0 {
		return []*Teacher{}
	}

	resultMap := make(map[*time.Time]bool)
	newList := []*Teacher{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].CreationDate]
		if !ok {
			resultMap[list[i].CreationDate] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}
// UnionTeacherByAddress return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionTeacherByAddress(arrList ...[]Teacher) []Teacher {
	resultMap := make(map[*string]bool)
	var resultArr []Teacher
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.Address]
			if !ok {
				resultMap[v.Address] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// Union<FTYPE>Ptr return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionTeacherByAddressPtr(arrList ...[]*Teacher) []*Teacher {
	resultMap := make(map[*string]bool)
	var resultArr []*Teacher
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.Address]
			if !ok {
				resultMap[v.Address] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// IntersectionTeacherByAddress return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionTeacherByAddress(arrList ...[]Teacher) []Teacher {
	if arrList == nil {
		return []Teacher{}
	}

	resultMap := make(map[*string]bool)
	if len(arrList) == 1 {
		var newList []Teacher
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Address]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Address] = true
			}
		}
		return newList
	}

	var newList []Teacher
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Address == v.Address {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].Address]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Address] = true
			}
		}
	}
	return newList
}

// IntersectionTeacherByAddressPtr return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionTeacherByAddressPtr(arrList ...[]*Teacher) []*Teacher {
	if arrList == nil {
		return []*Teacher{}
	}

	resultMap := make(map[*string]bool)
	if len(arrList) == 1 {
		var newList []*Teacher
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Address]
			if !ok {
				resultMap[arrList[0][i].Address] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Teacher
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Address == v.Address {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].Address]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Address] = true
			}
		}
	}
	return newList
}

// DifferenceTeacherByAddress returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceTeacherByAddress(arrList ...[]Teacher) []Teacher {
	if arrList == nil {
		return []Teacher{}
	}

	resultMap := make(map[*string]bool)
	if len(arrList) == 1 {
		var newList []Teacher
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Address]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Address] = true
			}
		}
		return newList
	}

	var newList []Teacher
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Address == v.Address {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].Address]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Address] = true
			}
		}
	}
	return newList
}

// DifferenceTeacherByAddressPtr returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceTeacherByAddressPtr(arrList ...[]*Teacher) []*Teacher {
	if arrList == nil {
		return []*Teacher{}
	}

	resultMap := make(map[*string]bool)
	if len(arrList) == 1 {
		var newList []*Teacher
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Address]
			if !ok {
				resultMap[arrList[0][i].Address] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Teacher
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Address == v.Address {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].Address]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Address] = true
			}
		}
	}
	return newList
}

// SubsetTeacherByAddress returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetTeacherByAddress(list1, list2 []Teacher) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[*string]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].Address]
		if !ok {
			found := false
			resultMap[list1[i].Address] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].Address == list2[j].Address {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SubsetTeacherByAddressPtr returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetTeacherByAddressPtr(list1, list2 []*Teacher) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[*string]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].Address]
		if !ok {
			found := false
			resultMap[list1[i].Address] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].Address == list2[j].Address {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetTeacherByAddress returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetTeacherByAddress(list1, list2 []Teacher) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[*string]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].Address]
		if !ok {
			found := false
			resultMap[list2[i].Address] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].Address == list1[j].Address {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetTeacherByAddressPtr returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetTeacherByAddressPtr(list1, list2 []*Teacher) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[*string]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].Address]
		if !ok {
			found := false
			resultMap[list2[i].Address] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].Address == list1[j].Address {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SetTeacherByAddress returns a set of the distinct elements of coll.
func SetTeacherByAddress(list []Teacher) []Teacher {
	if list == nil || len(list) == 0 {
		return []Teacher{}
	}

	resultMap := make(map[*string]bool)
	newList := []Teacher{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].Address]
		if !ok {
			resultMap[list[i].Address] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}

// SetTeacherByAddressPtr returns a set of the distinct elements of coll.
func SetTeacherByAddressPtr(list []*Teacher) []*Teacher {
	if list == nil || len(list) == 0 {
		return []*Teacher{}
	}

	resultMap := make(map[*string]bool)
	newList := []*Teacher{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].Address]
		if !ok {
			resultMap[list[i].Address] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}