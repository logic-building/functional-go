package fp

// KeysInt returns a slice of map's keys
func KeysInt(m map[int]int) []int {
	keys := make([]int, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysIntInt64 returns a slice of map's keys
func KeysIntInt64(m map[int]int64) []int {
	keys := make([]int, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysIntInt32 returns a slice of map's keys
func KeysIntInt32(m map[int]int32) []int {
	keys := make([]int, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysIntInt16 returns a slice of map's keys
func KeysIntInt16(m map[int]int16) []int {
	keys := make([]int, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysIntInt8 returns a slice of map's keys
func KeysIntInt8(m map[int]int8) []int {
	keys := make([]int, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysIntUint returns a slice of map's keys
func KeysIntUint(m map[int]uint) []int {
	keys := make([]int, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysIntUint64 returns a slice of map's keys
func KeysIntUint64(m map[int]uint64) []int {
	keys := make([]int, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysIntUint32 returns a slice of map's keys
func KeysIntUint32(m map[int]uint32) []int {
	keys := make([]int, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysIntUint16 returns a slice of map's keys
func KeysIntUint16(m map[int]uint16) []int {
	keys := make([]int, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysIntUint8 returns a slice of map's keys
func KeysIntUint8(m map[int]uint8) []int {
	keys := make([]int, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysIntStr returns a slice of map's keys
func KeysIntStr(m map[int]string) []int {
	keys := make([]int, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysIntBool returns a slice of map's keys
func KeysIntBool(m map[int]bool) []int {
	keys := make([]int, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysIntFloat32 returns a slice of map's keys
func KeysIntFloat32(m map[int]float32) []int {
	keys := make([]int, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysIntFloat64 returns a slice of map's keys
func KeysIntFloat64(m map[int]float64) []int {
	keys := make([]int, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysInt64Int returns a slice of map's keys
func KeysInt64Int(m map[int64]int) []int64 {
	keys := make([]int64, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysInt64 returns a slice of map's keys
func KeysInt64(m map[int64]int64) []int64 {
	keys := make([]int64, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysInt64Int32 returns a slice of map's keys
func KeysInt64Int32(m map[int64]int32) []int64 {
	keys := make([]int64, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysInt64Int16 returns a slice of map's keys
func KeysInt64Int16(m map[int64]int16) []int64 {
	keys := make([]int64, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysInt64Int8 returns a slice of map's keys
func KeysInt64Int8(m map[int64]int8) []int64 {
	keys := make([]int64, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysInt64Uint returns a slice of map's keys
func KeysInt64Uint(m map[int64]uint) []int64 {
	keys := make([]int64, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysInt64Uint64 returns a slice of map's keys
func KeysInt64Uint64(m map[int64]uint64) []int64 {
	keys := make([]int64, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysInt64Uint32 returns a slice of map's keys
func KeysInt64Uint32(m map[int64]uint32) []int64 {
	keys := make([]int64, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysInt64Uint16 returns a slice of map's keys
func KeysInt64Uint16(m map[int64]uint16) []int64 {
	keys := make([]int64, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysInt64Uint8 returns a slice of map's keys
func KeysInt64Uint8(m map[int64]uint8) []int64 {
	keys := make([]int64, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysInt64Str returns a slice of map's keys
func KeysInt64Str(m map[int64]string) []int64 {
	keys := make([]int64, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysInt64Bool returns a slice of map's keys
func KeysInt64Bool(m map[int64]bool) []int64 {
	keys := make([]int64, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysInt64Float32 returns a slice of map's keys
func KeysInt64Float32(m map[int64]float32) []int64 {
	keys := make([]int64, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysInt64Float64 returns a slice of map's keys
func KeysInt64Float64(m map[int64]float64) []int64 {
	keys := make([]int64, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysInt32Int returns a slice of map's keys
func KeysInt32Int(m map[int32]int) []int32 {
	keys := make([]int32, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysInt32Int64 returns a slice of map's keys
func KeysInt32Int64(m map[int32]int64) []int32 {
	keys := make([]int32, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysInt32 returns a slice of map's keys
func KeysInt32(m map[int32]int32) []int32 {
	keys := make([]int32, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysInt32Int16 returns a slice of map's keys
func KeysInt32Int16(m map[int32]int16) []int32 {
	keys := make([]int32, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysInt32Int8 returns a slice of map's keys
func KeysInt32Int8(m map[int32]int8) []int32 {
	keys := make([]int32, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysInt32Uint returns a slice of map's keys
func KeysInt32Uint(m map[int32]uint) []int32 {
	keys := make([]int32, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysInt32Uint64 returns a slice of map's keys
func KeysInt32Uint64(m map[int32]uint64) []int32 {
	keys := make([]int32, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysInt32Uint32 returns a slice of map's keys
func KeysInt32Uint32(m map[int32]uint32) []int32 {
	keys := make([]int32, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysInt32Uint16 returns a slice of map's keys
func KeysInt32Uint16(m map[int32]uint16) []int32 {
	keys := make([]int32, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysInt32Uint8 returns a slice of map's keys
func KeysInt32Uint8(m map[int32]uint8) []int32 {
	keys := make([]int32, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysInt32Str returns a slice of map's keys
func KeysInt32Str(m map[int32]string) []int32 {
	keys := make([]int32, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysInt32Bool returns a slice of map's keys
func KeysInt32Bool(m map[int32]bool) []int32 {
	keys := make([]int32, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysInt32Float32 returns a slice of map's keys
func KeysInt32Float32(m map[int32]float32) []int32 {
	keys := make([]int32, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysInt32Float64 returns a slice of map's keys
func KeysInt32Float64(m map[int32]float64) []int32 {
	keys := make([]int32, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysInt16Int returns a slice of map's keys
func KeysInt16Int(m map[int16]int) []int16 {
	keys := make([]int16, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysInt16Int64 returns a slice of map's keys
func KeysInt16Int64(m map[int16]int64) []int16 {
	keys := make([]int16, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysInt16Int32 returns a slice of map's keys
func KeysInt16Int32(m map[int16]int32) []int16 {
	keys := make([]int16, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysInt16 returns a slice of map's keys
func KeysInt16(m map[int16]int16) []int16 {
	keys := make([]int16, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysInt16Int8 returns a slice of map's keys
func KeysInt16Int8(m map[int16]int8) []int16 {
	keys := make([]int16, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysInt16Uint returns a slice of map's keys
func KeysInt16Uint(m map[int16]uint) []int16 {
	keys := make([]int16, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysInt16Uint64 returns a slice of map's keys
func KeysInt16Uint64(m map[int16]uint64) []int16 {
	keys := make([]int16, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysInt16Uint32 returns a slice of map's keys
func KeysInt16Uint32(m map[int16]uint32) []int16 {
	keys := make([]int16, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysInt16Uint16 returns a slice of map's keys
func KeysInt16Uint16(m map[int16]uint16) []int16 {
	keys := make([]int16, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysInt16Uint8 returns a slice of map's keys
func KeysInt16Uint8(m map[int16]uint8) []int16 {
	keys := make([]int16, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysInt16Str returns a slice of map's keys
func KeysInt16Str(m map[int16]string) []int16 {
	keys := make([]int16, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysInt16Bool returns a slice of map's keys
func KeysInt16Bool(m map[int16]bool) []int16 {
	keys := make([]int16, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysInt16Float32 returns a slice of map's keys
func KeysInt16Float32(m map[int16]float32) []int16 {
	keys := make([]int16, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysInt16Float64 returns a slice of map's keys
func KeysInt16Float64(m map[int16]float64) []int16 {
	keys := make([]int16, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysInt8Int returns a slice of map's keys
func KeysInt8Int(m map[int8]int) []int8 {
	keys := make([]int8, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysInt8Int64 returns a slice of map's keys
func KeysInt8Int64(m map[int8]int64) []int8 {
	keys := make([]int8, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysInt8Int32 returns a slice of map's keys
func KeysInt8Int32(m map[int8]int32) []int8 {
	keys := make([]int8, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysInt8Int16 returns a slice of map's keys
func KeysInt8Int16(m map[int8]int16) []int8 {
	keys := make([]int8, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysInt8 returns a slice of map's keys
func KeysInt8(m map[int8]int8) []int8 {
	keys := make([]int8, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysInt8Uint returns a slice of map's keys
func KeysInt8Uint(m map[int8]uint) []int8 {
	keys := make([]int8, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysInt8Uint64 returns a slice of map's keys
func KeysInt8Uint64(m map[int8]uint64) []int8 {
	keys := make([]int8, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysInt8Uint32 returns a slice of map's keys
func KeysInt8Uint32(m map[int8]uint32) []int8 {
	keys := make([]int8, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysInt8Uint16 returns a slice of map's keys
func KeysInt8Uint16(m map[int8]uint16) []int8 {
	keys := make([]int8, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysInt8Uint8 returns a slice of map's keys
func KeysInt8Uint8(m map[int8]uint8) []int8 {
	keys := make([]int8, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysInt8Str returns a slice of map's keys
func KeysInt8Str(m map[int8]string) []int8 {
	keys := make([]int8, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysInt8Bool returns a slice of map's keys
func KeysInt8Bool(m map[int8]bool) []int8 {
	keys := make([]int8, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysInt8Float32 returns a slice of map's keys
func KeysInt8Float32(m map[int8]float32) []int8 {
	keys := make([]int8, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysInt8Float64 returns a slice of map's keys
func KeysInt8Float64(m map[int8]float64) []int8 {
	keys := make([]int8, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysUintInt returns a slice of map's keys
func KeysUintInt(m map[uint]int) []uint {
	keys := make([]uint, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysUintInt64 returns a slice of map's keys
func KeysUintInt64(m map[uint]int64) []uint {
	keys := make([]uint, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysUintInt32 returns a slice of map's keys
func KeysUintInt32(m map[uint]int32) []uint {
	keys := make([]uint, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysUintInt16 returns a slice of map's keys
func KeysUintInt16(m map[uint]int16) []uint {
	keys := make([]uint, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysUintInt8 returns a slice of map's keys
func KeysUintInt8(m map[uint]int8) []uint {
	keys := make([]uint, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysUint returns a slice of map's keys
func KeysUint(m map[uint]uint) []uint {
	keys := make([]uint, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysUintUint64 returns a slice of map's keys
func KeysUintUint64(m map[uint]uint64) []uint {
	keys := make([]uint, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysUintUint32 returns a slice of map's keys
func KeysUintUint32(m map[uint]uint32) []uint {
	keys := make([]uint, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysUintUint16 returns a slice of map's keys
func KeysUintUint16(m map[uint]uint16) []uint {
	keys := make([]uint, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysUintUint8 returns a slice of map's keys
func KeysUintUint8(m map[uint]uint8) []uint {
	keys := make([]uint, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysUintStr returns a slice of map's keys
func KeysUintStr(m map[uint]string) []uint {
	keys := make([]uint, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysUintBool returns a slice of map's keys
func KeysUintBool(m map[uint]bool) []uint {
	keys := make([]uint, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysUintFloat32 returns a slice of map's keys
func KeysUintFloat32(m map[uint]float32) []uint {
	keys := make([]uint, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysUintFloat64 returns a slice of map's keys
func KeysUintFloat64(m map[uint]float64) []uint {
	keys := make([]uint, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysUint64Int returns a slice of map's keys
func KeysUint64Int(m map[uint64]int) []uint64 {
	keys := make([]uint64, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysUint64Int64 returns a slice of map's keys
func KeysUint64Int64(m map[uint64]int64) []uint64 {
	keys := make([]uint64, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysUint64Int32 returns a slice of map's keys
func KeysUint64Int32(m map[uint64]int32) []uint64 {
	keys := make([]uint64, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysUint64Int16 returns a slice of map's keys
func KeysUint64Int16(m map[uint64]int16) []uint64 {
	keys := make([]uint64, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysUint64Int8 returns a slice of map's keys
func KeysUint64Int8(m map[uint64]int8) []uint64 {
	keys := make([]uint64, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysUint64Uint returns a slice of map's keys
func KeysUint64Uint(m map[uint64]uint) []uint64 {
	keys := make([]uint64, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysUint64 returns a slice of map's keys
func KeysUint64(m map[uint64]uint64) []uint64 {
	keys := make([]uint64, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysUint64Uint32 returns a slice of map's keys
func KeysUint64Uint32(m map[uint64]uint32) []uint64 {
	keys := make([]uint64, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysUint64Uint16 returns a slice of map's keys
func KeysUint64Uint16(m map[uint64]uint16) []uint64 {
	keys := make([]uint64, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysUint64Uint8 returns a slice of map's keys
func KeysUint64Uint8(m map[uint64]uint8) []uint64 {
	keys := make([]uint64, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysUint64Str returns a slice of map's keys
func KeysUint64Str(m map[uint64]string) []uint64 {
	keys := make([]uint64, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysUint64Bool returns a slice of map's keys
func KeysUint64Bool(m map[uint64]bool) []uint64 {
	keys := make([]uint64, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysUint64Float32 returns a slice of map's keys
func KeysUint64Float32(m map[uint64]float32) []uint64 {
	keys := make([]uint64, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysUint64Float64 returns a slice of map's keys
func KeysUint64Float64(m map[uint64]float64) []uint64 {
	keys := make([]uint64, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysUint32Int returns a slice of map's keys
func KeysUint32Int(m map[uint32]int) []uint32 {
	keys := make([]uint32, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysUint32Int64 returns a slice of map's keys
func KeysUint32Int64(m map[uint32]int64) []uint32 {
	keys := make([]uint32, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysUint32Int32 returns a slice of map's keys
func KeysUint32Int32(m map[uint32]int32) []uint32 {
	keys := make([]uint32, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysUint32Int16 returns a slice of map's keys
func KeysUint32Int16(m map[uint32]int16) []uint32 {
	keys := make([]uint32, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysUint32Int8 returns a slice of map's keys
func KeysUint32Int8(m map[uint32]int8) []uint32 {
	keys := make([]uint32, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysUint32Uint returns a slice of map's keys
func KeysUint32Uint(m map[uint32]uint) []uint32 {
	keys := make([]uint32, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysUint32Uint64 returns a slice of map's keys
func KeysUint32Uint64(m map[uint32]uint64) []uint32 {
	keys := make([]uint32, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysUint32 returns a slice of map's keys
func KeysUint32(m map[uint32]uint32) []uint32 {
	keys := make([]uint32, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysUint32Uint16 returns a slice of map's keys
func KeysUint32Uint16(m map[uint32]uint16) []uint32 {
	keys := make([]uint32, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysUint32Uint8 returns a slice of map's keys
func KeysUint32Uint8(m map[uint32]uint8) []uint32 {
	keys := make([]uint32, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysUint32Str returns a slice of map's keys
func KeysUint32Str(m map[uint32]string) []uint32 {
	keys := make([]uint32, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysUint32Bool returns a slice of map's keys
func KeysUint32Bool(m map[uint32]bool) []uint32 {
	keys := make([]uint32, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysUint32Float32 returns a slice of map's keys
func KeysUint32Float32(m map[uint32]float32) []uint32 {
	keys := make([]uint32, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysUint32Float64 returns a slice of map's keys
func KeysUint32Float64(m map[uint32]float64) []uint32 {
	keys := make([]uint32, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysUint16Int returns a slice of map's keys
func KeysUint16Int(m map[uint16]int) []uint16 {
	keys := make([]uint16, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysUint16Int64 returns a slice of map's keys
func KeysUint16Int64(m map[uint16]int64) []uint16 {
	keys := make([]uint16, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysUint16Int32 returns a slice of map's keys
func KeysUint16Int32(m map[uint16]int32) []uint16 {
	keys := make([]uint16, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysUint16Int16 returns a slice of map's keys
func KeysUint16Int16(m map[uint16]int16) []uint16 {
	keys := make([]uint16, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysUint16Int8 returns a slice of map's keys
func KeysUint16Int8(m map[uint16]int8) []uint16 {
	keys := make([]uint16, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysUint16Uint returns a slice of map's keys
func KeysUint16Uint(m map[uint16]uint) []uint16 {
	keys := make([]uint16, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysUint16Uint64 returns a slice of map's keys
func KeysUint16Uint64(m map[uint16]uint64) []uint16 {
	keys := make([]uint16, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysUint16Uint32 returns a slice of map's keys
func KeysUint16Uint32(m map[uint16]uint32) []uint16 {
	keys := make([]uint16, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysUint16 returns a slice of map's keys
func KeysUint16(m map[uint16]uint16) []uint16 {
	keys := make([]uint16, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysUint16Uint8 returns a slice of map's keys
func KeysUint16Uint8(m map[uint16]uint8) []uint16 {
	keys := make([]uint16, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysUint16Str returns a slice of map's keys
func KeysUint16Str(m map[uint16]string) []uint16 {
	keys := make([]uint16, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysUint16Bool returns a slice of map's keys
func KeysUint16Bool(m map[uint16]bool) []uint16 {
	keys := make([]uint16, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysUint16Float32 returns a slice of map's keys
func KeysUint16Float32(m map[uint16]float32) []uint16 {
	keys := make([]uint16, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysUint16Float64 returns a slice of map's keys
func KeysUint16Float64(m map[uint16]float64) []uint16 {
	keys := make([]uint16, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysUint8Int returns a slice of map's keys
func KeysUint8Int(m map[uint8]int) []uint8 {
	keys := make([]uint8, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysUint8Int64 returns a slice of map's keys
func KeysUint8Int64(m map[uint8]int64) []uint8 {
	keys := make([]uint8, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysUint8Int32 returns a slice of map's keys
func KeysUint8Int32(m map[uint8]int32) []uint8 {
	keys := make([]uint8, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysUint8Int16 returns a slice of map's keys
func KeysUint8Int16(m map[uint8]int16) []uint8 {
	keys := make([]uint8, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysUint8Int8 returns a slice of map's keys
func KeysUint8Int8(m map[uint8]int8) []uint8 {
	keys := make([]uint8, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysUint8Uint returns a slice of map's keys
func KeysUint8Uint(m map[uint8]uint) []uint8 {
	keys := make([]uint8, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysUint8Uint64 returns a slice of map's keys
func KeysUint8Uint64(m map[uint8]uint64) []uint8 {
	keys := make([]uint8, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysUint8Uint32 returns a slice of map's keys
func KeysUint8Uint32(m map[uint8]uint32) []uint8 {
	keys := make([]uint8, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysUint8Uint16 returns a slice of map's keys
func KeysUint8Uint16(m map[uint8]uint16) []uint8 {
	keys := make([]uint8, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysUint8 returns a slice of map's keys
func KeysUint8(m map[uint8]uint8) []uint8 {
	keys := make([]uint8, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysUint8Str returns a slice of map's keys
func KeysUint8Str(m map[uint8]string) []uint8 {
	keys := make([]uint8, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysUint8Bool returns a slice of map's keys
func KeysUint8Bool(m map[uint8]bool) []uint8 {
	keys := make([]uint8, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysUint8Float32 returns a slice of map's keys
func KeysUint8Float32(m map[uint8]float32) []uint8 {
	keys := make([]uint8, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysUint8Float64 returns a slice of map's keys
func KeysUint8Float64(m map[uint8]float64) []uint8 {
	keys := make([]uint8, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysStrInt returns a slice of map's keys
func KeysStrInt(m map[string]int) []string {
	keys := make([]string, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysStrInt64 returns a slice of map's keys
func KeysStrInt64(m map[string]int64) []string {
	keys := make([]string, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysStrInt32 returns a slice of map's keys
func KeysStrInt32(m map[string]int32) []string {
	keys := make([]string, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysStrInt16 returns a slice of map's keys
func KeysStrInt16(m map[string]int16) []string {
	keys := make([]string, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysStrInt8 returns a slice of map's keys
func KeysStrInt8(m map[string]int8) []string {
	keys := make([]string, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysStrUint returns a slice of map's keys
func KeysStrUint(m map[string]uint) []string {
	keys := make([]string, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysStrUint64 returns a slice of map's keys
func KeysStrUint64(m map[string]uint64) []string {
	keys := make([]string, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysStrUint32 returns a slice of map's keys
func KeysStrUint32(m map[string]uint32) []string {
	keys := make([]string, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysStrUint16 returns a slice of map's keys
func KeysStrUint16(m map[string]uint16) []string {
	keys := make([]string, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysStrUint8 returns a slice of map's keys
func KeysStrUint8(m map[string]uint8) []string {
	keys := make([]string, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysStr returns a slice of map's keys
func KeysStr(m map[string]string) []string {
	keys := make([]string, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysStrBool returns a slice of map's keys
func KeysStrBool(m map[string]bool) []string {
	keys := make([]string, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysStrFloat32 returns a slice of map's keys
func KeysStrFloat32(m map[string]float32) []string {
	keys := make([]string, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysStrFloat64 returns a slice of map's keys
func KeysStrFloat64(m map[string]float64) []string {
	keys := make([]string, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysBoolInt returns a slice of map's keys
func KeysBoolInt(m map[bool]int) []bool {
	keys := make([]bool, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysBoolInt64 returns a slice of map's keys
func KeysBoolInt64(m map[bool]int64) []bool {
	keys := make([]bool, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysBoolInt32 returns a slice of map's keys
func KeysBoolInt32(m map[bool]int32) []bool {
	keys := make([]bool, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysBoolInt16 returns a slice of map's keys
func KeysBoolInt16(m map[bool]int16) []bool {
	keys := make([]bool, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysBoolInt8 returns a slice of map's keys
func KeysBoolInt8(m map[bool]int8) []bool {
	keys := make([]bool, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysBoolUint returns a slice of map's keys
func KeysBoolUint(m map[bool]uint) []bool {
	keys := make([]bool, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysBoolUint64 returns a slice of map's keys
func KeysBoolUint64(m map[bool]uint64) []bool {
	keys := make([]bool, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysBoolUint32 returns a slice of map's keys
func KeysBoolUint32(m map[bool]uint32) []bool {
	keys := make([]bool, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysBoolUint16 returns a slice of map's keys
func KeysBoolUint16(m map[bool]uint16) []bool {
	keys := make([]bool, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysBoolUint8 returns a slice of map's keys
func KeysBoolUint8(m map[bool]uint8) []bool {
	keys := make([]bool, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysBoolStr returns a slice of map's keys
func KeysBoolStr(m map[bool]string) []bool {
	keys := make([]bool, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysBool returns a slice of map's keys
func KeysBool(m map[bool]bool) []bool {
	keys := make([]bool, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysBoolFloat32 returns a slice of map's keys
func KeysBoolFloat32(m map[bool]float32) []bool {
	keys := make([]bool, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysBoolFloat64 returns a slice of map's keys
func KeysBoolFloat64(m map[bool]float64) []bool {
	keys := make([]bool, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysFloat32Int returns a slice of map's keys
func KeysFloat32Int(m map[float32]int) []float32 {
	keys := make([]float32, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysFloat32Int64 returns a slice of map's keys
func KeysFloat32Int64(m map[float32]int64) []float32 {
	keys := make([]float32, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysFloat32Int32 returns a slice of map's keys
func KeysFloat32Int32(m map[float32]int32) []float32 {
	keys := make([]float32, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysFloat32Int16 returns a slice of map's keys
func KeysFloat32Int16(m map[float32]int16) []float32 {
	keys := make([]float32, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysFloat32Int8 returns a slice of map's keys
func KeysFloat32Int8(m map[float32]int8) []float32 {
	keys := make([]float32, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysFloat32Uint returns a slice of map's keys
func KeysFloat32Uint(m map[float32]uint) []float32 {
	keys := make([]float32, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysFloat32Uint64 returns a slice of map's keys
func KeysFloat32Uint64(m map[float32]uint64) []float32 {
	keys := make([]float32, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysFloat32Uint32 returns a slice of map's keys
func KeysFloat32Uint32(m map[float32]uint32) []float32 {
	keys := make([]float32, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysFloat32Uint16 returns a slice of map's keys
func KeysFloat32Uint16(m map[float32]uint16) []float32 {
	keys := make([]float32, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysFloat32Uint8 returns a slice of map's keys
func KeysFloat32Uint8(m map[float32]uint8) []float32 {
	keys := make([]float32, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysFloat32Str returns a slice of map's keys
func KeysFloat32Str(m map[float32]string) []float32 {
	keys := make([]float32, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysFloat32Bool returns a slice of map's keys
func KeysFloat32Bool(m map[float32]bool) []float32 {
	keys := make([]float32, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysFloat32 returns a slice of map's keys
func KeysFloat32(m map[float32]float32) []float32 {
	keys := make([]float32, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysFloat32Float64 returns a slice of map's keys
func KeysFloat32Float64(m map[float32]float64) []float32 {
	keys := make([]float32, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysFloat64Int returns a slice of map's keys
func KeysFloat64Int(m map[float64]int) []float64 {
	keys := make([]float64, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysFloat64Int64 returns a slice of map's keys
func KeysFloat64Int64(m map[float64]int64) []float64 {
	keys := make([]float64, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysFloat64Int32 returns a slice of map's keys
func KeysFloat64Int32(m map[float64]int32) []float64 {
	keys := make([]float64, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysFloat64Int16 returns a slice of map's keys
func KeysFloat64Int16(m map[float64]int16) []float64 {
	keys := make([]float64, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysFloat64Int8 returns a slice of map's keys
func KeysFloat64Int8(m map[float64]int8) []float64 {
	keys := make([]float64, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysFloat64Uint returns a slice of map's keys
func KeysFloat64Uint(m map[float64]uint) []float64 {
	keys := make([]float64, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysFloat64Uint64 returns a slice of map's keys
func KeysFloat64Uint64(m map[float64]uint64) []float64 {
	keys := make([]float64, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysFloat64Uint32 returns a slice of map's keys
func KeysFloat64Uint32(m map[float64]uint32) []float64 {
	keys := make([]float64, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysFloat64Uint16 returns a slice of map's keys
func KeysFloat64Uint16(m map[float64]uint16) []float64 {
	keys := make([]float64, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysFloat64Uint8 returns a slice of map's keys
func KeysFloat64Uint8(m map[float64]uint8) []float64 {
	keys := make([]float64, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysFloat64Str returns a slice of map's keys
func KeysFloat64Str(m map[float64]string) []float64 {
	keys := make([]float64, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysFloat64Bool returns a slice of map's keys
func KeysFloat64Bool(m map[float64]bool) []float64 {
	keys := make([]float64, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysFloat64Float32 returns a slice of map's keys
func KeysFloat64Float32(m map[float64]float32) []float64 {
	keys := make([]float64, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// KeysFloat64 returns a slice of map's keys
func KeysFloat64(m map[float64]float64) []float64 {
	keys := make([]float64, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}
